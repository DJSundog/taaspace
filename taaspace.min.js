(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.taaspace = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
module.exports = function loadimages(imgSrcs, then) {
  // Parameters
  //   imgSrcs
  //     array of image source paths OR single source path string.
  //   then(err, imgElements)
  //     Will be called after all the images are loaded. If string was given,
  //     imgElements is an Image instead of array of Images.

  var numberOfImages, stringGiven, thereWasSuccess, thereWasError, imgs;
  var onloadsCalled, onload, onerror;

  if (typeof then !== 'function') {
    throw new Error('callback should be a function: ' + then);
  }

  if (typeof imgSrcs === 'string') {
    numberOfImages = 1;
    stringGiven = true;
    imgSrcs = [imgSrcs]; // Normalize
  } else {
    // Array of images
    numberOfImages = imgSrcs.length;
    stringGiven = false;
  }
  thereWasSuccess = false;
  thereWasError = false;

  imgs = [];

  onloadsCalled = 0;
  onload = function () {
    // Note:
    //   this = Image
    if (!thereWasError) {
      onloadsCalled += 1;
      var isFinalImage = (onloadsCalled === numberOfImages);
      if (isFinalImage) {
        thereWasSuccess = true;
        if (stringGiven) {
          then(null, imgs[0]);
        } else {
          then(null, imgs);
        }
      }
    }
  };

  onerror = function (errMsg) {
    // Note:
    //   this = Image

    // No errors after success.
    if (!thereWasSuccess) {
      thereWasError = true;
      then(errMsg, null);
    }

    // Prevent firing the default event handler
    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror#Parameters
    return true;
  };

  for (i = 0; i < imgSrcs.length; i += 1) {
    imgs.push(new Image());
    imgs[i].onload = onload;
    imgs[i].onerror = onerror;
    imgs[i].src = imgSrcs[i];
  }
};

},{}],3:[function(require,module,exports){
/**
 * Module Dependencies.
 */

var Emitter = require('component-emitter');
var query = require('component-query');
var after = require('after-transition');
var has3d = require('has-translate3d');
var ease = require('css-ease');

/**
 * CSS Translate
 */

var translate = has3d
  ? ['translate3d(', ', 0)']
  : ['translate(', ')'];

/**
 * Export `Move`
 */

module.exports = Move;

/**
 * Get computed style.
 */

var style = window.getComputedStyle
  || window.currentStyle;

/**
 * Library version.
 */

Move.version = '0.5.0';

/**
 * Export `ease`
 */

Move.ease = ease;

/**
 * Defaults.
 *
 *   `duration` - default duration of 500ms
 *
 */

Move.defaults = {
  duration: 500
};

/**
 * Default element selection utilized by `move(selector)`.
 *
 * Override to implement your own selection, for example
 * with jQuery one might write:
 *
 *     move.select = function(selector) {
 *       return jQuery(selector).get(0);
 *     };
 *
 * @param {Object|String} selector
 * @return {Element}
 * @api public
 */

Move.select = function(selector){
  if ('string' != typeof selector) return selector;
  return query(selector);
};

/**
 * Initialize a new `Move` with the given `el`.
 *
 * @param {Element} el
 * @api public
 */

function Move(el) {
  if (!(this instanceof Move)) return new Move(el);
  if ('string' == typeof el) el = query(el);
  if (!el) throw new TypeError('Move must be initialized with element or selector');
  this.el = el;
  this._props = {};
  this._rotate = 0;
  this._transitionProps = [];
  this._transforms = [];
  this.duration(Move.defaults.duration)
};


/**
 * Inherit from `EventEmitter.prototype`.
 */

Emitter(Move.prototype);

/**
 * Buffer `transform`.
 *
 * @param {String} transform
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transform = function(transform){
  this._transforms.push(transform);
  return this;
};

/**
 * Skew `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skew = function(x, y){
  return this.transform('skew('
    + x + 'deg, '
    + (y || 0)
    + 'deg)');
};

/**
 * Skew x by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewX = function(n){
  return this.transform('skewX(' + n + 'deg)');
};

/**
 * Skew y by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewY = function(n){
  return this.transform('skewY(' + n + 'deg)');
};

/**
 * Translate `x` and `y` axis.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translate =
Move.prototype.to = function(x, y){
  return this.transform(translate.join(''
    + x +'px, '
    + (y || 0)
    + 'px'));
};

/**
 * Translate on the x axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateX =
Move.prototype.x = function(n){
  return this.transform('translateX(' + n + 'px)');
};

/**
 * Translate on the y axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateY =
Move.prototype.y = function(n){
  return this.transform('translateY(' + n + 'px)');
};

/**
 * Scale the x and y axis by `x`, or
 * individually scale `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scale = function(x, y){
  return this.transform('scale('
    + x + ', '
    + (y || x)
    + ')');
};

/**
 * Scale x axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleX = function(n){
  return this.transform('scaleX(' + n + ')')
};

/**
 * Apply a matrix transformation
 *
 * @param {Number} m11 A matrix coefficient
 * @param {Number} m12 A matrix coefficient
 * @param {Number} m21 A matrix coefficient
 * @param {Number} m22 A matrix coefficient
 * @param {Number} m31 A matrix coefficient
 * @param {Number} m32 A matrix coefficient
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.matrix = function(m11, m12, m21, m22, m31, m32){
  return this.transform('matrix(' + [m11,m12,m21,m22,m31,m32].join(',') + ')');
};

/**
 * Scale y axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleY = function(n){
  return this.transform('scaleY(' + n + ')')
};

/**
 * Rotate `n` degrees.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.rotate = function(n){
  return this.transform('rotate(' + n + 'deg)');
};

/**
 * Set transition easing function to to `fn` string.
 *
 * When:
 *
 *   - null "ease" is used
 *   - "in" "ease-in" is used
 *   - "out" "ease-out" is used
 *   - "in-out" "ease-in-out" is used
 *
 * @param {String} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.ease = function(fn){
  fn = ease[fn] || fn || 'ease';
  return this.setVendorProperty('transition-timing-function', fn);
};

/**
 * Set animation properties
 *
 * @param {String} name
 * @param {Object} props
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.animate = function(name, props){
  for (var i in props){
    if (props.hasOwnProperty(i)){
      this.setVendorProperty('animation-' + i, props[i])
    }
  }
  return this.setVendorProperty('animation-name', name);
}

/**
 * Set duration to `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.duration = function(n){
  n = this._duration = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-duration', n + 'ms');
};

/**
 * Delay the animation by `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.delay = function(n){
  n = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-delay', n + 'ms');
};

/**
 * Set `prop` to `val`, deferred until `.end()` is invoked.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setProperty = function(prop, val){
  this._props[prop] = val;
  return this;
};

/**
 * Set a vendor prefixed `prop` with the given `val`.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setVendorProperty = function(prop, val){
  this.setProperty('-webkit-' + prop, val);
  this.setProperty('-moz-' + prop, val);
  this.setProperty('-ms-' + prop, val);
  this.setProperty('-o-' + prop, val);
  return this;
};

/**
 * Set `prop` to `value`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.set = function(prop, val){
  this.transition(prop);
  this._props[prop] = val;
  return this;
};

/**
 * Increment `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.add = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr + val + 'px');
  });
};

/**
 * Decrement `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.sub = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr - val + 'px');
  });
};

/**
 * Get computed or "current" value of `prop`.
 *
 * @param {String} prop
 * @return {String}
 * @api public
 */

Move.prototype.current = function(prop){
  return style(this.el).getPropertyValue(prop);
};

/**
 * Add `prop` to the list of internal transition properties.
 *
 * @param {String} prop
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transition = function(prop){
  if (!this._transitionProps.indexOf(prop)) return this;
  this._transitionProps.push(prop);
  return this;
};

/**
 * Commit style properties, aka apply them to `el.style`.
 *
 * @return {Move} for chaining
 * @see Move#end()
 * @api private
 */

Move.prototype.applyProperties = function(){
  for (var prop in this._props) {
    this.el.style.setProperty(prop, this._props[prop], '');
  }
  return this;
};

/**
 * Re-select element via `selector`, replacing
 * the current element.
 *
 * @param {String} selector
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.move =
Move.prototype.select = function(selector){
  this.el = Move.select(selector);
  return this;
};

/**
 * Defer the given `fn` until the animation
 * is complete. `fn` may be one of the following:
 *
 *   - a function to invoke
 *   - an instanceof `Move` to call `.end()`
 *   - nothing, to return a clone of this `Move` instance for chaining
 *
 * @param {Function|Move} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.then = function(fn){
  // invoke .end()
  if (fn instanceof Move) {
    this.on('end', function(){
      fn.end();
    });
  // callback
  } else if ('function' == typeof fn) {
    this.on('end', fn);
  // chain
  } else {
    var clone = new Move(this.el);
    clone._transforms = this._transforms.slice(0);
    this.then(clone);
    clone.parent = this;
    return clone;
  }

  return this;
};

/**
 * Pop the move context.
 *
 * @return {Move} parent Move
 * @api public
 */

Move.prototype.pop = function(){
  return this.parent;
};

/**
 * Reset duration.
 *
 * @return {Move}
 * @api public
 */

Move.prototype.reset = function(){
  this.el.style.webkitTransitionDuration =
  this.el.style.mozTransitionDuration =
  this.el.style.msTransitionDuration =
  this.el.style.oTransitionDuration = '';
  return this;
};

/**
 * Start animation, optionally calling `fn` when complete.
 *
 * @param {Function} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.end = function(fn){
  var self = this;

  // emit "start" event
  this.emit('start');

  // transforms
  if (this._transforms.length) {
    this.setVendorProperty('transform', this._transforms.join(' '));
  }

  // transition properties
  this.setVendorProperty('transition-properties', this._transitionProps.join(', '));
  this.applyProperties();

  // callback given
  if (fn) this.then(fn);

  // emit "end" when complete
  after.once(this.el, function(){
    self.reset();
    self.emit('end');
  });

  return this;
};

},{"after-transition":4,"component-emitter":1,"component-query":8,"css-ease":9,"has-translate3d":10}],4:[function(require,module,exports){
var hasTransitions = require('has-transitions');
var emitter = require('css-emitter');

function afterTransition(el, callback) {
  if(hasTransitions(el)) {
    return emitter(el).bind(callback);
  }
  return callback.apply(el);
};

afterTransition.once = function(el, callback) {
  afterTransition(el, function fn(){
    callback.apply(el);
    emitter(el).unbind(fn);
  });
};

module.exports = afterTransition;
},{"css-emitter":5,"has-transitions":7}],5:[function(require,module,exports){
/**
 * Module Dependencies
 */

var events = require('event');

// CSS events

var watch = [
  'transitionend'
, 'webkitTransitionEnd'
, 'oTransitionEnd'
, 'MSTransitionEnd'
, 'animationend'
, 'webkitAnimationEnd'
, 'oAnimationEnd'
, 'MSAnimationEnd'
];

/**
 * Expose `CSSnext`
 */

module.exports = CssEmitter;

/**
 * Initialize a new `CssEmitter`
 *
 */

function CssEmitter(element){
  if (!(this instanceof CssEmitter)) return new CssEmitter(element);
  this.el = element;
}

/**
 * Bind CSS events.
 *
 * @api public
 */

CssEmitter.prototype.bind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.bind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Unbind CSS events
 * 
 * @api public
 */

CssEmitter.prototype.unbind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.unbind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Fire callback only once
 * 
 * @api public
 */

CssEmitter.prototype.once = function(fn){
  var self = this;
  function on(){
    self.unbind(on);
    fn.apply(self.el, arguments);
  }
  self.bind(on);
  return this;
};


},{"event":6}],6:[function(require,module,exports){

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  if (el.addEventListener) {
    el.addEventListener(type, fn, capture);
  } else {
    el.attachEvent('on' + type, fn);
  }
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  if (el.removeEventListener) {
    el.removeEventListener(type, fn, capture);
  } else {
    el.detachEvent('on' + type, fn);
  }
  return fn;
};

},{}],7:[function(require,module,exports){
/**
 * This will store the property that the current
 * browser uses for transitionDuration
 */
var property;

/**
 * The properties we'll check on an element
 * to determine if it actually has transitions
 * We use duration as this is the only property
 * needed to technically have transitions
 * @type {Array}
 */
var types = [
  "transitionDuration",
  "MozTransitionDuration",
  "webkitTransitionDuration"
];

/**
 * Determine the correct property for this browser
 * just once so we done need to check every time
 */
while(types.length) {
  var type = types.shift();
  if(type in document.body.style) {
    property = type;
  }
}

/**
 * Determine if the browser supports transitions or
 * if an element has transitions at all.
 * @param  {Element}  el Optional. Returns browser support if not included
 * @return {Boolean}
 */
function hasTransitions(el){
  if(!property) {
    return false; // No browser support for transitions
  }
  if(!el) {
    return property != null; // We just want to know if browsers support it
  }
  var duration = getComputedStyle(el)[property];
  return duration !== "" && parseFloat(duration) !== 0; // Does this element have transitions?
}

module.exports = hasTransitions;
},{}],8:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],9:[function(require,module,exports){

/**
 * CSS Easing functions
 */

module.exports = {
    'in':                'ease-in'
  , 'out':               'ease-out'
  , 'in-out':            'ease-in-out'
  , 'snap':              'cubic-bezier(0,1,.5,1)'
  , 'linear':            'cubic-bezier(0.250, 0.250, 0.750, 0.750)'
  , 'ease-in-quad':      'cubic-bezier(0.550, 0.085, 0.680, 0.530)'
  , 'ease-in-cubic':     'cubic-bezier(0.550, 0.055, 0.675, 0.190)'
  , 'ease-in-quart':     'cubic-bezier(0.895, 0.030, 0.685, 0.220)'
  , 'ease-in-quint':     'cubic-bezier(0.755, 0.050, 0.855, 0.060)'
  , 'ease-in-sine':      'cubic-bezier(0.470, 0.000, 0.745, 0.715)'
  , 'ease-in-expo':      'cubic-bezier(0.950, 0.050, 0.795, 0.035)'
  , 'ease-in-circ':      'cubic-bezier(0.600, 0.040, 0.980, 0.335)'
  , 'ease-in-back':      'cubic-bezier(0.600, -0.280, 0.735, 0.045)'
  , 'ease-out-quad':     'cubic-bezier(0.250, 0.460, 0.450, 0.940)'
  , 'ease-out-cubic':    'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
  , 'ease-out-quart':    'cubic-bezier(0.165, 0.840, 0.440, 1.000)'
  , 'ease-out-quint':    'cubic-bezier(0.230, 1.000, 0.320, 1.000)'
  , 'ease-out-sine':     'cubic-bezier(0.390, 0.575, 0.565, 1.000)'
  , 'ease-out-expo':     'cubic-bezier(0.190, 1.000, 0.220, 1.000)'
  , 'ease-out-circ':     'cubic-bezier(0.075, 0.820, 0.165, 1.000)'
  , 'ease-out-back':     'cubic-bezier(0.175, 0.885, 0.320, 1.275)'
  , 'ease-out-quad':     'cubic-bezier(0.455, 0.030, 0.515, 0.955)'
  , 'ease-out-cubic':    'cubic-bezier(0.645, 0.045, 0.355, 1.000)'
  , 'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'
  , 'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'
  , 'ease-in-out-sine':  'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
  , 'ease-in-out-expo':  'cubic-bezier(1.000, 0.000, 0.000, 1.000)'
  , 'ease-in-out-circ':  'cubic-bezier(0.785, 0.135, 0.150, 0.860)'
  , 'ease-in-out-back':  'cubic-bezier(0.680, -0.550, 0.265, 1.550)'
};

},{}],10:[function(require,module,exports){

var prop = require('transform-property');

// IE <=8 doesn't have `getComputedStyle`
if (!prop || !window.getComputedStyle) {
  module.exports = false;

} else {
  var map = {
    webkitTransform: '-webkit-transform',
    OTransform: '-o-transform',
    msTransform: '-ms-transform',
    MozTransform: '-moz-transform',
    transform: 'transform'
  };

  // from: https://gist.github.com/lorenzopolidori/3794226
  var el = document.createElement('div');
  el.style[prop] = 'translate3d(1px,1px,1px)';
  document.body.insertBefore(el, null);
  var val = getComputedStyle(el).getPropertyValue(map[prop]);
  document.body.removeChild(el);
  module.exports = null != val && val.length && 'none' != val;
}

},{"transform-property":11}],11:[function(require,module,exports){

var styles = [
  'webkitTransform',
  'MozTransform',
  'msTransform',
  'OTransform',
  'transform'
];

var el = document.createElement('p');
var style;

for (var i = 0; i < styles.length; i++) {
  style = styles[i];
  if (null != el.style[style]) {
    module.exports = style;
    break;
  }
}

},{}],12:[function(require,module,exports){
/*

*/
exports.Transform = require('./lib/Transform');
exports.estimateT = require('./lib/estimateT');
exports.estimateS = require('./lib/estimateS');
exports.estimateR = require('./lib/estimateR');
exports.estimateTS = require('./lib/estimateTS');
exports.estimateTR = require('./lib/estimateTR');
exports.estimateSR = require('./lib/estimateSR');
exports.estimateTSR = require('./lib/estimateTSR');
exports.version = require('./lib/version');

exports.estimate = function (type, domain, range, pivot) {
  // Parameter
  //   type
  //     string. One of the following: 'T', 'S', 'R', 'TS', 'TR', 'SR', 'TSR'
  //   domain
  //     array of 2d arrays
  //   range
  //     array of 2d arrays
  //   pivot
  //     optional 2d array, does nothing for translation estimators
  var name = 'estimate' + type.toUpperCase();
  if (exports.hasOwnProperty(name)) {
    return exports[name](domain, range, pivot);
  } // else
  throw new Error('Unknown estimator type: ' + type);
};

},{"./lib/Transform":13,"./lib/estimateR":14,"./lib/estimateS":15,"./lib/estimateSR":16,"./lib/estimateT":17,"./lib/estimateTR":18,"./lib/estimateTS":19,"./lib/estimateTSR":20,"./lib/version":21}],13:[function(require,module,exports){

var Transform = function (s, r, tx, ty) {

  // Public, to allow user access
  this.s = s;
  this.r = r;
  this.tx = tx;
  this.ty = ty;

  this.equals = function (t) {
    return (s === t.s && r === t.r && tx === t.tx && ty === t.ty);
  };

  this.transform = function (p) {
    // p
    //   point [x, y] or array of points [[x1,y1], [x2, y2], ...]

    if (typeof p[0] === 'number') {
      // Single point
      return [s * p[0] - r * p[1] + tx, r * p[0] + s * p[1] + ty];
    } // else

    var i, c = [];
    for (i = 0; i < p.length; i += 1) {
      c.push([s * p[i][0] - r * p[i][1] + tx, r * p[i][0] + s * p[i][1] + ty]);
    }
    return c;
  };

  this.getMatrix = function () {
    // Get the transformation matrix in the format common to
    // many APIs, including:
    // - kld-affine
    //
    // Return
    //   object o, having properties a, b, c, d, e, f:
    //   [ s  -r  tx ]   [ o.a  o.c  o.e ]
    //   [ r   s  ty ] = [ o.b  o.d  o.f ]
    //   [ 0   0   1 ]   [  -    -    -  ]
    return { a: s, b: r, c: -r, d: s, e: tx, f: ty };
  };

  this.getRotation = function () {
    // in rads
    return Math.atan2(r, s);
  };

  this.getScale = function () {
    // scale multiplier
    return Math.sqrt(r * r + s * s);
  };

  this.getTranslation = function () {
    return [tx, ty];
  };

  this.inverse = function () {
    // Return inversed transform instance
    // See note 2015-10-26-16-30
    var det = s * s + r * r;
    // Test if singular transformation. These might occur when all the range
    // points are the same, forcing the scale to drop to zero.
    var eps = 0.00000001;
    if (Math.abs(det) < eps) {
      throw new Error('Singular transformations cannot be inversed.');
    }
    var shat = s / det;
    var rhat = -r / det;
    var txhat = (-s * tx - r * ty) / det;
    var tyhat = ( r * tx - s * ty) / det;
    return new Transform(shat, rhat, txhat, tyhat);
  };

  this.translateBy = function (dx, dy) {
    return new Transform(s, r, tx + dx, ty + dy);
  };

  this.scaleBy = function (multiplier, pivot) {
    // Parameter
    //   multiplier
    //   pivot
    //     optional, a [x, y] point
    var m, x, y;
    m = multiplier; // alias
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    return new Transform(m * s, m * r, m * tx + (1-m) * x, m * ty + (1-m) * y);
  };

  this.rotateBy = function (radians, pivot) {
    // Parameter
    //   radians
    //     from positive x to positive y axis
    //   pivot
    //     optional, a [x, y] point
    var co, si, x, y, shat, rhat, txhat, tyhat;
    co = Math.cos(radians);
    si = Math.sin(radians);
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    shat = s * co - r * si;
    rhat = s * si + r * co;
    txhat = (tx - x) * co - (ty - y) * si + x;
    tyhat = (tx - x) * si + (ty - y) * co + y;
    return new Transform(shat, rhat, txhat, tyhat);
  };


  this.multiplyBy = function (transform) {
    // Multiply this transformation matrix A
    // from the right with the given transformation matrix B
    // and return the result AB

    // For reading aid:
    // s -r tx  t.s -r tx
    // r  s ty *  r  s ty
    // 0  0  1    0  0  1
    var t = transform; // alias
    var shat = s * t.s - r * t.r;
    var rhat = s * t.r + r * t.s;
    var txhat = s * t.tx - r * t.ty + tx;
    var tyhat = r * t.tx + s * t.ty + ty;
    return new Transform(shat, rhat, txhat, tyhat);
  };
};

Transform.IDENTITY = new Transform(1, 0, 0, 0);

module.exports = Transform;

},{}],14:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, ad, bc, bd, shat, rhat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = ad = bc = bd = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  p = ac + bd;
  q = ad - bc;

  D = Math.sqrt(p * p + q * q);

  if (D === 0) {
    // D === 0
    // <=> q === 0 and p === 0.
    // <=> ad === bc and ac === -bd
    // <=> domain in pivot OR range in pivot OR yet unknown cases
    //     where the angle cannot be determined.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  shat = p / D;
  rhat = q / D;
  tx = a0 - a0 * shat + b0 * rhat;
  ty = b0 - a0 * rhat - b0 * shat;

  return new Transform(shat, rhat, tx, ty);
};

},{"./Transform":13}],15:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, bd, aa, bb, shat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = bd = aa = bb = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    bd += b * d;
    aa += a * a;
    bb += b * b;
  }

  D = aa + bb;

  if (D === 0) {
    // All domain points equal the pivot.
    // Identity transform is then only solution.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  // Prevent negative scaling because it would be same as positive scaling
  // and rotation => limit to zero
  shat = Math.max(0, (ac + bd) / D);
  tx = (1 - shat) * a0;
  ty = (1 - shat) * b0;

  return new Transform(shat, 0, tx, ty);
};

},{"./Transform":13}],16:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  // Estimate optimal transformation given the domain and the range
  // so that the pivot point remains the same.
  //
  // Use cases
  //   - transform an image that has one corner fixed with a pin.
  //   - allow only scale and rotation by fixing the middle of the object
  //     to transform.
  //
  // Parameters
  //   domain, an array of [x, y] points
  //   range, an array of [x, y] points
  //   pivot, optional
  //     the point [x, y] that must remain constant in the tranformation.
  //     Defaults to origo [0, 0]
  //
  //
  var X, Y, N, s, r, tx, ty;

  // Optional pivot
  if (typeof pivot === 'undefined') {
    pivot = [0, 0];
  }

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  var v = pivot[0];
  var w = pivot[1];

  var i, a, b, c, d;
  var a2, b2;
  a2 = b2 = 0;
  var ac, bd, bc, ad;
  ac = bd = bc = ad = 0;

  for (i = 0; i < N; i += 1) {
    a = X[i][0] - v;
    b = X[i][1] - w;
    c = Y[i][0] - v;
    d = Y[i][1] - w;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
    bc += b * c;
    ad += a * d;
  }

  // Denominator = determinant.
  // It becomes zero iff N = 0 or X[i] = [v, w] for every i in [0, n).
  // In other words, iff all the domain points are under the fixed point or
  // there is no domain points.
  var den = a2 + b2;

  var eps = 0.00000001;
  if (Math.abs(den) < eps) {
    // The domain points are under the pivot or there is no domain points.
    // We assume identity transform be the simplest guess. It keeps
    // the domain points under the pivot if there is some.
    return new Transform(1, 0, 0, 0);
  }

  // Estimators
  s = (ac + bd) / den;
  r = (-bc + ad) / den;
  tx =  w * r - v * s + v;
  ty = -v * r - w * s + w;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],17:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  var i, N, a1, b1, c1, d1, txhat, tyhat;

  N = Math.min(domain.length, range.length);
  a1 = b1 = c1 = d1 = 0;

  if (N < 1) {
    // Assume identity transform be the best guess
    return Transform.IDENTITY;
  }

  for (i = 0; i < N; i += 1) {
    a1 += domain[i][0];
    b1 += domain[i][1];
    c1 += range[i][0];
    d1 += range[i][1];
  }

  txhat = (c1 - a1) / N;
  tyhat = (d1 - b1) / N;

  return new Transform(1, 0, txhat, tyhat);
};

},{"./Transform":13}],18:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, ac, ad, bc, bd;
  a1 = b1 = c1 = d1 = ac = ad = bc = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  // Denominator.
  var v = N * (ad - bc) - a1 * d1 + b1 * c1;
  var w = N * (ac + bd) - a1 * c1 - b1 * d1;
  var D = Math.sqrt(v * v + w * w);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> undecidable
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 - a1) / N, (d1 - b1) / N);
  }

  // Estimators
  var shat = w / D;
  var rhat = v / D;
  var txhat = (-a1 * shat + b1 * rhat + c1) / N;
  var tyhat = (-a1 * rhat - b1 * shat + d1) / N;

  return new Transform(shat, rhat, txhat, tyhat);
};

},{"./Transform":13}],19:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, a2, b2, ac, bd;
  a1 = b1 = c1 = d1 = a2 = b2 = ac = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  var N2 = N * N;
  var a12 = a1 * a1;
  var b12 = b1 * b1;
  var p = a2 + b2;
  var q = ac + bd;
  var D = N2 * p - N * (a12 + b12);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> all the domain points are the same
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  var shat = (N2 * q - N * (a1 * c1 + b1 * d1)) / D;
  var txhat = (-N * a1 * q + N * c1 * p - b12 * c1 + a1 * b1 * d1) / D;
  var tyhat = (-N * b1 * q + N * d1 * p - a12 * d1 + a1 * b1 * c1) / D;

  return new Transform(shat, 0, txhat, tyhat);
};

},{"./Transform":13}],20:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays
  var X, Y, N, s, r, tx, ty;

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  // If length is zero, no estimation can be done. We choose the indentity
  // transformation be the best quess.
  if (N === 0) {
    return new Transform(1, 0, 0, 0);
  } // else

  var i, a, b, c, d;
  var a1 = 0;
  var b1 = 0;
  var c1 = 0;
  var d1 = 0;
  var a2 = 0;
  var b2 = 0;
  var ad = 0;
  var bc = 0;
  var ac = 0;
  var bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ad += a * d;
    bc += b * c;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  // It is zero iff X[i] = X[j] for every i and j in [0, n).
  // In other words, iff all the domain points are the same or there is only one domain point.
  var den = N * a2 + N * b2 - a1 * a1 - b1 * b1;

  var eps = 0.00000001;
  if (-eps < den && den < eps) {
    // The domain points are the same.
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  s = (N * (ac + bd) - a1 * c1 - b1 * d1) / den;
  r = (N * (ad - bc) + b1 * c1 - a1 * d1) / den;
  tx = (-a1 * (ac + bd) + b1 * (ad - bc) + a2 * c1 + b2 * c1) / den;
  ty = (-b1 * (ac + bd) - a1 * (ad - bc) + a2 * d1 + b2 * d1) / den;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],21:[function(require,module,exports){
module.exports = '1.0.1';

},{}],22:[function(require,module,exports){
"use strict";

module.exports = SeqId

function SeqId(initial) {
  if (!(this instanceof SeqId)) {
    return new SeqId(initial)
  }
  if (initial == null) {
    initial = (Math.random() - 0.5) * Math.pow(2, 32)
  }
  this._id = initial | 0
}
SeqId.prototype.next = function () {
  this._id = (this._id + 1) | 0
  return this._id
}

},{}],23:[function(require,module,exports){
/*

View

*/
var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');
var SpaceTaa = require('./SpaceTaa');
var SpaceHTML = require('./SpaceHTML');
var Space = require('./Space');
var move = require('movejs');

// Disable animations by default.
move.defaults = { duration: 0 };

var HTMLSpaceView = function (space, htmlContainer) {
  // Test if valid space
  if (!(space instanceof Space)) {
    throw 'Parent of a View must be a Space.';
  }
  // Test if valid dom element
  if (!('tagName' in htmlContainer)) {
    throw 'Container should be a DOM Element';
  }

  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);
  var this2 = this;

  this._el = htmlContainer;

  // Two mappings from space taa ids:
  // 1. to HTML elements of the space nodes.
  // 2. to SpaceNode instances
  // Dev decision:
  //   For data structure, dict over list because key search time complexity.
  this._elements = {};
  this._nodes = {};

  (function initSize() {
    var w = this2._el.clientWidth;
    var h = this2._el.clientHeight;
    this2.resize([w, h]);
  }());

  var _hasNodeId = function (nodeid) {
    return this2._elements.hasOwnProperty(nodeid);
  };

  var transformNode = function (htmlElement, spaceNode) {
    // Transform elements because the view orientation.
    // See 2016-03-05-09 for math.
    var node_global_T = spaceNode.getGlobalTransform();
    var T = this2._T.inverse().multiplyBy(node_global_T);
    // Current move.js does not prevent scientific notation reaching CSS
    // which leads to problems with Safari and Opera. Therefore we must
    // prevent the notation here.
    // Of course this will cause error in the presentation.
    // However the error is only in the presentation and thus not a problem.
    var prec = 8;
    var s = T.s.toFixed(prec);
    var r = T.r.toFixed(prec);
    var tx = T.tx.toFixed(prec);
    var ty = T.ty.toFixed(prec);
    move(htmlElement).matrix(s, r,-r, s, tx, ty).end();
  };

  var getViewSpecificId = function (spaceNodeId) {
    // Each rendered element has own ID. The ID differs from
    // the id of space nodes because a space node can become
    // visualized through multiple views.
    return this2.id + '-' + spaceNodeId;
  };


  // Listen the space for new or removed nodes or transformations

  var transformedHandler = function (spaceNode) {
    // Update css transformation.
    // If the node has children, they must also be transformed
    // because the children do not emit transformed by themselves.
    var nodes, i, node, el;
    nodes = spaceNode.getDescendants();
    nodes.push(spaceNode);

    for (i = 0; i < nodes.length; i += 1) {
      node = nodes[i];
      if (_hasNodeId(node.id)) {
        if (node instanceof SpaceTaa) {
          el = this2._elements[node.id];
          transformNode(el, node);
        } else if (node instanceof SpaceHTML) {
          el = this2._elements[node.id];
          transformNode(el, node);
        }
        // Else: no transformable representation for Views.
      }
    }
  };

  var resizedHandler = function (node) {
    var el, wh;
    if (_hasNodeId(node.id)) {
      // Safeguard: if is a SpaceRectangle
      if (node.hasOwnProperty('resize')) {
        wh = node.getSize();
        el = this2._elements[node.id];
        el.style.width = wh[0] + 'px';
        el.style.height = wh[1] + 'px';
      }
    }
  };

  var contentAddedHandler = function (spaceNode, newParent, oldParent) {
    // Parameters:
    //   spaceNode: a SpaceNode i.e. the content unit that was added.
    //   newParent: optional. The new parent of the SpaceNode
    //     Not used for anything for now but probably in the future.
    //   oldParent: optional. The old parent of the SpaceNode.
    //     Not used for anything for now but probably in the future.
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var node, el, wh;

    // SpaceView, SpaceTaa ...
    node = spaceNode;

    // Ensure the spaceNode is in same space. Otherwise,
    // if view's space has been just changed, a waiting
    // contentAdded event could add spaceNode from the old space.
    if (spaceNode.getRootParent() !== this2.getRootParent()) {
      return;
    }

    if (_hasNodeId(node.id)) {
      // Content is already drawn.
    } else {
      if (node instanceof SpaceTaa) {
        el = new Image(256, 256);
        el.src = node.taa.image.src;
        el.id = getViewSpecificId(node.id);
        el.className = 'taaspace-taa';
        // Show to client
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[node.id] = el;
        this2._nodes[node.id] = node;
        // Make transformation
        transformNode(el, node);
        // Listen to further transformations
        node.on('transformed', transformedHandler);
        node.on('resized', resizedHandler);
      } else if (node instanceof SpaceHTML) {
        // Create container div.
        el = document.createElement('div');
        el.innerHTML = node.html;
        el.id = getViewSpecificId(node.id);
        el.className = 'taaspace-html';
        // Resize, and let taaspace styles do the rest.
        wh = node.getSize();
        el.style.width = wh[0] + 'px';
        el.style.height = wh[1] + 'px';
        // Render
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[node.id] = el;
        this2._nodes[node.id] = node;
        // Make transformation
        transformNode(el, node);
        // Listen to further transformations
        node.on('transformed', transformedHandler);
        node.on('resized', resizedHandler);
      } else if (node instanceof HTMLSpaceView) {
        // No representation for views.
      } else {
        throw new Exception('Unknown SpaceNode subtype; cannot represent');
      }
    }
  };

  var contentRemovedHandler = function (spaceNode, oldParent, newParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot, el, node;

    node = spaceNode; // Alias

    // Decide sameRoot
    if (oldParent === null || newParent === null) {
      sameRoot = false;
    } else {
      sameRoot = oldParent.getRootParent() === newParent.getRootParent();
    }

    if (sameRoot) {
      // No reason to remove and then add again.
    } else {
      // New parent in different space, so not displayed in this view anymore.
      if (_hasNodeId(node.id)) {
        // Remove HTML element
        el = this2._elements[node.id];
        this2._el.removeChild(el);
        // Remove from memory.
        // JS feature of delete: does not throw if key does not exist
        delete this2._elements[node.id];
        delete this2._nodes[node.id];
        // Remove handlers.
        node.off('transformed', transformedHandler);
        node.off('resized', resizedHandler);
      }
    }

  };

  // View added to new parent.
  this.on('added', function (self, newSpace, oldSpace) {
    var des, i;

    if (oldSpace === newSpace) {
      // Already set up. Do nothing.
      return;
    }

    // Render nodes from the new space.
    des = newSpace.getDescendants();
    for (i = 0; i < des.length; i += 1) {
      contentAddedHandler(des[i]);
    }

    // Start to listen for changes.
    newSpace.on('contentAdded', contentAddedHandler);
    newSpace.on('contentRemoved', contentRemovedHandler);
  });

  // View removed from parent.
  this.on('removed', function (self, oldSpace, newSpace) {
    var des, i;

    if (newSpace === oldSpace) {
      // Already set up. Do nothing.
      return;
    }

    // Stop listening for changes.
    oldSpace.off('contentAdded', contentAddedHandler);
    oldSpace.off('contentRemoved', contentRemovedHandler);

    // Remove all nodes from old space.
    des = oldSpace.getDescendants();
    for (i = 0; i < des.length; i += 1) {
      contentRemovedHandler(des[i]);
    }
  });

  // If the view is transformed, we of course need to retransform everything.
  this.on('transformed', function () {
    var id, element, node;
    for (id in this2._elements) {
      if (this2._elements.hasOwnProperty(id)) {
        element  = this2._elements[id];
        node = this2._nodes[id];
        transformNode(element, node);
      }
    }
  });

  this.getElementBySpaceNode = function (spaceNode) {
    // Get HTML element representation of the space taa.
    // Return null if not found.
    if (_hasNodeId(spaceNode.id)) {
      return this._elements[spaceNode.id];
    }
    return null;
  };

  this.getSpaceNodeByElementId = function (id) {
    // Get space taa by HTML element id
    // Return null if no space taa for such id.
    var i = id.split('-');
    var spaceViewId = i[0];
    var spaceNodeId = i[1];
    if (this.id === spaceViewId) {
      if (_hasNodeId(spaceNodeId)) {
        return this._nodes[spaceNodeId];
      }
    }
    return null;
  };

  this.getRootElement = function () {
    // Return the container HTML element.
    return this._el;
  };

  // Override the setParent so that only a Space
  // is allowed to become the parent.
  var superSetParent = this.setParent;
  this.setParent = function (space) {
    if (!(space instanceof Space)) {
      throw 'A View can only be a child of a Space';
    }
    superSetParent.call(this, space);
  };

  // View ready to be added to Space.
  this.setParent(space);
};

module.exports = HTMLSpaceView;

},{"./Space":24,"./SpaceHTML":25,"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./SpaceTaa":30,"./Transformer":33,"component-emitter":1,"movejs":3}],24:[function(require,module,exports){
/*
Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
  contentTransformed
*/
var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');

var Space = function () {
  Emitter(this);

  SpaceNode(this);
  // TODO remove possibility to add to parent.

  SpacePlane(this);
  // Space has constant identity transformation _T
};

module.exports = Space;

},{"./SpaceNode":26,"./SpacePlane":27,"component-emitter":1}],25:[function(require,module,exports){
/*
# SpaceElement

A HTMLElement [1] in the space.

[1] https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
*/

var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceHTML = function (parent, html) {
  // Parameters:
  //   parent:
  //     a SpaceNode
  //   html:
  //     a string, containing html
  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);

  this.html = html;
  this.resize([256, 256]);  // Initial element size.

  this.getHTML = function () {
    return this.html;
  };

  // Ready
  this.setParent(parent);
};

module.exports = SpaceHTML;

},{"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./Transformer":33,"component-emitter":1}],26:[function(require,module,exports){
/*
API v3.0.0

Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
*/
var Emitter = require('component-emitter');

// Unique ID generator. Unique over session.
// Usage: seqid.next()
// Return: int
var seqid = require('seqid')(0);

var SpaceNode = function (emitter) {
  // Parameters
  //   emitter, an Emitter.

  // Each node has an id. That is used by the parent nodes and in views.
  emitter.id = seqid.next().toString();

  // Nodes with null parent are root nodes i.e. spaces.
  // SpaceNode#remove sets _parent to null.
  emitter._parent = null;

  // Dict over list because key search time complexity
  emitter._children = {};

  // We need to store built handlers bound to children
  // to be able to remove the handlers when child is removed.
  emitter._addedHandlers = {};
  emitter._removedHandlers = {};

  emitter.getParent = function () {
    return this._parent;
  };

  emitter.getRootParent = function () {
    // Get the predecessor without parents in recursive manner.
    if (this._parent === null) {
      return this;
    } // else
    return this._parent.getRootParent();
  };

  emitter.getChildren = function () {
    // Return child SpaceNodes in a list.
    // Does not include the children of the children.
    var id, arr, obj;
    arr = [];
    obj = this._children;
    for (id in obj) {
      arr.push(obj[id]);
    }
    return arr;
  };

  emitter.getDescendants = function () {
    // All descendants in a list, including the children.
    var i, children, child, arr;
    arr = [];
    children = this.getChildren();
    for (i = 0; i < children.length; i += 1) {
      child = children[i];
      arr = arr.concat(child, child.getDescendants());
    }
    return arr;
  };

  emitter.hasChild = function (spaceNode) {
    // Return
    //   true if spaceNode is a child of this.
    return spaceNode._parent === this;
  };

  emitter.setParent = function (newParent) {
    // Add to new parent.

    var oldParent = this._parent;

    if (oldParent === null) {
      if (newParent === null) {
        // From root to root.
        // Do nothing
      } else {
        // From root to child.
        this._parent = newParent;
        this._parent._addChild(this);
        this.emit('added', this, this._parent, null);
        newParent.emit('contentAdded', this, this._parent, null);
      }
    } else {
      if (newParent === null) {
        // From child to root.
        this._parent = null; // Becomes new root node.
        oldParent._removeChild(this);
        this.emit('removed', this, oldParent, null);
        oldParent.emit('contentRemoved', this, oldParent, null);
      } else {
        // From child to child.
        this._parent = newParent;
        oldParent._removeChild(this);
        newParent._addChild(this);
        this.emit('removed', this, oldParent, newParent);
        this.emit('added', this, newParent, oldParent);
        // With both oldParent and newParent, SpaceView is able to
        // decide whether to keep same HTMLElement or recreate it.
        oldParent.emit('contentRemoved', this, oldParent, newParent);
        newParent.emit('contentAdded', this, newParent, oldParent);
      }
    }

  };

  emitter.remove = function () {
    // Remove this space node from its parent.
    // Return: see setParent
    return this.setParent(null);
  };

  emitter._addChild = function (child) {
    // To be called from child.setParent().
    //
    // Parameters
    //   child, A SpaceNode
    //
    // Return
    //   undefined
    //
    // Dev. note:
    //   Previously this was called from the SpaceNode constructor.
    //   However, because SpaceNode upgrade is done before other
    //   upgrades, the child would not be ready to be added to parent.

    var sc = child; // alias
    var self = this;

    this._children[sc.id] = sc;

    // Start to listen if child has beed added, removed or transformed
    var addedHandler = function (a, b, c) {
      self.emit('contentAdded', a, b, c);
    };
    var removedHandler = function (a, b, c) {
      self.emit('contentRemoved', a, b, c);
    };
    // added and removed events are not listened because
    // for after successfully made add or remove,
    // contentAdded and contentRemoved are fired in setParent.
    sc.on('contentAdded', addedHandler);
    sc.on('contentRemoved', removedHandler);
    this._addedHandlers[sc.id] = addedHandler;
    this._removedHandlers[sc.id] = removedHandler;
  };

  emitter._removeChild = function (child) {
    // To be called from SpaceNode#remove
    // Precondition: child in space
    var sc, h;

    sc = child; // alias
    delete this._children[sc.id];

    // Remove handlers
    h = this._addedHandlers[sc.id];
    delete this._addedHandlers[sc.id];
    sc.off('contentAdded', h);

    h = this._removedHandlers[sc.id];
    delete this._removedHandlers[sc.id];
    sc.off('contentRemoved', h);
  };
};

module.exports = SpaceNode;

},{"component-emitter":1,"seqid":22}],27:[function(require,module,exports){
/*
SpacePlane
API v0.6.0

A SpacePlane represents a coordinate system. It does not include
methods to transform the system. SpacePlane and Transformer are separated
because we want to have planes that cannot be transformed, as the Space.

*/

var nudged = require('nudged');
var SpacePoint = require('./SpacePoint');

var at = function (xy) {
  // Return
  //   A SpacePoint at (x,y) on the plane.
  if (xy.length !== 2) {  // DEBUG TODO remove this
    throw 'Invalid point, use array [x, y]';
  }
  return new SpacePoint(xy, this);  // Note: this === spaceNode
};

var SpacePlane = function (spaceNode) {
  // Parameters
  //   spaceNode
  //     A SpaceNode to monkey patch to SpacePlane

  // Coordinate transformation.
  // The transformation from the plane to the parent (space).
  // See 2016-03-05-09
  // Let:
  //   x_space, a point in space
  //   x_plane, a point on the plane.
  //   T, the coordinate transformation of the plane
  // Then:
  //   x_space = T * x_plane
  //
  // For Space, it is obviously the identity transform:
  //   x_space = T * x_space
  spaceNode._T = nudged.Transform.IDENTITY; // identity transformation

  spaceNode.at = at;

  spaceNode.getTransform = function () {
    // Local transform from plane to parent
    //
    // Return
    //   transformation from plane to parent, i.e.
    //     xy_parent = T * xy_plane
    // Needed when we want to store transformer's position for later use.
    return this._T;
  };

  spaceNode.getGlobalTransform = function () {
    // Return
    //   transformation from the plane to root container.
    //
    // Dev note:
    //   Local transformations go like:
    //     xy_parent = T_plane * xy_plane
    //     xy_parent_parent = T_parent * xy_parent
    //     ...
    //     xy_root = T_parent_parent..._parent * xy_parent_parent..._parent
    //   Therefore global transformation is:
    //     xy_root = T_parent_..._parent * ... * T_parent * T_plane * xy_plane
    if (this._parent === null) {
      // TODO maybe too far: this._parent._parent might be sufficient.
      return this._T;
    } // else
    return this._parent.getGlobalTransform().multiplyBy(this._T);
  };

  spaceNode.resetTransform = function () {
    // Become space. Called e.g. when plane is removed from parent.
    this._T = nudged.Transform.IDENTITY;
  };

};

module.exports = SpacePlane;

},{"./SpacePoint":28,"nudged":12}],28:[function(require,module,exports){
// API v0.6.0

var Transform = require('./Transform');

var SpacePoint = function (xy, reference) {
  // Example
  //   var p = taaspace.SpacePoint([x, y], taa);
  //
  // Parameter
  //   xy
  //     2D array
  //   reference
  //     a SpaceNode or SpacePoint
  //       an item in space, enabling coord projections.
  this.xy = xy;

  // The SpacePlane's transformation the xy are on.
  // Design note: at first, the references were SpacePlanes and not
  // transformations. But because a SpacePlane can move or be removed,
  // we chose only the transformation to be remembered.
  // Design note: later we found it would be convenient for debugging
  // to know where the point came from, which led to this._origin.
  // After that we found that in toSpace method, we would need reference
  // to space, although we only have implicit reference to its coords.
  // Therefore this._origin was dropped.

  if (reference.hasOwnProperty('getGlobalTransform')) {
    // Is a SpacePlane
    this._T = reference.getGlobalTransform();
  } else {
    // Is a SpacePoint
    this._T = reference._T;
  }
};

var proto = SpacePoint.prototype;

proto.equals = function (point) {
  return (this.xy[0] === point.xy[0] &&
    this.xy[1] === point.xy[1] &&
    this._T.equals(point._T));
  };

proto.offset = function (dx, dy) {
  // Create a new point nearby.
  //
  // Parameter
  //   dx
  //     Movement towards positive x
  //   dy
  //     ...
  var xy = [this.xy[0] + dx, this.xy[1] + dy];
  return new SpacePoint(xy, this);
};

proto.polarOffset = function (radius, radians) {
  // Create a new point moved by the polar coordinates
  var x = this.xy[0] + radius * Math.cos(radians);
  var y = this.xy[1] + radius * Math.sin(radians);
  return new SpacePoint([x, y], this);
};

proto.to = function (target) {
  // Create a new SpacePoint at same location but on a
  // different SpacePlane.
  //
  // Parameter
  //   target, a SpacePlane or null.
  //
  // Implementation note (See 2016-03-05-09):
  //
  // First, compute coord. transf. B from the current plane
  // to the space:
  //   x_space = B * x_plane  <=>  x_plane = inv(B) * x_space
  //   B = plane._T
  // Second, let A be coord. transf. from the space to the target plane:
  //   x_target = A * x_space
  //   A = inv(target._T)
  // Therefore combined coord. transf. C from the curr. plane to the target:
  //   x_target = C * x_plane
  //   <=> A * x_space = C * inv(B) * x_space
  //   <=> A = C * inv(B)
  //   <=> C = AB
  //   <=> C = inv(target._T) * plane._T
  //

  if (target === null) {
    // target is the root node (space)
    return this.toSpace();
  }

  // Target's global transformation. This._T is already global.
  var target_gT = target.getGlobalTransform();

  if (target_gT.equals(this._T)) {
    return this;
  } // else
  var C = target_gT.inverse().multiplyBy(this._T);
  var xy_target = C.transform(this.xy);
  return new SpacePoint(xy_target, target);
};

proto.toSpace = function () {
  // Create a new SpacePoint at same location but represented on space coords.
  //
  // Implementation note:
  //   We already have coord. transf. from the current plane to the space:
  //     plane._T
  var xy_space = this._T.transform(this.xy);
  var space_mock = {'_T': Transform.IDENTITY};
  return new SpacePoint(xy_space, space_mock);
};

proto.transform = function (tr) {
  // Create a new point by transformation.
  //
  // Parameter
  //   tr
  //     a Transform
  var xy_hat = tr.transform(this.xy);
  return new SpacePoint(xy_hat, this);
};


module.exports = SpacePoint;

},{"./Transform":32}],29:[function(require,module,exports){
// API v3.0.0

var SpacePoint = require('./SpacePoint');

var SpaceRectangle = function (transformer) {

  var t = transformer;  // Alias

  // Rectangles have size.
  // In its own coordinates, rectangle's right bottom corner
  // is located at [width, height].
  // By default transformation, width 1 and height 1 equal to 1 space unit.
  var width = 1;
  var height = 1;

  t.atNorm = function (xy) {
    // Return a SpacePoint by coordinates normalized about the size.
    // atNorm([1,0]) returns the point at the right upper corner.
    return new SpacePoint([width * xy[0], height * xy[1]], t);
  };

  t.atMid = function () {
    return new SpacePoint([width / 2, height / 2], t);
  };

  t.atMidN = function () {
    return new SpacePoint([width / 2, 0], t);
  };

  t.atMidW = function () {
    return new SpacePoint([0, height / 2], t);
  };

  t.atMidE = function () {
    return new SpacePoint([width, height / 2], t);
  };

  t.atMidS = function () {
    return new SpacePoint([width / 2, height], t);
  };

  t.atNW = function () {
    return new SpacePoint([0, 0], t);
  };

  t.atNE = function () {
    return new SpacePoint([width, 0], t);
  };

  t.atSW = function () {
    return new SpacePoint([0, height], t);
  };

  t.atSE = function () {
    return new SpacePoint([width, height], t);
  };

  t.getSize = function () {
    return [width, height];
  };

  t.resize = function (dimensions) {
    // Parameter
    //   dimensions, [width, height]
    width = dimensions[0];
    height = dimensions[1];

    this.emit('resized', t);
  };

};

module.exports = SpaceRectangle;

},{"./SpacePoint":28}],30:[function(require,module,exports){
// API v0.6.0

var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceTaa = function (parent, taa) {
  // Parameters:
  //   parent
  //     a SpaceNode
  //   taa
  //     a Taa
  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);

  this.taa = taa;
  this.resize([256, 256]);  // Size of taa.

  this.setParent(parent);
};

module.exports = SpaceTaa;

},{"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./Transformer":33,"component-emitter":1}],31:[function(require,module,exports){
// API v0.6.0
var Emitter = require('component-emitter');
var loadimages = require('loadimages');

var NOOP = function () {};

var Taa = function (imgSrc, onLoaded) {
  // Parameters
  //   imgSrc
  //   onLoaded(err, taa)
  //     optional, function (taa)
  Emitter(this);
  var this2 = this;

  // onLoaded is optional
  if (typeof onLoaded !== 'function') {
    onLoaded = NOOP;
  }

  // This object will be replaced by a real Image object but before that
  // src is needed in SpaceView.
  this.image = { src: imgSrc };

  // If the image is cached, the 'load' event of Image element is
  // fired instantly when calling loadimages. If we did not care
  // about this, the on('loaded', fn) listeners would experience
  // different execution order depending whether the images was
  // cached or not.
  var notCached = false;

  loadimages(imgSrc, function (err, image) {
    var emiterr, emittaa;
    if (err) {
      emiterr = err;
      emittaa = null;
    } else {
      this2.image = image;
      emiterr = null;
      emittaa = this2;
    }

    if (notCached) {
      this2.emit('loaded', emiterr, emittaa);
      onLoaded(emiterr, emittaa);
    } else {
      // Postpone emitting of the loaded event
      setTimeout(function () {
        this2.emit('loaded', emiterr, emittaa);
        onLoaded(emiterr, emittaa);
      }, 0);
    }
  });

  notCached = true;
};

module.exports = Taa;

},{"component-emitter":1,"loadimages":2}],32:[function(require,module,exports){
// API v0.6.0
var nudged = require('nudged');

// TODO
// monkeypatch "to(plane)"

module.exports = nudged.Transform;

},{"nudged":12}],33:[function(require,module,exports){
// API v3.0.0
var nudged = require('nudged');
var Transform = require('./Transform');
var SpacePoint = require('./SpacePoint');

var normalize = function (points, plane) {
  // Transform all the points onto the parent and
  // represent them in array [[x0,y0], [x1,y1], ...].
  //
  // Arguments:
  //   points, a single spacepoint or a list of spacepoints
  //   plane, a SpacePlane e.g. a SpaceTaa onto normalize.
  // Return:
  //   array of xy points in space.
  var i, p, np, normalized;

  if (!Array.isArray(points)) {
    // Single SpacePoint
    p = points;
    np = p.to(plane).xy;
    return [np];
  } // else
  normalized = [];
  for (i = 0; i < points.length; i += 1) {
    p = points[i];
    np = p.to(plane).xy;
    normalized.push(np);
  }
  return normalized;
};


var transformByEstimate = function (plane, type, domain, range, pivot) {
  // Types: T,S,R,TS,TR,SR,TSR (see nudged for further details)

  var normPivot;
  if (typeof pivot !== 'undefined') {
    normPivot = normalize(pivot, plane._parent)[0];
  }

  // Convert all SpacePoints onto the space and to arrays
  var normDomain = normalize(domain, plane._parent);
  var normRange = normalize(range, plane._parent);

  // Then compute optimal transformation in space
  var H_space = nudged.estimate(type, normDomain, normRange, normPivot);
  // See 2016-03-05-11:
  //   To apply transformation to a space object:
  //     T_hat = toParent(H) * T
  // Therefore:
  plane._T = H_space.multiplyBy(plane._T);

  // Notify especially view about transformation.
  plane.emit('transformed', plane);
};


var Transformer = function (plane) {
  //
  // Parameters
  //   plane
  //     a SpacePlane

  plane.setTransform = function (T) {
    // Needed when we whan to restore stored position, maybe after
    // modification.
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    this._T = T;
    this.emit('transformed', this);
  };

  plane.setGlobalTransform = function (T) {
    // Set local transform so that the global transform becomes the given T.
    //
    // Dev note:
    //   Given T is coord. transf. from the plane to root (space).
    //   So is this._T.
    //   current_glob_trans = parent_glob_trans * this_T
    //   new_glob_trans = parent_glob_trans * X
    //   <=> X = inv(parent_glob_trans) * new_glob_trans
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    var parent_global = this._parent.getGlobalTransform();
    this._T = parent_global.inverse().multiplyBy(T);
    this.emit('transformed', this);
  };

  plane.translate = function (domain, range) {
    // Move plane horizontally and vertically by example.
    //
    // Translate the plane so that after the translation, the domain points
    // would be as close to given range points as possible.
    //
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'T', domain, range);
  };

  plane.scale = function (pivot, multiplierOrDomain, range) {
    // Parameter
    //   pivot, a SpacePoint
    //   multiplier, the scale factor, > 0
    //  OR
    //   pivot
    //   domain
    //   range

    var useMultiplier = (typeof range === 'undefined');

    if (useMultiplier) {
      var normPivot = normalize(pivot, this._parent)[0];
      var multiplier = multiplierOrDomain;
      // Multiplier does not depend on plane.
      // We create a pivoted scaling transform on parent.
      var S_parent = Transform.IDENTITY.scaleBy(multiplier, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = S_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = multiplierOrDomain;
      transformByEstimate(this, 'S', domain, range, pivot);
    }
  };

  plane.rotate = function (pivot, radiansOrDomain, range) {
    // Parameter
    //   pivot
    //   radians
    //  OR
    //   pivot
    //   domain
    //   range

    var useRadians = (typeof range === 'undefined');

    if (useRadians) {
      var normPivot = normalize(pivot, this._parent)[0];
      var radians = radiansOrDomain;
      // Radians do not depend on plane.
      // We create a pivoted rotation transform on parent.
      var R_parent = Transform.IDENTITY.rotateBy(radians, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = R_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = radiansOrDomain;
      transformByEstimate(this, 'R', domain, range, pivot);
    }
  };

  plane.translateScale = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TS', domain, range);
  };

  plane.translateRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TR', domain, range);
  };

  plane.scaleRotate = function (pivot, domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'SR', domain, range, pivot);
  };

  plane.translateScaleRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TSR', domain, range);
  };

  // plane.translateAndScaleToFit, not sure if necessary for now

  plane.on('removed', function (self, oldParent, newParent) {
    // Maintain global location
    
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot;
    if (newParent === null) {
      // Root nodes cannot move.
      this.resetTransform();
    } else {
      if (oldParent === null) {
        // Removed from null parent?
        throw new Exception('Cannot remove from null parent');
      } else {
        // Moved onto another parent.
        // Let us keep the location in space the same if possible.
        // It is possible only if the parents share same root i.e.
        // are in the same space.
        sameRoot = oldParent.getRootParent() === newParent.getRootParent();
        if (sameRoot) {
          // Keep the location.
          // Let
          //   OT be the old local coord. transformation.
          //   NT be the unknown new local coord. transf.
          //   OPGT be the global coord. transf. of old parent
          //   NPGT be the global coord. transf. of new parent
          // Now, we want to keep global transf. unchanged.
          //   OPGT * OT = NPGT * NT
          //   <=> NT = inv(NPGT) * OPGT * OT
          var opgt = oldParent.getGlobalTransform();
          var npgt = newParent.getGlobalTransform();
          var ot = this._T;
          var nt = npgt.inverse().multiplyBy(opgt).multiplyBy(ot);
          this._T = nt;
          this.emit('transformed', this); // TODO Is needed because inplace?
        } else {
          // In different space: reset
          this.resetTransform();
        }
        // Note: there could be a need to change parent with the same
        // local transformation. Not needed for now.
      }

    }
  });
};

module.exports = Transformer;

},{"./SpacePoint":28,"./Transform":32,"nudged":12}],34:[function(require,module,exports){

exports.Taa = require('./Taa');
exports.SpaceTaa = require('./SpaceTaa');
exports.SpaceHTML = require('./SpaceHTML');
exports.Space = require('./Space');
exports.HTMLSpaceView = require('./HTMLSpaceView');

exports.version = require('./version');

},{"./HTMLSpaceView":23,"./Space":24,"./SpaceHTML":25,"./SpaceTaa":30,"./Taa":31,"./version":35}],35:[function(require,module,exports){
module.exports = '3.0.0';

},{}]},{},[34])(34)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9hZGltYWdlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L25vZGVfbW9kdWxlcy9ldmVudC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL25vZGVfbW9kdWxlcy9oYXMtdHJhbnNpdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jb21wb25lbnQtcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jc3MtZWFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9ub2RlX21vZHVsZXMvdHJhbnNmb3JtLXByb3BlcnR5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL1RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUi5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlU1IuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVQuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVRSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvZXN0aW1hdGVUUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlVFNSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZXFpZC9zZXFpZC5qcyIsInNyYy9IVE1MU3BhY2VWaWV3LmpzIiwic3JjL1NwYWNlLmpzIiwic3JjL1NwYWNlSFRNTC5qcyIsInNyYy9TcGFjZU5vZGUuanMiLCJzcmMvU3BhY2VQbGFuZS5qcyIsInNyYy9TcGFjZVBvaW50LmpzIiwic3JjL1NwYWNlUmVjdGFuZ2xlLmpzIiwic3JjL1NwYWNlVGFhLmpzIiwic3JjL1RhYS5qcyIsInNyYy9UcmFuc2Zvcm0uanMiLCJzcmMvVHJhbnNmb3JtZXIuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvdmVyc2lvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkaW1hZ2VzKGltZ1NyY3MsIHRoZW4pIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGltZ1NyY3NcbiAgLy8gICAgIGFycmF5IG9mIGltYWdlIHNvdXJjZSBwYXRocyBPUiBzaW5nbGUgc291cmNlIHBhdGggc3RyaW5nLlxuICAvLyAgIHRoZW4oZXJyLCBpbWdFbGVtZW50cylcbiAgLy8gICAgIFdpbGwgYmUgY2FsbGVkIGFmdGVyIGFsbCB0aGUgaW1hZ2VzIGFyZSBsb2FkZWQuIElmIHN0cmluZyB3YXMgZ2l2ZW4sXG4gIC8vICAgICBpbWdFbGVtZW50cyBpcyBhbiBJbWFnZSBpbnN0ZWFkIG9mIGFycmF5IG9mIEltYWdlcy5cblxuICB2YXIgbnVtYmVyT2ZJbWFnZXMsIHN0cmluZ0dpdmVuLCB0aGVyZVdhc1N1Y2Nlc3MsIHRoZXJlV2FzRXJyb3IsIGltZ3M7XG4gIHZhciBvbmxvYWRzQ2FsbGVkLCBvbmxvYWQsIG9uZXJyb3I7XG5cbiAgaWYgKHR5cGVvZiB0aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbjogJyArIHRoZW4pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbWdTcmNzID09PSAnc3RyaW5nJykge1xuICAgIG51bWJlck9mSW1hZ2VzID0gMTtcbiAgICBzdHJpbmdHaXZlbiA9IHRydWU7XG4gICAgaW1nU3JjcyA9IFtpbWdTcmNzXTsgLy8gTm9ybWFsaXplXG4gIH0gZWxzZSB7XG4gICAgLy8gQXJyYXkgb2YgaW1hZ2VzXG4gICAgbnVtYmVyT2ZJbWFnZXMgPSBpbWdTcmNzLmxlbmd0aDtcbiAgICBzdHJpbmdHaXZlbiA9IGZhbHNlO1xuICB9XG4gIHRoZXJlV2FzU3VjY2VzcyA9IGZhbHNlO1xuICB0aGVyZVdhc0Vycm9yID0gZmFsc2U7XG5cbiAgaW1ncyA9IFtdO1xuXG4gIG9ubG9hZHNDYWxsZWQgPSAwO1xuICBvbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90ZTpcbiAgICAvLyAgIHRoaXMgPSBJbWFnZVxuICAgIGlmICghdGhlcmVXYXNFcnJvcikge1xuICAgICAgb25sb2Fkc0NhbGxlZCArPSAxO1xuICAgICAgdmFyIGlzRmluYWxJbWFnZSA9IChvbmxvYWRzQ2FsbGVkID09PSBudW1iZXJPZkltYWdlcyk7XG4gICAgICBpZiAoaXNGaW5hbEltYWdlKSB7XG4gICAgICAgIHRoZXJlV2FzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChzdHJpbmdHaXZlbikge1xuICAgICAgICAgIHRoZW4obnVsbCwgaW1nc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhlbihudWxsLCBpbWdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbmVycm9yID0gZnVuY3Rpb24gKGVyck1zZykge1xuICAgIC8vIE5vdGU6XG4gICAgLy8gICB0aGlzID0gSW1hZ2VcblxuICAgIC8vIE5vIGVycm9ycyBhZnRlciBzdWNjZXNzLlxuICAgIGlmICghdGhlcmVXYXNTdWNjZXNzKSB7XG4gICAgICB0aGVyZVdhc0Vycm9yID0gdHJ1ZTtcbiAgICAgIHRoZW4oZXJyTXNnLCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGZpcmluZyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dsb2JhbEV2ZW50SGFuZGxlcnMub25lcnJvciNQYXJhbWV0ZXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZm9yIChpID0gMDsgaSA8IGltZ1NyY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpbWdzLnB1c2gobmV3IEltYWdlKCkpO1xuICAgIGltZ3NbaV0ub25sb2FkID0gb25sb2FkO1xuICAgIGltZ3NbaV0ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgaW1nc1tpXS5zcmMgPSBpbWdTcmNzW2ldO1xuICB9XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgRGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBxdWVyeSA9IHJlcXVpcmUoJ2NvbXBvbmVudC1xdWVyeScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXItdHJhbnNpdGlvbicpO1xudmFyIGhhczNkID0gcmVxdWlyZSgnaGFzLXRyYW5zbGF0ZTNkJyk7XG52YXIgZWFzZSA9IHJlcXVpcmUoJ2Nzcy1lYXNlJyk7XG5cbi8qKlxuICogQ1NTIFRyYW5zbGF0ZVxuICovXG5cbnZhciB0cmFuc2xhdGUgPSBoYXMzZFxuICA/IFsndHJhbnNsYXRlM2QoJywgJywgMCknXVxuICA6IFsndHJhbnNsYXRlKCcsICcpJ107XG5cbi8qKlxuICogRXhwb3J0IGBNb3ZlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW92ZTtcblxuLyoqXG4gKiBHZXQgY29tcHV0ZWQgc3R5bGUuXG4gKi9cblxudmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgfHwgd2luZG93LmN1cnJlbnRTdHlsZTtcblxuLyoqXG4gKiBMaWJyYXJ5IHZlcnNpb24uXG4gKi9cblxuTW92ZS52ZXJzaW9uID0gJzAuNS4wJztcblxuLyoqXG4gKiBFeHBvcnQgYGVhc2VgXG4gKi9cblxuTW92ZS5lYXNlID0gZWFzZTtcblxuLyoqXG4gKiBEZWZhdWx0cy5cbiAqXG4gKiAgIGBkdXJhdGlvbmAgLSBkZWZhdWx0IGR1cmF0aW9uIG9mIDUwMG1zXG4gKlxuICovXG5cbk1vdmUuZGVmYXVsdHMgPSB7XG4gIGR1cmF0aW9uOiA1MDBcbn07XG5cbi8qKlxuICogRGVmYXVsdCBlbGVtZW50IHNlbGVjdGlvbiB1dGlsaXplZCBieSBgbW92ZShzZWxlY3RvcilgLlxuICpcbiAqIE92ZXJyaWRlIHRvIGltcGxlbWVudCB5b3VyIG93biBzZWxlY3Rpb24sIGZvciBleGFtcGxlXG4gKiB3aXRoIGpRdWVyeSBvbmUgbWlnaHQgd3JpdGU6XG4gKlxuICogICAgIG1vdmUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgICAgIHJldHVybiBqUXVlcnkoc2VsZWN0b3IpLmdldCgwKTtcbiAqICAgICB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHNlbGVjdG9yKSByZXR1cm4gc2VsZWN0b3I7XG4gIHJldHVybiBxdWVyeShzZWxlY3Rvcik7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1vdmVgIHdpdGggdGhlIGdpdmVuIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNb3ZlKGVsKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb3ZlKSkgcmV0dXJuIG5ldyBNb3ZlKGVsKTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBlbCkgZWwgPSBxdWVyeShlbCk7XG4gIGlmICghZWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ01vdmUgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGVsZW1lbnQgb3Igc2VsZWN0b3InKTtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLl9wcm9wcyA9IHt9O1xuICB0aGlzLl9yb3RhdGUgPSAwO1xuICB0aGlzLl90cmFuc2l0aW9uUHJvcHMgPSBbXTtcbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLmR1cmF0aW9uKE1vdmUuZGVmYXVsdHMuZHVyYXRpb24pXG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cbiAqL1xuXG5FbWl0dGVyKE1vdmUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBCdWZmZXIgYHRyYW5zZm9ybWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pe1xuICB0aGlzLl90cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNrZXcgYHhgIGFuZCBgeWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2tldyA9IGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXcoJ1xuICAgICsgeCArICdkZWcsICdcbiAgICArICh5IHx8IDApXG4gICAgKyAnZGVnKScpO1xufTtcblxuLyoqXG4gKiBTa2V3IHggYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2tld1ggPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdza2V3WCgnICsgbiArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNrZXcgeSBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3WSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXdZKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIGB4YCBhbmQgYHlgIGF4aXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUudHJhbnNsYXRlID1cbk1vdmUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0cmFuc2xhdGUuam9pbignJ1xuICAgICsgeCArJ3B4LCAnXG4gICAgKyAoeSB8fCAwKVxuICAgICsgJ3B4JykpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgb24gdGhlIHggYXhpcyB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGVYID1cbk1vdmUucHJvdG90eXBlLnggPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGVYKCcgKyBuICsgJ3B4KScpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgb24gdGhlIHkgYXhpcyB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGVZID1cbk1vdmUucHJvdG90eXBlLnkgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGVZKCcgKyBuICsgJ3B4KScpO1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgeCBhbmQgeSBheGlzIGJ5IGB4YCwgb3JcbiAqIGluZGl2aWR1YWxseSBzY2FsZSBgeGAgYW5kIGB5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlKCdcbiAgICArIHggKyAnLCAnXG4gICAgKyAoeSB8fCB4KVxuICAgICsgJyknKTtcbn07XG5cbi8qKlxuICogU2NhbGUgeCBheGlzIGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlWCgnICsgbiArICcpJylcbn07XG5cbi8qKlxuICogQXBwbHkgYSBtYXRyaXggdHJhbnNmb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUubWF0cml4ID0gZnVuY3Rpb24obTExLCBtMTIsIG0yMSwgbTIyLCBtMzEsIG0zMil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnbWF0cml4KCcgKyBbbTExLG0xMixtMjEsbTIyLG0zMSxtMzJdLmpvaW4oJywnKSArICcpJyk7XG59O1xuXG4vKipcbiAqIFNjYWxlIHkgYXhpcyBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdzY2FsZVkoJyArIG4gKyAnKScpXG59O1xuXG4vKipcbiAqIFJvdGF0ZSBgbmAgZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3JvdGF0ZSgnICsgbiArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNldCB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvbiB0byB0byBgZm5gIHN0cmluZy5cbiAqXG4gKiBXaGVuOlxuICpcbiAqICAgLSBudWxsIFwiZWFzZVwiIGlzIHVzZWRcbiAqICAgLSBcImluXCIgXCJlYXNlLWluXCIgaXMgdXNlZFxuICogICAtIFwib3V0XCIgXCJlYXNlLW91dFwiIGlzIHVzZWRcbiAqICAgLSBcImluLW91dFwiIFwiZWFzZS1pbi1vdXRcIiBpcyB1c2VkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKGZuKXtcbiAgZm4gPSBlYXNlW2ZuXSB8fCBmbiB8fCAnZWFzZSc7XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIGZuKTtcbn07XG5cbi8qKlxuICogU2V0IGFuaW1hdGlvbiBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbihuYW1lLCBwcm9wcyl7XG4gIGZvciAodmFyIGkgaW4gcHJvcHMpe1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgICB0aGlzLnNldFZlbmRvclByb3BlcnR5KCdhbmltYXRpb24tJyArIGksIHByb3BzW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgnYW5pbWF0aW9uLW5hbWUnLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBTZXQgZHVyYXRpb24gdG8gYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24obil7XG4gIG4gPSB0aGlzLl9kdXJhdGlvbiA9ICdzdHJpbmcnID09IHR5cGVvZiBuXG4gICAgPyBwYXJzZUZsb2F0KG4pICogMTAwMFxuICAgIDogbjtcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCBuICsgJ21zJyk7XG59O1xuXG4vKipcbiAqIERlbGF5IHRoZSBhbmltYXRpb24gYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24obil7XG4gIG4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgblxuICAgID8gcGFyc2VGbG9hdChuKSAqIDEwMDBcbiAgICA6IG47XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2l0aW9uLWRlbGF5JywgbiArICdtcycpO1xufTtcblxuLyoqXG4gKiBTZXQgYHByb3BgIHRvIGB2YWxgLCBkZWZlcnJlZCB1bnRpbCBgLmVuZCgpYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICB0aGlzLl9wcm9wc1twcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBhIHZlbmRvciBwcmVmaXhlZCBgcHJvcGAgd2l0aCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXRWZW5kb3JQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy13ZWJraXQtJyArIHByb3AsIHZhbCk7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy1tb3otJyArIHByb3AsIHZhbCk7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy1tcy0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW8tJyArIHByb3AsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYHByb3BgIHRvIGB2YWx1ZWAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgdGhpcy50cmFuc2l0aW9uKHByb3ApO1xuICB0aGlzLl9wcm9wc1twcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluY3JlbWVudCBgcHJvcGAgYnkgYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgaWYgKCFzdHlsZSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1cnIgPSBwYXJzZUludChzZWxmLmN1cnJlbnQocHJvcCksIDEwKTtcbiAgICBzZWxmLnNldChwcm9wLCBjdXJyICsgdmFsICsgJ3B4Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWNyZW1lbnQgYHByb3BgIGJ5IGB2YWxgLCBkZWZlcnJlZCB1bnRpbCBgLmVuZCgpYCBpcyBpbnZva2VkXG4gKiBhbmQgYWRkcyB0aGUgcHJvcGVydHkgdG8gdGhlIGxpc3Qgb2YgdHJhbnNpdGlvbiBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIGlmICghc3R5bGUpIHJldHVybjtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5vbignc3RhcnQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBjdXJyID0gcGFyc2VJbnQoc2VsZi5jdXJyZW50KHByb3ApLCAxMCk7XG4gICAgc2VsZi5zZXQocHJvcCwgY3VyciAtIHZhbCArICdweCcpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGNvbXB1dGVkIG9yIFwiY3VycmVudFwiIHZhbHVlIG9mIGBwcm9wYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocHJvcCl7XG4gIHJldHVybiBzdHlsZSh0aGlzLmVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xufTtcblxuLyoqXG4gKiBBZGQgYHByb3BgIHRvIHRoZSBsaXN0IG9mIGludGVybmFsIHRyYW5zaXRpb24gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24ocHJvcCl7XG4gIGlmICghdGhpcy5fdHJhbnNpdGlvblByb3BzLmluZGV4T2YocHJvcCkpIHJldHVybiB0aGlzO1xuICB0aGlzLl90cmFuc2l0aW9uUHJvcHMucHVzaChwcm9wKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbW1pdCBzdHlsZSBwcm9wZXJ0aWVzLCBha2EgYXBwbHkgdGhlbSB0byBgZWwuc3R5bGVgLlxuICpcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQHNlZSBNb3ZlI2VuZCgpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5hcHBseVByb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3Byb3BzKSB7XG4gICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB0aGlzLl9wcm9wc1twcm9wXSwgJycpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZS1zZWxlY3QgZWxlbWVudCB2aWEgYHNlbGVjdG9yYCwgcmVwbGFjaW5nXG4gKiB0aGUgY3VycmVudCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLm1vdmUgPVxuTW92ZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICB0aGlzLmVsID0gTW92ZS5zZWxlY3Qoc2VsZWN0b3IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmZXIgdGhlIGdpdmVuIGBmbmAgdW50aWwgdGhlIGFuaW1hdGlvblxuICogaXMgY29tcGxldGUuIGBmbmAgbWF5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAgLSBhIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICAtIGFuIGluc3RhbmNlb2YgYE1vdmVgIHRvIGNhbGwgYC5lbmQoKWBcbiAqICAgLSBub3RoaW5nLCB0byByZXR1cm4gYSBjbG9uZSBvZiB0aGlzIGBNb3ZlYCBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE1vdmV9IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKGZuKXtcbiAgLy8gaW52b2tlIC5lbmQoKVxuICBpZiAoZm4gaW5zdGFuY2VvZiBNb3ZlKSB7XG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGZuLmVuZCgpO1xuICAgIH0pO1xuICAvLyBjYWxsYmFja1xuICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGZuKSB7XG4gICAgdGhpcy5vbignZW5kJywgZm4pO1xuICAvLyBjaGFpblxuICB9IGVsc2Uge1xuICAgIHZhciBjbG9uZSA9IG5ldyBNb3ZlKHRoaXMuZWwpO1xuICAgIGNsb25lLl90cmFuc2Zvcm1zID0gdGhpcy5fdHJhbnNmb3Jtcy5zbGljZSgwKTtcbiAgICB0aGlzLnRoZW4oY2xvbmUpO1xuICAgIGNsb25lLnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBvcCB0aGUgbW92ZSBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge01vdmV9IHBhcmVudCBNb3ZlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbi8qKlxuICogUmVzZXQgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TW92ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVsLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9XG4gIHRoaXMuZWwuc3R5bGUubW96VHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5tc1RyYW5zaXRpb25EdXJhdGlvbiA9XG4gIHRoaXMuZWwuc3R5bGUub1RyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnQgYW5pbWF0aW9uLCBvcHRpb25hbGx5IGNhbGxpbmcgYGZuYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZW1pdCBcInN0YXJ0XCIgZXZlbnRcbiAgdGhpcy5lbWl0KCdzdGFydCcpO1xuXG4gIC8vIHRyYW5zZm9ybXNcbiAgaWYgKHRoaXMuX3RyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5fdHJhbnNmb3Jtcy5qb2luKCcgJykpO1xuICB9XG5cbiAgLy8gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tcHJvcGVydGllcycsIHRoaXMuX3RyYW5zaXRpb25Qcm9wcy5qb2luKCcsICcpKTtcbiAgdGhpcy5hcHBseVByb3BlcnRpZXMoKTtcblxuICAvLyBjYWxsYmFjayBnaXZlblxuICBpZiAoZm4pIHRoaXMudGhlbihmbik7XG5cbiAgLy8gZW1pdCBcImVuZFwiIHdoZW4gY29tcGxldGVcbiAgYWZ0ZXIub25jZSh0aGlzLmVsLCBmdW5jdGlvbigpe1xuICAgIHNlbGYucmVzZXQoKTtcbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgaGFzVHJhbnNpdGlvbnMgPSByZXF1aXJlKCdoYXMtdHJhbnNpdGlvbnMnKTtcbnZhciBlbWl0dGVyID0gcmVxdWlyZSgnY3NzLWVtaXR0ZXInKTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2l0aW9uKGVsLCBjYWxsYmFjaykge1xuICBpZihoYXNUcmFuc2l0aW9ucyhlbCkpIHtcbiAgICByZXR1cm4gZW1pdHRlcihlbCkuYmluZChjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGVsKTtcbn07XG5cbmFmdGVyVHJhbnNpdGlvbi5vbmNlID0gZnVuY3Rpb24oZWwsIGNhbGxiYWNrKSB7XG4gIGFmdGVyVHJhbnNpdGlvbihlbCwgZnVuY3Rpb24gZm4oKXtcbiAgICBjYWxsYmFjay5hcHBseShlbCk7XG4gICAgZW1pdHRlcihlbCkudW5iaW5kKGZuKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyVHJhbnNpdGlvbjsiLCIvKipcbiAqIE1vZHVsZSBEZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnQnKTtcblxuLy8gQ1NTIGV2ZW50c1xuXG52YXIgd2F0Y2ggPSBbXG4gICd0cmFuc2l0aW9uZW5kJ1xuLCAnd2Via2l0VHJhbnNpdGlvbkVuZCdcbiwgJ29UcmFuc2l0aW9uRW5kJ1xuLCAnTVNUcmFuc2l0aW9uRW5kJ1xuLCAnYW5pbWF0aW9uZW5kJ1xuLCAnd2Via2l0QW5pbWF0aW9uRW5kJ1xuLCAnb0FuaW1hdGlvbkVuZCdcbiwgJ01TQW5pbWF0aW9uRW5kJ1xuXTtcblxuLyoqXG4gKiBFeHBvc2UgYENTU25leHRgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDc3NFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYENzc0VtaXR0ZXJgXG4gKlxuICovXG5cbmZ1bmN0aW9uIENzc0VtaXR0ZXIoZWxlbWVudCl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDc3NFbWl0dGVyKSkgcmV0dXJuIG5ldyBDc3NFbWl0dGVyKGVsZW1lbnQpO1xuICB0aGlzLmVsID0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBCaW5kIENTUyBldmVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Dc3NFbWl0dGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZm4pe1xuICBmb3IgKHZhciBpPTA7IGkgPCB3YXRjaC5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50cy5iaW5kKHRoaXMuZWwsIHdhdGNoW2ldLCBmbik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVuYmluZCBDU1MgZXZlbnRzXG4gKiBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ3NzRW1pdHRlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZm4pe1xuICBmb3IgKHZhciBpPTA7IGkgPCB3YXRjaC5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50cy51bmJpbmQodGhpcy5lbCwgd2F0Y2hbaV0sIGZuKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmlyZSBjYWxsYmFjayBvbmx5IG9uY2VcbiAqIFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Dc3NFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIG9uKCl7XG4gICAgc2VsZi51bmJpbmQob24pO1xuICAgIGZuLmFwcGx5KHNlbGYuZWwsIGFyZ3VtZW50cyk7XG4gIH1cbiAgc2VsZi5iaW5kKG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4iLCJcbi8qKlxuICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICB9XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogVW5iaW5kIGBlbGAgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICB9XG4gIHJldHVybiBmbjtcbn07XG4iLCIvKipcbiAqIFRoaXMgd2lsbCBzdG9yZSB0aGUgcHJvcGVydHkgdGhhdCB0aGUgY3VycmVudFxuICogYnJvd3NlciB1c2VzIGZvciB0cmFuc2l0aW9uRHVyYXRpb25cbiAqL1xudmFyIHByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBwcm9wZXJ0aWVzIHdlJ2xsIGNoZWNrIG9uIGFuIGVsZW1lbnRcbiAqIHRvIGRldGVybWluZSBpZiBpdCBhY3R1YWxseSBoYXMgdHJhbnNpdGlvbnNcbiAqIFdlIHVzZSBkdXJhdGlvbiBhcyB0aGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5XG4gKiBuZWVkZWQgdG8gdGVjaG5pY2FsbHkgaGF2ZSB0cmFuc2l0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICovXG52YXIgdHlwZXMgPSBbXG4gIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gIFwiTW96VHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gIFwid2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXCJcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHByb3BlcnR5IGZvciB0aGlzIGJyb3dzZXJcbiAqIGp1c3Qgb25jZSBzbyB3ZSBkb25lIG5lZWQgdG8gY2hlY2sgZXZlcnkgdGltZVxuICovXG53aGlsZSh0eXBlcy5sZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlcy5zaGlmdCgpO1xuICBpZih0eXBlIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcbiAgICBwcm9wZXJ0eSA9IHR5cGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNpdGlvbnMgb3JcbiAqIGlmIGFuIGVsZW1lbnQgaGFzIHRyYW5zaXRpb25zIGF0IGFsbC5cbiAqIEBwYXJhbSAge0VsZW1lbnR9ICBlbCBPcHRpb25hbC4gUmV0dXJucyBicm93c2VyIHN1cHBvcnQgaWYgbm90IGluY2x1ZGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNUcmFuc2l0aW9ucyhlbCl7XG4gIGlmKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gTm8gYnJvd3NlciBzdXBwb3J0IGZvciB0cmFuc2l0aW9uc1xuICB9XG4gIGlmKCFlbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eSAhPSBudWxsOyAvLyBXZSBqdXN0IHdhbnQgdG8ga25vdyBpZiBicm93c2VycyBzdXBwb3J0IGl0XG4gIH1cbiAgdmFyIGR1cmF0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbClbcHJvcGVydHldO1xuICByZXR1cm4gZHVyYXRpb24gIT09IFwiXCIgJiYgcGFyc2VGbG9hdChkdXJhdGlvbikgIT09IDA7IC8vIERvZXMgdGhpcyBlbGVtZW50IGhhdmUgdHJhbnNpdGlvbnM/XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVHJhbnNpdGlvbnM7IiwiZnVuY3Rpb24gb25lKHNlbGVjdG9yLCBlbCkge1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlbCl7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG4gIHJldHVybiBvbmUoc2VsZWN0b3IsIGVsKTtcbn07XG5cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufTtcblxuZXhwb3J0cy5lbmdpbmUgPSBmdW5jdGlvbihvYmope1xuICBpZiAoIW9iai5vbmUpIHRocm93IG5ldyBFcnJvcignLm9uZSBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBpZiAoIW9iai5hbGwpIHRocm93IG5ldyBFcnJvcignLmFsbCBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBvbmUgPSBvYmoub25lO1xuICBleHBvcnRzLmFsbCA9IG9iai5hbGw7XG4gIHJldHVybiBleHBvcnRzO1xufTtcbiIsIlxuLyoqXG4gKiBDU1MgRWFzaW5nIGZ1bmN0aW9uc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdpbic6ICAgICAgICAgICAgICAgICdlYXNlLWluJ1xuICAsICdvdXQnOiAgICAgICAgICAgICAgICdlYXNlLW91dCdcbiAgLCAnaW4tb3V0JzogICAgICAgICAgICAnZWFzZS1pbi1vdXQnXG4gICwgJ3NuYXAnOiAgICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLDEsLjUsMSknXG4gICwgJ2xpbmVhcic6ICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLjI1MCwgMC4yNTAsIDAuNzUwLCAwLjc1MCknXG4gICwgJ2Vhc2UtaW4tcXVhZCc6ICAgICAgJ2N1YmljLWJlemllcigwLjU1MCwgMC4wODUsIDAuNjgwLCAwLjUzMCknXG4gICwgJ2Vhc2UtaW4tY3ViaWMnOiAgICAgJ2N1YmljLWJlemllcigwLjU1MCwgMC4wNTUsIDAuNjc1LCAwLjE5MCknXG4gICwgJ2Vhc2UtaW4tcXVhcnQnOiAgICAgJ2N1YmljLWJlemllcigwLjg5NSwgMC4wMzAsIDAuNjg1LCAwLjIyMCknXG4gICwgJ2Vhc2UtaW4tcXVpbnQnOiAgICAgJ2N1YmljLWJlemllcigwLjc1NSwgMC4wNTAsIDAuODU1LCAwLjA2MCknXG4gICwgJ2Vhc2UtaW4tc2luZSc6ICAgICAgJ2N1YmljLWJlemllcigwLjQ3MCwgMC4wMDAsIDAuNzQ1LCAwLjcxNSknXG4gICwgJ2Vhc2UtaW4tZXhwbyc6ICAgICAgJ2N1YmljLWJlemllcigwLjk1MCwgMC4wNTAsIDAuNzk1LCAwLjAzNSknXG4gICwgJ2Vhc2UtaW4tY2lyYyc6ICAgICAgJ2N1YmljLWJlemllcigwLjYwMCwgMC4wNDAsIDAuOTgwLCAwLjMzNSknXG4gICwgJ2Vhc2UtaW4tYmFjayc6ICAgICAgJ2N1YmljLWJlemllcigwLjYwMCwgLTAuMjgwLCAwLjczNSwgMC4wNDUpJ1xuICAsICdlYXNlLW91dC1xdWFkJzogICAgICdjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApJ1xuICAsICdlYXNlLW91dC1jdWJpYyc6ICAgICdjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEwLCAwLjM1NSwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1xdWFydCc6ICAgICdjdWJpYy1iZXppZXIoMC4xNjUsIDAuODQwLCAwLjQ0MCwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1xdWludCc6ICAgICdjdWJpYy1iZXppZXIoMC4yMzAsIDEuMDAwLCAwLjMyMCwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1zaW5lJzogICAgICdjdWJpYy1iZXppZXIoMC4zOTAsIDAuNTc1LCAwLjU2NSwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1leHBvJzogICAgICdjdWJpYy1iZXppZXIoMC4xOTAsIDEuMDAwLCAwLjIyMCwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1jaXJjJzogICAgICdjdWJpYy1iZXppZXIoMC4wNzUsIDAuODIwLCAwLjE2NSwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1iYWNrJzogICAgICdjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyMCwgMS4yNzUpJ1xuICAsICdlYXNlLW91dC1xdWFkJzogICAgICdjdWJpYy1iZXppZXIoMC40NTUsIDAuMDMwLCAwLjUxNSwgMC45NTUpJ1xuICAsICdlYXNlLW91dC1jdWJpYyc6ICAgICdjdWJpYy1iZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1xdWFydCc6ICdjdWJpYy1iZXppZXIoMC43NzAsIDAuMDAwLCAwLjE3NSwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1xdWludCc6ICdjdWJpYy1iZXppZXIoMC44NjAsIDAuMDAwLCAwLjA3MCwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1zaW5lJzogICdjdWJpYy1iZXppZXIoMC40NDUsIDAuMDUwLCAwLjU1MCwgMC45NTApJ1xuICAsICdlYXNlLWluLW91dC1leHBvJzogICdjdWJpYy1iZXppZXIoMS4wMDAsIDAuMDAwLCAwLjAwMCwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1jaXJjJzogICdjdWJpYy1iZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1MCwgMC44NjApJ1xuICAsICdlYXNlLWluLW91dC1iYWNrJzogICdjdWJpYy1iZXppZXIoMC42ODAsIC0wLjU1MCwgMC4yNjUsIDEuNTUwKSdcbn07XG4iLCJcbnZhciBwcm9wID0gcmVxdWlyZSgndHJhbnNmb3JtLXByb3BlcnR5Jyk7XG5cbi8vIElFIDw9OCBkb2Vzbid0IGhhdmUgYGdldENvbXB1dGVkU3R5bGVgXG5pZiAoIXByb3AgfHwgIXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbn0gZWxzZSB7XG4gIHZhciBtYXAgPSB7XG4gICAgd2Via2l0VHJhbnNmb3JtOiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICAgIE9UcmFuc2Zvcm06ICctby10cmFuc2Zvcm0nLFxuICAgIG1zVHJhbnNmb3JtOiAnLW1zLXRyYW5zZm9ybScsXG4gICAgTW96VHJhbnNmb3JtOiAnLW1vei10cmFuc2Zvcm0nLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zZm9ybSdcbiAgfTtcblxuICAvLyBmcm9tOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9sb3JlbnpvcG9saWRvcmkvMzc5NDIyNlxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuc3R5bGVbcHJvcF0gPSAndHJhbnNsYXRlM2QoMXB4LDFweCwxcHgpJztcbiAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZWwsIG51bGwpO1xuICB2YXIgdmFsID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShtYXBbcHJvcF0pO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBudWxsICE9IHZhbCAmJiB2YWwubGVuZ3RoICYmICdub25lJyAhPSB2YWw7XG59XG4iLCJcbnZhciBzdHlsZXMgPSBbXG4gICd3ZWJraXRUcmFuc2Zvcm0nLFxuICAnTW96VHJhbnNmb3JtJyxcbiAgJ21zVHJhbnNmb3JtJyxcbiAgJ09UcmFuc2Zvcm0nLFxuICAndHJhbnNmb3JtJ1xuXTtcblxudmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xudmFyIHN0eWxlO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgaWYgKG51bGwgIT0gZWwuc3R5bGVbc3R5bGVdKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZTtcbiAgICBicmVhaztcbiAgfVxufVxuIiwiLypcblxuKi9cbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvVHJhbnNmb3JtJyk7XG5leHBvcnRzLmVzdGltYXRlVCA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlVCcpO1xuZXhwb3J0cy5lc3RpbWF0ZVMgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVMnKTtcbmV4cG9ydHMuZXN0aW1hdGVSID0gcmVxdWlyZSgnLi9saWIvZXN0aW1hdGVSJyk7XG5leHBvcnRzLmVzdGltYXRlVFMgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVRTJyk7XG5leHBvcnRzLmVzdGltYXRlVFIgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVRSJyk7XG5leHBvcnRzLmVzdGltYXRlU1IgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVNSJyk7XG5leHBvcnRzLmVzdGltYXRlVFNSID0gcmVxdWlyZSgnLi9saWIvZXN0aW1hdGVUU1InKTtcbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4vbGliL3ZlcnNpb24nKTtcblxuZXhwb3J0cy5lc3RpbWF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBkb21haW4sIHJhbmdlLCBwaXZvdCkge1xuICAvLyBQYXJhbWV0ZXJcbiAgLy8gICB0eXBlXG4gIC8vICAgICBzdHJpbmcuIE9uZSBvZiB0aGUgZm9sbG93aW5nOiAnVCcsICdTJywgJ1InLCAnVFMnLCAnVFInLCAnU1InLCAnVFNSJ1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgMmQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIDJkIGFycmF5c1xuICAvLyAgIHBpdm90XG4gIC8vICAgICBvcHRpb25hbCAyZCBhcnJheSwgZG9lcyBub3RoaW5nIGZvciB0cmFuc2xhdGlvbiBlc3RpbWF0b3JzXG4gIHZhciBuYW1lID0gJ2VzdGltYXRlJyArIHR5cGUudG9VcHBlckNhc2UoKTtcbiAgaWYgKGV4cG9ydHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gZXhwb3J0c1tuYW1lXShkb21haW4sIHJhbmdlLCBwaXZvdCk7XG4gIH0gLy8gZWxzZVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXN0aW1hdG9yIHR5cGU6ICcgKyB0eXBlKTtcbn07XG4iLCJcbnZhciBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocywgciwgdHgsIHR5KSB7XG5cbiAgLy8gUHVibGljLCB0byBhbGxvdyB1c2VyIGFjY2Vzc1xuICB0aGlzLnMgPSBzO1xuICB0aGlzLnIgPSByO1xuICB0aGlzLnR4ID0gdHg7XG4gIHRoaXMudHkgPSB0eTtcblxuICB0aGlzLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIChzID09PSB0LnMgJiYgciA9PT0gdC5yICYmIHR4ID09PSB0LnR4ICYmIHR5ID09PSB0LnR5KTtcbiAgfTtcblxuICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgLy8gcFxuICAgIC8vICAgcG9pbnQgW3gsIHldIG9yIGFycmF5IG9mIHBvaW50cyBbW3gxLHkxXSwgW3gyLCB5Ml0sIC4uLl1cblxuICAgIGlmICh0eXBlb2YgcFswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbmdsZSBwb2ludFxuICAgICAgcmV0dXJuIFtzICogcFswXSAtIHIgKiBwWzFdICsgdHgsIHIgKiBwWzBdICsgcyAqIHBbMV0gKyB0eV07XG4gICAgfSAvLyBlbHNlXG5cbiAgICB2YXIgaSwgYyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjLnB1c2goW3MgKiBwW2ldWzBdIC0gciAqIHBbaV1bMV0gKyB0eCwgciAqIHBbaV1bMF0gKyBzICogcFtpXVsxXSArIHR5XSk7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIHRoaXMuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEdldCB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGluIHRoZSBmb3JtYXQgY29tbW9uIHRvXG4gICAgLy8gbWFueSBBUElzLCBpbmNsdWRpbmc6XG4gICAgLy8gLSBrbGQtYWZmaW5lXG4gICAgLy9cbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIG9iamVjdCBvLCBoYXZpbmcgcHJvcGVydGllcyBhLCBiLCBjLCBkLCBlLCBmOlxuICAgIC8vICAgWyBzICAtciAgdHggXSAgIFsgby5hICBvLmMgIG8uZSBdXG4gICAgLy8gICBbIHIgICBzICB0eSBdID0gWyBvLmIgIG8uZCAgby5mIF1cbiAgICAvLyAgIFsgMCAgIDAgICAxIF0gICBbICAtICAgIC0gICAgLSAgXVxuICAgIHJldHVybiB7IGE6IHMsIGI6IHIsIGM6IC1yLCBkOiBzLCBlOiB0eCwgZjogdHkgfTtcbiAgfTtcblxuICB0aGlzLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGluIHJhZHNcbiAgICByZXR1cm4gTWF0aC5hdGFuMihyLCBzKTtcbiAgfTtcblxuICB0aGlzLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNjYWxlIG11bHRpcGxpZXJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHIgKiByICsgcyAqIHMpO1xuICB9O1xuXG4gIHRoaXMuZ2V0VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt0eCwgdHldO1xuICB9O1xuXG4gIHRoaXMuaW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gaW52ZXJzZWQgdHJhbnNmb3JtIGluc3RhbmNlXG4gICAgLy8gU2VlIG5vdGUgMjAxNS0xMC0yNi0xNi0zMFxuICAgIHZhciBkZXQgPSBzICogcyArIHIgKiByO1xuICAgIC8vIFRlc3QgaWYgc2luZ3VsYXIgdHJhbnNmb3JtYXRpb24uIFRoZXNlIG1pZ2h0IG9jY3VyIHdoZW4gYWxsIHRoZSByYW5nZVxuICAgIC8vIHBvaW50cyBhcmUgdGhlIHNhbWUsIGZvcmNpbmcgdGhlIHNjYWxlIHRvIGRyb3AgdG8gemVyby5cbiAgICB2YXIgZXBzID0gMC4wMDAwMDAwMTtcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IGVwcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaW5ndWxhciB0cmFuc2Zvcm1hdGlvbnMgY2Fubm90IGJlIGludmVyc2VkLicpO1xuICAgIH1cbiAgICB2YXIgc2hhdCA9IHMgLyBkZXQ7XG4gICAgdmFyIHJoYXQgPSAtciAvIGRldDtcbiAgICB2YXIgdHhoYXQgPSAoLXMgKiB0eCAtIHIgKiB0eSkgLyBkZXQ7XG4gICAgdmFyIHR5aGF0ID0gKCByICogdHggLSBzICogdHkpIC8gZGV0O1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdCk7XG4gIH07XG5cbiAgdGhpcy50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShzLCByLCB0eCArIGR4LCB0eSArIGR5KTtcbiAgfTtcblxuICB0aGlzLnNjYWxlQnkgPSBmdW5jdGlvbiAobXVsdGlwbGllciwgcGl2b3QpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIG11bHRpcGxpZXJcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICAgIG9wdGlvbmFsLCBhIFt4LCB5XSBwb2ludFxuICAgIHZhciBtLCB4LCB5O1xuICAgIG0gPSBtdWx0aXBsaWVyOyAvLyBhbGlhc1xuICAgIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBwaXZvdFswXTtcbiAgICAgIHkgPSBwaXZvdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0obSAqIHMsIG0gKiByLCBtICogdHggKyAoMS1tKSAqIHgsIG0gKiB0eSArICgxLW0pICogeSk7XG4gIH07XG5cbiAgdGhpcy5yb3RhdGVCeSA9IGZ1bmN0aW9uIChyYWRpYW5zLCBwaXZvdCkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgcmFkaWFuc1xuICAgIC8vICAgICBmcm9tIHBvc2l0aXZlIHggdG8gcG9zaXRpdmUgeSBheGlzXG4gICAgLy8gICBwaXZvdFxuICAgIC8vICAgICBvcHRpb25hbCwgYSBbeCwgeV0gcG9pbnRcbiAgICB2YXIgY28sIHNpLCB4LCB5LCBzaGF0LCByaGF0LCB0eGhhdCwgdHloYXQ7XG4gICAgY28gPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICBzaSA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBwaXZvdFswXTtcbiAgICAgIHkgPSBwaXZvdFsxXTtcbiAgICB9XG4gICAgc2hhdCA9IHMgKiBjbyAtIHIgKiBzaTtcbiAgICByaGF0ID0gcyAqIHNpICsgciAqIGNvO1xuICAgIHR4aGF0ID0gKHR4IC0geCkgKiBjbyAtICh0eSAtIHkpICogc2kgKyB4O1xuICAgIHR5aGF0ID0gKHR4IC0geCkgKiBzaSArICh0eSAtIHkpICogY28gKyB5O1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdCk7XG4gIH07XG5cblxuICB0aGlzLm11bHRpcGx5QnkgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG4gICAgLy8gTXVsdGlwbHkgdGhpcyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggQVxuICAgIC8vIGZyb20gdGhlIHJpZ2h0IHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBCXG4gICAgLy8gYW5kIHJldHVybiB0aGUgcmVzdWx0IEFCXG5cbiAgICAvLyBGb3IgcmVhZGluZyBhaWQ6XG4gICAgLy8gcyAtciB0eCAgdC5zIC1yIHR4XG4gICAgLy8gciAgcyB0eSAqICByICBzIHR5XG4gICAgLy8gMCAgMCAgMSAgICAwICAwICAxXG4gICAgdmFyIHQgPSB0cmFuc2Zvcm07IC8vIGFsaWFzXG4gICAgdmFyIHNoYXQgPSBzICogdC5zIC0gciAqIHQucjtcbiAgICB2YXIgcmhhdCA9IHMgKiB0LnIgKyByICogdC5zO1xuICAgIHZhciB0eGhhdCA9IHMgKiB0LnR4IC0gciAqIHQudHkgKyB0eDtcbiAgICB2YXIgdHloYXQgPSByICogdC50eCArIHMgKiB0LnR5ICsgdHk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbiAgfTtcbn07XG5cblRyYW5zZm9ybS5JREVOVElUWSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCwgMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UsIHBpdm90KSB7XG4gIHZhciBpLCBOLCBELCBhMCwgYjAsIGEsIGIsIGMsIGQsIGFjLCBhZCwgYmMsIGJkLCBzaGF0LCByaGF0LCB0eCwgdHk7XG5cbiAgTiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCk7XG4gIGFjID0gYWQgPSBiYyA9IGJkID0gMDtcblxuICBpZiAodHlwZW9mIHBpdm90ID09PSAndW5kZWZpbmVkJykge1xuICAgIGEwID0gYjAgPSAwO1xuICB9IGVsc2Uge1xuICAgIGEwID0gcGl2b3RbMF07XG4gICAgYjAgPSBwaXZvdFsxXTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gZG9tYWluW2ldWzBdIC0gYTA7XG4gICAgYiA9IGRvbWFpbltpXVsxXSAtIGIwO1xuICAgIGMgPSByYW5nZVtpXVswXSAtIGEwO1xuICAgIGQgPSByYW5nZVtpXVsxXSAtIGIwO1xuICAgIGFjICs9IGEgKiBjO1xuICAgIGFkICs9IGEgKiBkO1xuICAgIGJjICs9IGIgKiBjO1xuICAgIGJkICs9IGIgKiBkO1xuICB9XG5cbiAgcCA9IGFjICsgYmQ7XG4gIHEgPSBhZCAtIGJjO1xuXG4gIEQgPSBNYXRoLnNxcnQocCAqIHAgKyBxICogcSk7XG5cbiAgaWYgKEQgPT09IDApIHtcbiAgICAvLyBEID09PSAwXG4gICAgLy8gPD0+IHEgPT09IDAgYW5kIHAgPT09IDAuXG4gICAgLy8gPD0+IGFkID09PSBiYyBhbmQgYWMgPT09IC1iZFxuICAgIC8vIDw9PiBkb21haW4gaW4gcGl2b3QgT1IgcmFuZ2UgaW4gcGl2b3QgT1IgeWV0IHVua25vd24gY2FzZXNcbiAgICAvLyAgICAgd2hlcmUgdGhlIGFuZ2xlIGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICAgIC8vIEQgPT09IDAgYWxzbyBpZiBOID09PSAwLlxuICAgIC8vIEFzc3VtZSBpZGVudGl0eSB0cmFuc2Zvcm0gdG8gYmUgdGhlIGJlc3QgZ3Vlc3NcbiAgICByZXR1cm4gVHJhbnNmb3JtLklERU5USVRZO1xuICB9XG5cbiAgc2hhdCA9IHAgLyBEO1xuICByaGF0ID0gcSAvIEQ7XG4gIHR4ID0gYTAgLSBhMCAqIHNoYXQgKyBiMCAqIHJoYXQ7XG4gIHR5ID0gYjAgLSBhMCAqIHJoYXQgLSBiMCAqIHNoYXQ7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHgsIHR5KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgdmFyIGksIE4sIEQsIGEwLCBiMCwgYSwgYiwgYywgZCwgYWMsIGJkLCBhYSwgYmIsIHNoYXQsIHR4LCB0eTtcblxuICBOID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKTtcbiAgYWMgPSBiZCA9IGFhID0gYmIgPSAwO1xuXG4gIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYTAgPSBiMCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYTAgPSBwaXZvdFswXTtcbiAgICBiMCA9IHBpdm90WzFdO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBkb21haW5baV1bMF0gLSBhMDtcbiAgICBiID0gZG9tYWluW2ldWzFdIC0gYjA7XG4gICAgYyA9IHJhbmdlW2ldWzBdIC0gYTA7XG4gICAgZCA9IHJhbmdlW2ldWzFdIC0gYjA7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gICAgYWEgKz0gYSAqIGE7XG4gICAgYmIgKz0gYiAqIGI7XG4gIH1cblxuICBEID0gYWEgKyBiYjtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIEFsbCBkb21haW4gcG9pbnRzIGVxdWFsIHRoZSBwaXZvdC5cbiAgICAvLyBJZGVudGl0eSB0cmFuc2Zvcm0gaXMgdGhlbiBvbmx5IHNvbHV0aW9uLlxuICAgIC8vIEQgPT09IDAgYWxzbyBpZiBOID09PSAwLlxuICAgIC8vIEFzc3VtZSBpZGVudGl0eSB0cmFuc2Zvcm0gdG8gYmUgdGhlIGJlc3QgZ3Vlc3NcbiAgICByZXR1cm4gVHJhbnNmb3JtLklERU5USVRZO1xuICB9XG5cbiAgLy8gUHJldmVudCBuZWdhdGl2ZSBzY2FsaW5nIGJlY2F1c2UgaXQgd291bGQgYmUgc2FtZSBhcyBwb3NpdGl2ZSBzY2FsaW5nXG4gIC8vIGFuZCByb3RhdGlvbiA9PiBsaW1pdCB0byB6ZXJvXG4gIHNoYXQgPSBNYXRoLm1heCgwLCAoYWMgKyBiZCkgLyBEKTtcbiAgdHggPSAoMSAtIHNoYXQpICogYTA7XG4gIHR5ID0gKDEgLSBzaGF0KSAqIGIwO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIDAsIHR4LCB0eSk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UsIHBpdm90KSB7XG4gIC8vIEVzdGltYXRlIG9wdGltYWwgdHJhbnNmb3JtYXRpb24gZ2l2ZW4gdGhlIGRvbWFpbiBhbmQgdGhlIHJhbmdlXG4gIC8vIHNvIHRoYXQgdGhlIHBpdm90IHBvaW50IHJlbWFpbnMgdGhlIHNhbWUuXG4gIC8vXG4gIC8vIFVzZSBjYXNlc1xuICAvLyAgIC0gdHJhbnNmb3JtIGFuIGltYWdlIHRoYXQgaGFzIG9uZSBjb3JuZXIgZml4ZWQgd2l0aCBhIHBpbi5cbiAgLy8gICAtIGFsbG93IG9ubHkgc2NhbGUgYW5kIHJvdGF0aW9uIGJ5IGZpeGluZyB0aGUgbWlkZGxlIG9mIHRoZSBvYmplY3RcbiAgLy8gICAgIHRvIHRyYW5zZm9ybS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpbiwgYW4gYXJyYXkgb2YgW3gsIHldIHBvaW50c1xuICAvLyAgIHJhbmdlLCBhbiBhcnJheSBvZiBbeCwgeV0gcG9pbnRzXG4gIC8vICAgcGl2b3QsIG9wdGlvbmFsXG4gIC8vICAgICB0aGUgcG9pbnQgW3gsIHldIHRoYXQgbXVzdCByZW1haW4gY29uc3RhbnQgaW4gdGhlIHRyYW5mb3JtYXRpb24uXG4gIC8vICAgICBEZWZhdWx0cyB0byBvcmlnbyBbMCwgMF1cbiAgLy9cbiAgLy9cbiAgdmFyIFgsIFksIE4sIHMsIHIsIHR4LCB0eTtcblxuICAvLyBPcHRpb25hbCBwaXZvdFxuICBpZiAodHlwZW9mIHBpdm90ID09PSAndW5kZWZpbmVkJykge1xuICAgIHBpdm90ID0gWzAsIDBdO1xuICB9XG5cbiAgLy8gQWxpYXNcbiAgWCA9IGRvbWFpbjtcbiAgWSA9IHJhbmdlO1xuXG4gIC8vIEFsbG93IGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3RoIGJ1dFxuICAvLyBpZ25vcmUgdGhlIGV4dHJhIHBvaW50cy5cbiAgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgdmFyIHYgPSBwaXZvdFswXTtcbiAgdmFyIHcgPSBwaXZvdFsxXTtcblxuICB2YXIgaSwgYSwgYiwgYywgZDtcbiAgdmFyIGEyLCBiMjtcbiAgYTIgPSBiMiA9IDA7XG4gIHZhciBhYywgYmQsIGJjLCBhZDtcbiAgYWMgPSBiZCA9IGJjID0gYWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gWFtpXVswXSAtIHY7XG4gICAgYiA9IFhbaV1bMV0gLSB3O1xuICAgIGMgPSBZW2ldWzBdIC0gdjtcbiAgICBkID0gWVtpXVsxXSAtIHc7XG4gICAgYTIgKz0gYSAqIGE7XG4gICAgYjIgKz0gYiAqIGI7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYWQgKz0gYSAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvciA9IGRldGVybWluYW50LlxuICAvLyBJdCBiZWNvbWVzIHplcm8gaWZmIE4gPSAwIG9yIFhbaV0gPSBbdiwgd10gZm9yIGV2ZXJ5IGkgaW4gWzAsIG4pLlxuICAvLyBJbiBvdGhlciB3b3JkcywgaWZmIGFsbCB0aGUgZG9tYWluIHBvaW50cyBhcmUgdW5kZXIgdGhlIGZpeGVkIHBvaW50IG9yXG4gIC8vIHRoZXJlIGlzIG5vIGRvbWFpbiBwb2ludHMuXG4gIHZhciBkZW4gPSBhMiArIGIyO1xuXG4gIHZhciBlcHMgPSAwLjAwMDAwMDAxO1xuICBpZiAoTWF0aC5hYnMoZGVuKSA8IGVwcykge1xuICAgIC8vIFRoZSBkb21haW4gcG9pbnRzIGFyZSB1bmRlciB0aGUgcGl2b3Qgb3IgdGhlcmUgaXMgbm8gZG9tYWluIHBvaW50cy5cbiAgICAvLyBXZSBhc3N1bWUgaWRlbnRpdHkgdHJhbnNmb3JtIGJlIHRoZSBzaW1wbGVzdCBndWVzcy4gSXQga2VlcHNcbiAgICAvLyB0aGUgZG9tYWluIHBvaW50cyB1bmRlciB0aGUgcGl2b3QgaWYgdGhlcmUgaXMgc29tZS5cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcbiAgfVxuXG4gIC8vIEVzdGltYXRvcnNcbiAgcyA9IChhYyArIGJkKSAvIGRlbjtcbiAgciA9ICgtYmMgKyBhZCkgLyBkZW47XG4gIHR4ID0gIHcgKiByIC0gdiAqIHMgKyB2O1xuICB0eSA9IC12ICogciAtIHcgKiBzICsgdztcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybShzLCByLCB0eCwgdHkpO1xufTtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gIHZhciBpLCBOLCBhMSwgYjEsIGMxLCBkMSwgdHhoYXQsIHR5aGF0O1xuXG4gIE4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICBhMSA9IGIxID0gYzEgPSBkMSA9IDA7XG5cbiAgaWYgKE4gPCAxKSB7XG4gICAgLy8gQXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybSBiZSB0aGUgYmVzdCBndWVzc1xuICAgIHJldHVybiBUcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSAxKSB7XG4gICAgYTEgKz0gZG9tYWluW2ldWzBdO1xuICAgIGIxICs9IGRvbWFpbltpXVsxXTtcbiAgICBjMSArPSByYW5nZVtpXVswXTtcbiAgICBkMSArPSByYW5nZVtpXVsxXTtcbiAgfVxuXG4gIHR4aGF0ID0gKGMxIC0gYTEpIC8gTjtcbiAgdHloYXQgPSAoZDEgLSBiMSkgLyBOO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIHR4aGF0LCB0eWhhdCk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgW3gsIHldIDJEIGFycmF5c1xuICAvLyAgIHJhbmdlXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG5cbiAgLy8gQWxpYXNcbiAgdmFyIFggPSBkb21haW47XG4gIHZhciBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICB2YXIgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgdmFyIGksIGEsIGIsIGMsIGQsIGExLCBiMSwgYzEsIGQxLCBhYywgYWQsIGJjLCBiZDtcbiAgYTEgPSBiMSA9IGMxID0gZDEgPSBhYyA9IGFkID0gYmMgPSBiZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gWFtpXVswXTtcbiAgICBiID0gWFtpXVsxXTtcbiAgICBjID0gWVtpXVswXTtcbiAgICBkID0gWVtpXVsxXTtcbiAgICBhMSArPSBhO1xuICAgIGIxICs9IGI7XG4gICAgYzEgKz0gYztcbiAgICBkMSArPSBkO1xuICAgIGFjICs9IGEgKiBjO1xuICAgIGFkICs9IGEgKiBkO1xuICAgIGJjICs9IGIgKiBjO1xuICAgIGJkICs9IGIgKiBkO1xuICB9XG5cbiAgLy8gRGVub21pbmF0b3IuXG4gIHZhciB2ID0gTiAqIChhZCAtIGJjKSAtIGExICogZDEgKyBiMSAqIGMxO1xuICB2YXIgdyA9IE4gKiAoYWMgKyBiZCkgLSBhMSAqIGMxIC0gYjEgKiBkMTtcbiAgdmFyIEQgPSBNYXRoLnNxcnQodiAqIHYgKyB3ICogdyk7XG5cbiAgaWYgKEQgPT09IDApIHtcbiAgICAvLyBOID09PSAwID0+IEQgPT09IDBcbiAgICBpZiAoTiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCwgMCk7XG4gICAgfSAvLyBlbHNlXG4gICAgLy8gRCA9PT0gMCA8PT4gdW5kZWNpZGFibGVcbiAgICAvLyBXZSBndWVzcyB0aGUgdHJhbnNsYXRpb24gdG8gdGhlIG1lYW4gb2YgdGhlIHJhbmdlIHRvIGJlIHRoZSBiZXN0IGd1ZXNzLlxuICAgIC8vIEhlcmUgYSwgYiByZXByZXNlbnRzIHRoZSBtZWFuIG9mIGRvbWFpbiBwb2ludHMuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgKGMxIC0gYTEpIC8gTiwgKGQxIC0gYjEpIC8gTik7XG4gIH1cblxuICAvLyBFc3RpbWF0b3JzXG4gIHZhciBzaGF0ID0gdyAvIEQ7XG4gIHZhciByaGF0ID0gdiAvIEQ7XG4gIHZhciB0eGhhdCA9ICgtYTEgKiBzaGF0ICsgYjEgKiByaGF0ICsgYzEpIC8gTjtcbiAgdmFyIHR5aGF0ID0gKC1hMSAqIHJoYXQgLSBiMSAqIHNoYXQgKyBkMSkgLyBOO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdCk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgW3gsIHldIDJEIGFycmF5c1xuICAvLyAgIHJhbmdlXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG5cbiAgLy8gQWxpYXNcbiAgdmFyIFggPSBkb21haW47XG4gIHZhciBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICB2YXIgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgdmFyIGksIGEsIGIsIGMsIGQsIGExLCBiMSwgYzEsIGQxLCBhMiwgYjIsIGFjLCBiZDtcbiAgYTEgPSBiMSA9IGMxID0gZDEgPSBhMiA9IGIyID0gYWMgPSBiZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gWFtpXVswXTtcbiAgICBiID0gWFtpXVsxXTtcbiAgICBjID0gWVtpXVswXTtcbiAgICBkID0gWVtpXVsxXTtcbiAgICBhMSArPSBhO1xuICAgIGIxICs9IGI7XG4gICAgYzEgKz0gYztcbiAgICBkMSArPSBkO1xuICAgIGEyICs9IGEgKiBhO1xuICAgIGIyICs9IGIgKiBiO1xuICAgIGFjICs9IGEgKiBjO1xuICAgIGJkICs9IGIgKiBkO1xuICB9XG5cbiAgLy8gRGVub21pbmF0b3IuXG4gIHZhciBOMiA9IE4gKiBOO1xuICB2YXIgYTEyID0gYTEgKiBhMTtcbiAgdmFyIGIxMiA9IGIxICogYjE7XG4gIHZhciBwID0gYTIgKyBiMjtcbiAgdmFyIHEgPSBhYyArIGJkO1xuICB2YXIgRCA9IE4yICogcCAtIE4gKiAoYTEyICsgYjEyKTtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIE4gPT09IDAgPT4gRCA9PT0gMFxuICAgIGlmIChOID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcbiAgICB9IC8vIGVsc2VcbiAgICAvLyBEID09PSAwIDw9PiBhbGwgdGhlIGRvbWFpbiBwb2ludHMgYXJlIHRoZSBzYW1lXG4gICAgLy8gV2UgZ3Vlc3MgdGhlIHRyYW5zbGF0aW9uIHRvIHRoZSBtZWFuIG9mIHRoZSByYW5nZSB0byBiZSB0aGUgYmVzdCBndWVzcy5cbiAgICAvLyBIZXJlIGEsIGIgcmVwcmVzZW50cyB0aGUgbWVhbiBvZiBkb21haW4gcG9pbnRzLlxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIChjMSAvIE4pIC0gYSwgKGQxIC8gTikgLSBiKTtcbiAgfVxuXG4gIC8vIEVzdGltYXRvcnNcbiAgdmFyIHNoYXQgPSAoTjIgKiBxIC0gTiAqIChhMSAqIGMxICsgYjEgKiBkMSkpIC8gRDtcbiAgdmFyIHR4aGF0ID0gKC1OICogYTEgKiBxICsgTiAqIGMxICogcCAtIGIxMiAqIGMxICsgYTEgKiBiMSAqIGQxKSAvIEQ7XG4gIHZhciB0eWhhdCA9ICgtTiAqIGIxICogcSArIE4gKiBkMSAqIHAgLSBhMTIgKiBkMSArIGExICogYjEgKiBjMSkgLyBEO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIDAsIHR4aGF0LCB0eWhhdCk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgW3gsIHldIDJEIGFycmF5c1xuICAvLyAgIHJhbmdlXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIHZhciBYLCBZLCBOLCBzLCByLCB0eCwgdHk7XG5cbiAgLy8gQWxpYXNcbiAgWCA9IGRvbWFpbjtcbiAgWSA9IHJhbmdlO1xuXG4gIC8vIEFsbG93IGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3RoIGJ1dFxuICAvLyBpZ25vcmUgdGhlIGV4dHJhIHBvaW50cy5cbiAgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgLy8gSWYgbGVuZ3RoIGlzIHplcm8sIG5vIGVzdGltYXRpb24gY2FuIGJlIGRvbmUuIFdlIGNob29zZSB0aGUgaW5kZW50aXR5XG4gIC8vIHRyYW5zZm9ybWF0aW9uIGJlIHRoZSBiZXN0IHF1ZXNzLlxuICBpZiAoTiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIDAsIDApO1xuICB9IC8vIGVsc2VcblxuICB2YXIgaSwgYSwgYiwgYywgZDtcbiAgdmFyIGExID0gMDtcbiAgdmFyIGIxID0gMDtcbiAgdmFyIGMxID0gMDtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGEyID0gMDtcbiAgdmFyIGIyID0gMDtcbiAgdmFyIGFkID0gMDtcbiAgdmFyIGJjID0gMDtcbiAgdmFyIGFjID0gMDtcbiAgdmFyIGJkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdO1xuICAgIGIgPSBYW2ldWzFdO1xuICAgIGMgPSBZW2ldWzBdO1xuICAgIGQgPSBZW2ldWzFdO1xuICAgIGExICs9IGE7XG4gICAgYjEgKz0gYjtcbiAgICBjMSArPSBjO1xuICAgIGQxICs9IGQ7XG4gICAgYTIgKz0gYSAqIGE7XG4gICAgYjIgKz0gYiAqIGI7XG4gICAgYWQgKz0gYSAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvci5cbiAgLy8gSXQgaXMgemVybyBpZmYgWFtpXSA9IFhbal0gZm9yIGV2ZXJ5IGkgYW5kIGogaW4gWzAsIG4pLlxuICAvLyBJbiBvdGhlciB3b3JkcywgaWZmIGFsbCB0aGUgZG9tYWluIHBvaW50cyBhcmUgdGhlIHNhbWUgb3IgdGhlcmUgaXMgb25seSBvbmUgZG9tYWluIHBvaW50LlxuICB2YXIgZGVuID0gTiAqIGEyICsgTiAqIGIyIC0gYTEgKiBhMSAtIGIxICogYjE7XG5cbiAgdmFyIGVwcyA9IDAuMDAwMDAwMDE7XG4gIGlmICgtZXBzIDwgZGVuICYmIGRlbiA8IGVwcykge1xuICAgIC8vIFRoZSBkb21haW4gcG9pbnRzIGFyZSB0aGUgc2FtZS5cbiAgICAvLyBXZSBndWVzcyB0aGUgdHJhbnNsYXRpb24gdG8gdGhlIG1lYW4gb2YgdGhlIHJhbmdlIHRvIGJlIHRoZSBiZXN0IGd1ZXNzLlxuICAgIC8vIEhlcmUgYSwgYiByZXByZXNlbnRzIHRoZSBtZWFuIG9mIGRvbWFpbiBwb2ludHMuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgKGMxIC8gTikgLSBhLCAoZDEgLyBOKSAtIGIpO1xuICB9XG5cbiAgLy8gRXN0aW1hdG9yc1xuICBzID0gKE4gKiAoYWMgKyBiZCkgLSBhMSAqIGMxIC0gYjEgKiBkMSkgLyBkZW47XG4gIHIgPSAoTiAqIChhZCAtIGJjKSArIGIxICogYzEgLSBhMSAqIGQxKSAvIGRlbjtcbiAgdHggPSAoLWExICogKGFjICsgYmQpICsgYjEgKiAoYWQgLSBiYykgKyBhMiAqIGMxICsgYjIgKiBjMSkgLyBkZW47XG4gIHR5ID0gKC1iMSAqIChhYyArIGJkKSAtIGExICogKGFkIC0gYmMpICsgYTIgKiBkMSArIGIyICogZDEpIC8gZGVuO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHMsIHIsIHR4LCB0eSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMS4wLjEnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VxSWRcblxuZnVuY3Rpb24gU2VxSWQoaW5pdGlhbCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VxSWQpKSB7XG4gICAgcmV0dXJuIG5ldyBTZXFJZChpbml0aWFsKVxuICB9XG4gIGlmIChpbml0aWFsID09IG51bGwpIHtcbiAgICBpbml0aWFsID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogTWF0aC5wb3coMiwgMzIpXG4gIH1cbiAgdGhpcy5faWQgPSBpbml0aWFsIHwgMFxufVxuU2VxSWQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2lkID0gKHRoaXMuX2lkICsgMSkgfCAwXG4gIHJldHVybiB0aGlzLl9pZFxufVxuIiwiLypcblxuVmlld1xuXG4qL1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFNwYWNlTm9kZSA9IHJlcXVpcmUoJy4vU3BhY2VOb2RlJyk7XG52YXIgU3BhY2VQbGFuZSA9IHJlcXVpcmUoJy4vU3BhY2VQbGFuZScpO1xudmFyIFRyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1lcicpO1xudmFyIFNwYWNlUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9TcGFjZVJlY3RhbmdsZScpO1xudmFyIFNwYWNlVGFhID0gcmVxdWlyZSgnLi9TcGFjZVRhYScpO1xudmFyIFNwYWNlSFRNTCA9IHJlcXVpcmUoJy4vU3BhY2VIVE1MJyk7XG52YXIgU3BhY2UgPSByZXF1aXJlKCcuL1NwYWNlJyk7XG52YXIgbW92ZSA9IHJlcXVpcmUoJ21vdmVqcycpO1xuXG4vLyBEaXNhYmxlIGFuaW1hdGlvbnMgYnkgZGVmYXVsdC5cbm1vdmUuZGVmYXVsdHMgPSB7IGR1cmF0aW9uOiAwIH07XG5cbnZhciBIVE1MU3BhY2VWaWV3ID0gZnVuY3Rpb24gKHNwYWNlLCBodG1sQ29udGFpbmVyKSB7XG4gIC8vIFRlc3QgaWYgdmFsaWQgc3BhY2VcbiAgaWYgKCEoc3BhY2UgaW5zdGFuY2VvZiBTcGFjZSkpIHtcbiAgICB0aHJvdyAnUGFyZW50IG9mIGEgVmlldyBtdXN0IGJlIGEgU3BhY2UuJztcbiAgfVxuICAvLyBUZXN0IGlmIHZhbGlkIGRvbSBlbGVtZW50XG4gIGlmICghKCd0YWdOYW1lJyBpbiBodG1sQ29udGFpbmVyKSkge1xuICAgIHRocm93ICdDb250YWluZXIgc2hvdWxkIGJlIGEgRE9NIEVsZW1lbnQnO1xuICB9XG5cbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VOb2RlKHRoaXMpO1xuICBTcGFjZVBsYW5lKHRoaXMpO1xuICBUcmFuc2Zvcm1lcih0aGlzKTtcbiAgU3BhY2VSZWN0YW5nbGUodGhpcyk7XG4gIHZhciB0aGlzMiA9IHRoaXM7XG5cbiAgdGhpcy5fZWwgPSBodG1sQ29udGFpbmVyO1xuXG4gIC8vIFR3byBtYXBwaW5ncyBmcm9tIHNwYWNlIHRhYSBpZHM6XG4gIC8vIDEuIHRvIEhUTUwgZWxlbWVudHMgb2YgdGhlIHNwYWNlIG5vZGVzLlxuICAvLyAyLiB0byBTcGFjZU5vZGUgaW5zdGFuY2VzXG4gIC8vIERldiBkZWNpc2lvbjpcbiAgLy8gICBGb3IgZGF0YSBzdHJ1Y3R1cmUsIGRpY3Qgb3ZlciBsaXN0IGJlY2F1c2Uga2V5IHNlYXJjaCB0aW1lIGNvbXBsZXhpdHkuXG4gIHRoaXMuX2VsZW1lbnRzID0ge307XG4gIHRoaXMuX25vZGVzID0ge307XG5cbiAgKGZ1bmN0aW9uIGluaXRTaXplKCkge1xuICAgIHZhciB3ID0gdGhpczIuX2VsLmNsaWVudFdpZHRoO1xuICAgIHZhciBoID0gdGhpczIuX2VsLmNsaWVudEhlaWdodDtcbiAgICB0aGlzMi5yZXNpemUoW3csIGhdKTtcbiAgfSgpKTtcblxuICB2YXIgX2hhc05vZGVJZCA9IGZ1bmN0aW9uIChub2RlaWQpIHtcbiAgICByZXR1cm4gdGhpczIuX2VsZW1lbnRzLmhhc093blByb3BlcnR5KG5vZGVpZCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybU5vZGUgPSBmdW5jdGlvbiAoaHRtbEVsZW1lbnQsIHNwYWNlTm9kZSkge1xuICAgIC8vIFRyYW5zZm9ybSBlbGVtZW50cyBiZWNhdXNlIHRoZSB2aWV3IG9yaWVudGF0aW9uLlxuICAgIC8vIFNlZSAyMDE2LTAzLTA1LTA5IGZvciBtYXRoLlxuICAgIHZhciBub2RlX2dsb2JhbF9UID0gc3BhY2VOb2RlLmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgIHZhciBUID0gdGhpczIuX1QuaW52ZXJzZSgpLm11bHRpcGx5Qnkobm9kZV9nbG9iYWxfVCk7XG4gICAgLy8gQ3VycmVudCBtb3ZlLmpzIGRvZXMgbm90IHByZXZlbnQgc2NpZW50aWZpYyBub3RhdGlvbiByZWFjaGluZyBDU1NcbiAgICAvLyB3aGljaCBsZWFkcyB0byBwcm9ibGVtcyB3aXRoIFNhZmFyaSBhbmQgT3BlcmEuIFRoZXJlZm9yZSB3ZSBtdXN0XG4gICAgLy8gcHJldmVudCB0aGUgbm90YXRpb24gaGVyZS5cbiAgICAvLyBPZiBjb3Vyc2UgdGhpcyB3aWxsIGNhdXNlIGVycm9yIGluIHRoZSBwcmVzZW50YXRpb24uXG4gICAgLy8gSG93ZXZlciB0aGUgZXJyb3IgaXMgb25seSBpbiB0aGUgcHJlc2VudGF0aW9uIGFuZCB0aHVzIG5vdCBhIHByb2JsZW0uXG4gICAgdmFyIHByZWMgPSA4O1xuICAgIHZhciBzID0gVC5zLnRvRml4ZWQocHJlYyk7XG4gICAgdmFyIHIgPSBULnIudG9GaXhlZChwcmVjKTtcbiAgICB2YXIgdHggPSBULnR4LnRvRml4ZWQocHJlYyk7XG4gICAgdmFyIHR5ID0gVC50eS50b0ZpeGVkKHByZWMpO1xuICAgIG1vdmUoaHRtbEVsZW1lbnQpLm1hdHJpeChzLCByLC1yLCBzLCB0eCwgdHkpLmVuZCgpO1xuICB9O1xuXG4gIHZhciBnZXRWaWV3U3BlY2lmaWNJZCA9IGZ1bmN0aW9uIChzcGFjZU5vZGVJZCkge1xuICAgIC8vIEVhY2ggcmVuZGVyZWQgZWxlbWVudCBoYXMgb3duIElELiBUaGUgSUQgZGlmZmVycyBmcm9tXG4gICAgLy8gdGhlIGlkIG9mIHNwYWNlIG5vZGVzIGJlY2F1c2UgYSBzcGFjZSBub2RlIGNhbiBiZWNvbWVcbiAgICAvLyB2aXN1YWxpemVkIHRocm91Z2ggbXVsdGlwbGUgdmlld3MuXG4gICAgcmV0dXJuIHRoaXMyLmlkICsgJy0nICsgc3BhY2VOb2RlSWQ7XG4gIH07XG5cblxuICAvLyBMaXN0ZW4gdGhlIHNwYWNlIGZvciBuZXcgb3IgcmVtb3ZlZCBub2RlcyBvciB0cmFuc2Zvcm1hdGlvbnNcblxuICB2YXIgdHJhbnNmb3JtZWRIYW5kbGVyID0gZnVuY3Rpb24gKHNwYWNlTm9kZSkge1xuICAgIC8vIFVwZGF0ZSBjc3MgdHJhbnNmb3JtYXRpb24uXG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIGNoaWxkcmVuLCB0aGV5IG11c3QgYWxzbyBiZSB0cmFuc2Zvcm1lZFxuICAgIC8vIGJlY2F1c2UgdGhlIGNoaWxkcmVuIGRvIG5vdCBlbWl0IHRyYW5zZm9ybWVkIGJ5IHRoZW1zZWx2ZXMuXG4gICAgdmFyIG5vZGVzLCBpLCBub2RlLCBlbDtcbiAgICBub2RlcyA9IHNwYWNlTm9kZS5nZXREZXNjZW5kYW50cygpO1xuICAgIG5vZGVzLnB1c2goc3BhY2VOb2RlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKF9oYXNOb2RlSWQobm9kZS5pZCkpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGFjZVRhYSkge1xuICAgICAgICAgIGVsID0gdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdO1xuICAgICAgICAgIHRyYW5zZm9ybU5vZGUoZWwsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGFjZUhUTUwpIHtcbiAgICAgICAgICBlbCA9IHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXTtcbiAgICAgICAgICB0cmFuc2Zvcm1Ob2RlKGVsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlOiBubyB0cmFuc2Zvcm1hYmxlIHJlcHJlc2VudGF0aW9uIGZvciBWaWV3cy5cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlc2l6ZWRIYW5kbGVyID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgZWwsIHdoO1xuICAgIGlmIChfaGFzTm9kZUlkKG5vZGUuaWQpKSB7XG4gICAgICAvLyBTYWZlZ3VhcmQ6IGlmIGlzIGEgU3BhY2VSZWN0YW5nbGVcbiAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KCdyZXNpemUnKSkge1xuICAgICAgICB3aCA9IG5vZGUuZ2V0U2l6ZSgpO1xuICAgICAgICBlbCA9IHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXTtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3aFswXSArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IHdoWzFdICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbnRlbnRBZGRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoc3BhY2VOb2RlLCBuZXdQYXJlbnQsIG9sZFBhcmVudCkge1xuICAgIC8vIFBhcmFtZXRlcnM6XG4gICAgLy8gICBzcGFjZU5vZGU6IGEgU3BhY2VOb2RlIGkuZS4gdGhlIGNvbnRlbnQgdW5pdCB0aGF0IHdhcyBhZGRlZC5cbiAgICAvLyAgIG5ld1BhcmVudDogb3B0aW9uYWwuIFRoZSBuZXcgcGFyZW50IG9mIHRoZSBTcGFjZU5vZGVcbiAgICAvLyAgICAgTm90IHVzZWQgZm9yIGFueXRoaW5nIGZvciBub3cgYnV0IHByb2JhYmx5IGluIHRoZSBmdXR1cmUuXG4gICAgLy8gICBvbGRQYXJlbnQ6IG9wdGlvbmFsLiBUaGUgb2xkIHBhcmVudCBvZiB0aGUgU3BhY2VOb2RlLlxuICAgIC8vICAgICBOb3QgdXNlZCBmb3IgYW55dGhpbmcgZm9yIG5vdyBidXQgcHJvYmFibHkgaW4gdGhlIGZ1dHVyZS5cbiAgICBpZiAodHlwZW9mIG9sZFBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgb2xkUGFyZW50ID0gbnVsbDsgfVxuICAgIGlmICh0eXBlb2YgbmV3UGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBuZXdQYXJlbnQgPSBudWxsOyB9XG5cbiAgICB2YXIgbm9kZSwgZWwsIHdoO1xuXG4gICAgLy8gU3BhY2VWaWV3LCBTcGFjZVRhYSAuLi5cbiAgICBub2RlID0gc3BhY2VOb2RlO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBzcGFjZU5vZGUgaXMgaW4gc2FtZSBzcGFjZS4gT3RoZXJ3aXNlLFxuICAgIC8vIGlmIHZpZXcncyBzcGFjZSBoYXMgYmVlbiBqdXN0IGNoYW5nZWQsIGEgd2FpdGluZ1xuICAgIC8vIGNvbnRlbnRBZGRlZCBldmVudCBjb3VsZCBhZGQgc3BhY2VOb2RlIGZyb20gdGhlIG9sZCBzcGFjZS5cbiAgICBpZiAoc3BhY2VOb2RlLmdldFJvb3RQYXJlbnQoKSAhPT0gdGhpczIuZ2V0Um9vdFBhcmVudCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKF9oYXNOb2RlSWQobm9kZS5pZCkpIHtcbiAgICAgIC8vIENvbnRlbnQgaXMgYWxyZWFkeSBkcmF3bi5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGFjZVRhYSkge1xuICAgICAgICBlbCA9IG5ldyBJbWFnZSgyNTYsIDI1Nik7XG4gICAgICAgIGVsLnNyYyA9IG5vZGUudGFhLmltYWdlLnNyYztcbiAgICAgICAgZWwuaWQgPSBnZXRWaWV3U3BlY2lmaWNJZChub2RlLmlkKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gJ3RhYXNwYWNlLXRhYSc7XG4gICAgICAgIC8vIFNob3cgdG8gY2xpZW50XG4gICAgICAgIHRoaXMyLl9lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIC8vIE1ha2UgcmVmZXJlbmNhYmxlXG4gICAgICAgIHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXSA9IGVsO1xuICAgICAgICB0aGlzMi5fbm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAvLyBNYWtlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIHRyYW5zZm9ybU5vZGUoZWwsIG5vZGUpO1xuICAgICAgICAvLyBMaXN0ZW4gdG8gZnVydGhlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgbm9kZS5vbigndHJhbnNmb3JtZWQnLCB0cmFuc2Zvcm1lZEhhbmRsZXIpO1xuICAgICAgICBub2RlLm9uKCdyZXNpemVkJywgcmVzaXplZEhhbmRsZXIpO1xuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU3BhY2VIVE1MKSB7XG4gICAgICAgIC8vIENyZWF0ZSBjb250YWluZXIgZGl2LlxuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBub2RlLmh0bWw7XG4gICAgICAgIGVsLmlkID0gZ2V0Vmlld1NwZWNpZmljSWQobm9kZS5pZCk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICd0YWFzcGFjZS1odG1sJztcbiAgICAgICAgLy8gUmVzaXplLCBhbmQgbGV0IHRhYXNwYWNlIHN0eWxlcyBkbyB0aGUgcmVzdC5cbiAgICAgICAgd2ggPSBub2RlLmdldFNpemUoKTtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3aFswXSArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IHdoWzFdICsgJ3B4JztcbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIHRoaXMyLl9lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIC8vIE1ha2UgcmVmZXJlbmNhYmxlXG4gICAgICAgIHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXSA9IGVsO1xuICAgICAgICB0aGlzMi5fbm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAvLyBNYWtlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIHRyYW5zZm9ybU5vZGUoZWwsIG5vZGUpO1xuICAgICAgICAvLyBMaXN0ZW4gdG8gZnVydGhlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgbm9kZS5vbigndHJhbnNmb3JtZWQnLCB0cmFuc2Zvcm1lZEhhbmRsZXIpO1xuICAgICAgICBub2RlLm9uKCdyZXNpemVkJywgcmVzaXplZEhhbmRsZXIpO1xuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTFNwYWNlVmlldykge1xuICAgICAgICAvLyBObyByZXByZXNlbnRhdGlvbiBmb3Igdmlld3MuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIFNwYWNlTm9kZSBzdWJ0eXBlOyBjYW5ub3QgcmVwcmVzZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjb250ZW50UmVtb3ZlZEhhbmRsZXIgPSBmdW5jdGlvbiAoc3BhY2VOb2RlLCBvbGRQYXJlbnQsIG5ld1BhcmVudCkge1xuICAgIGlmICh0eXBlb2Ygb2xkUGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBvbGRQYXJlbnQgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVvZiBuZXdQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG5ld1BhcmVudCA9IG51bGw7IH1cblxuICAgIHZhciBzYW1lUm9vdCwgZWwsIG5vZGU7XG5cbiAgICBub2RlID0gc3BhY2VOb2RlOyAvLyBBbGlhc1xuXG4gICAgLy8gRGVjaWRlIHNhbWVSb290XG4gICAgaWYgKG9sZFBhcmVudCA9PT0gbnVsbCB8fCBuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHNhbWVSb290ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbWVSb290ID0gb2xkUGFyZW50LmdldFJvb3RQYXJlbnQoKSA9PT0gbmV3UGFyZW50LmdldFJvb3RQYXJlbnQoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtZVJvb3QpIHtcbiAgICAgIC8vIE5vIHJlYXNvbiB0byByZW1vdmUgYW5kIHRoZW4gYWRkIGFnYWluLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgcGFyZW50IGluIGRpZmZlcmVudCBzcGFjZSwgc28gbm90IGRpc3BsYXllZCBpbiB0aGlzIHZpZXcgYW55bW9yZS5cbiAgICAgIGlmIChfaGFzTm9kZUlkKG5vZGUuaWQpKSB7XG4gICAgICAgIC8vIFJlbW92ZSBIVE1MIGVsZW1lbnRcbiAgICAgICAgZWwgPSB0aGlzMi5fZWxlbWVudHNbbm9kZS5pZF07XG4gICAgICAgIHRoaXMyLl9lbC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG1lbW9yeS5cbiAgICAgICAgLy8gSlMgZmVhdHVyZSBvZiBkZWxldGU6IGRvZXMgbm90IHRocm93IGlmIGtleSBkb2VzIG5vdCBleGlzdFxuICAgICAgICBkZWxldGUgdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdO1xuICAgICAgICBkZWxldGUgdGhpczIuX25vZGVzW25vZGUuaWRdO1xuICAgICAgICAvLyBSZW1vdmUgaGFuZGxlcnMuXG4gICAgICAgIG5vZGUub2ZmKCd0cmFuc2Zvcm1lZCcsIHRyYW5zZm9ybWVkSGFuZGxlcik7XG4gICAgICAgIG5vZGUub2ZmKCdyZXNpemVkJywgcmVzaXplZEhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8vIFZpZXcgYWRkZWQgdG8gbmV3IHBhcmVudC5cbiAgdGhpcy5vbignYWRkZWQnLCBmdW5jdGlvbiAoc2VsZiwgbmV3U3BhY2UsIG9sZFNwYWNlKSB7XG4gICAgdmFyIGRlcywgaTtcblxuICAgIGlmIChvbGRTcGFjZSA9PT0gbmV3U3BhY2UpIHtcbiAgICAgIC8vIEFscmVhZHkgc2V0IHVwLiBEbyBub3RoaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBub2RlcyBmcm9tIHRoZSBuZXcgc3BhY2UuXG4gICAgZGVzID0gbmV3U3BhY2UuZ2V0RGVzY2VuZGFudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb250ZW50QWRkZWRIYW5kbGVyKGRlc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgIG5ld1NwYWNlLm9uKCdjb250ZW50QWRkZWQnLCBjb250ZW50QWRkZWRIYW5kbGVyKTtcbiAgICBuZXdTcGFjZS5vbignY29udGVudFJlbW92ZWQnLCBjb250ZW50UmVtb3ZlZEhhbmRsZXIpO1xuICB9KTtcblxuICAvLyBWaWV3IHJlbW92ZWQgZnJvbSBwYXJlbnQuXG4gIHRoaXMub24oJ3JlbW92ZWQnLCBmdW5jdGlvbiAoc2VsZiwgb2xkU3BhY2UsIG5ld1NwYWNlKSB7XG4gICAgdmFyIGRlcywgaTtcblxuICAgIGlmIChuZXdTcGFjZSA9PT0gb2xkU3BhY2UpIHtcbiAgICAgIC8vIEFscmVhZHkgc2V0IHVwLiBEbyBub3RoaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBjaGFuZ2VzLlxuICAgIG9sZFNwYWNlLm9mZignY29udGVudEFkZGVkJywgY29udGVudEFkZGVkSGFuZGxlcik7XG4gICAgb2xkU3BhY2Uub2ZmKCdjb250ZW50UmVtb3ZlZCcsIGNvbnRlbnRSZW1vdmVkSGFuZGxlcik7XG5cbiAgICAvLyBSZW1vdmUgYWxsIG5vZGVzIGZyb20gb2xkIHNwYWNlLlxuICAgIGRlcyA9IG9sZFNwYWNlLmdldERlc2NlbmRhbnRzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29udGVudFJlbW92ZWRIYW5kbGVyKGRlc1tpXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgdmlldyBpcyB0cmFuc2Zvcm1lZCwgd2Ugb2YgY291cnNlIG5lZWQgdG8gcmV0cmFuc2Zvcm0gZXZlcnl0aGluZy5cbiAgdGhpcy5vbigndHJhbnNmb3JtZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkLCBlbGVtZW50LCBub2RlO1xuICAgIGZvciAoaWQgaW4gdGhpczIuX2VsZW1lbnRzKSB7XG4gICAgICBpZiAodGhpczIuX2VsZW1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlbGVtZW50ICA9IHRoaXMyLl9lbGVtZW50c1tpZF07XG4gICAgICAgIG5vZGUgPSB0aGlzMi5fbm9kZXNbaWRdO1xuICAgICAgICB0cmFuc2Zvcm1Ob2RlKGVsZW1lbnQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5nZXRFbGVtZW50QnlTcGFjZU5vZGUgPSBmdW5jdGlvbiAoc3BhY2VOb2RlKSB7XG4gICAgLy8gR2V0IEhUTUwgZWxlbWVudCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BhY2UgdGFhLlxuICAgIC8vIFJldHVybiBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICBpZiAoX2hhc05vZGVJZChzcGFjZU5vZGUuaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHNbc3BhY2VOb2RlLmlkXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdGhpcy5nZXRTcGFjZU5vZGVCeUVsZW1lbnRJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIC8vIEdldCBzcGFjZSB0YWEgYnkgSFRNTCBlbGVtZW50IGlkXG4gICAgLy8gUmV0dXJuIG51bGwgaWYgbm8gc3BhY2UgdGFhIGZvciBzdWNoIGlkLlxuICAgIHZhciBpID0gaWQuc3BsaXQoJy0nKTtcbiAgICB2YXIgc3BhY2VWaWV3SWQgPSBpWzBdO1xuICAgIHZhciBzcGFjZU5vZGVJZCA9IGlbMV07XG4gICAgaWYgKHRoaXMuaWQgPT09IHNwYWNlVmlld0lkKSB7XG4gICAgICBpZiAoX2hhc05vZGVJZChzcGFjZU5vZGVJZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVzW3NwYWNlTm9kZUlkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdGhpcy5nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGNvbnRhaW5lciBIVE1MIGVsZW1lbnQuXG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9O1xuXG4gIC8vIE92ZXJyaWRlIHRoZSBzZXRQYXJlbnQgc28gdGhhdCBvbmx5IGEgU3BhY2VcbiAgLy8gaXMgYWxsb3dlZCB0byBiZWNvbWUgdGhlIHBhcmVudC5cbiAgdmFyIHN1cGVyU2V0UGFyZW50ID0gdGhpcy5zZXRQYXJlbnQ7XG4gIHRoaXMuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHNwYWNlKSB7XG4gICAgaWYgKCEoc3BhY2UgaW5zdGFuY2VvZiBTcGFjZSkpIHtcbiAgICAgIHRocm93ICdBIFZpZXcgY2FuIG9ubHkgYmUgYSBjaGlsZCBvZiBhIFNwYWNlJztcbiAgICB9XG4gICAgc3VwZXJTZXRQYXJlbnQuY2FsbCh0aGlzLCBzcGFjZSk7XG4gIH07XG5cbiAgLy8gVmlldyByZWFkeSB0byBiZSBhZGRlZCB0byBTcGFjZS5cbiAgdGhpcy5zZXRQYXJlbnQoc3BhY2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MU3BhY2VWaWV3O1xuIiwiLypcbkVtaXRzXG4gIGNvbnRlbnRBZGRlZFxuICBjb250ZW50UmVtb3ZlZFxuICAgIG5vdCB0aHJvd24gaWYgdGhlIGNvbnRlbnQgdG8gcmVtb3ZlIGRpZCBub3QgZXhpc3QgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICBjb250ZW50VHJhbnNmb3JtZWRcbiovXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VOb2RlID0gcmVxdWlyZSgnLi9TcGFjZU5vZGUnKTtcbnZhciBTcGFjZVBsYW5lID0gcmVxdWlyZSgnLi9TcGFjZVBsYW5lJyk7XG5cbnZhciBTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgRW1pdHRlcih0aGlzKTtcblxuICBTcGFjZU5vZGUodGhpcyk7XG4gIC8vIFRPRE8gcmVtb3ZlIHBvc3NpYmlsaXR5IHRvIGFkZCB0byBwYXJlbnQuXG5cbiAgU3BhY2VQbGFuZSh0aGlzKTtcbiAgLy8gU3BhY2UgaGFzIGNvbnN0YW50IGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uIF9UXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlO1xuIiwiLypcbiMgU3BhY2VFbGVtZW50XG5cbkEgSFRNTEVsZW1lbnQgWzFdIGluIHRoZSBzcGFjZS5cblxuWzFdIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudFxuKi9cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFNwYWNlTm9kZSA9IHJlcXVpcmUoJy4vU3BhY2VOb2RlJyk7XG52YXIgU3BhY2VQbGFuZSA9IHJlcXVpcmUoJy4vU3BhY2VQbGFuZScpO1xudmFyIFRyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1lcicpO1xudmFyIFNwYWNlUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9TcGFjZVJlY3RhbmdsZScpO1xuXG52YXIgU3BhY2VIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAgIHBhcmVudDpcbiAgLy8gICAgIGEgU3BhY2VOb2RlXG4gIC8vICAgaHRtbDpcbiAgLy8gICAgIGEgc3RyaW5nLCBjb250YWluaW5nIGh0bWxcbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VOb2RlKHRoaXMpO1xuICBTcGFjZVBsYW5lKHRoaXMpO1xuICBUcmFuc2Zvcm1lcih0aGlzKTtcbiAgU3BhY2VSZWN0YW5nbGUodGhpcyk7XG5cbiAgdGhpcy5odG1sID0gaHRtbDtcbiAgdGhpcy5yZXNpemUoWzI1NiwgMjU2XSk7ICAvLyBJbml0aWFsIGVsZW1lbnQgc2l6ZS5cblxuICB0aGlzLmdldEhUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaHRtbDtcbiAgfTtcblxuICAvLyBSZWFkeVxuICB0aGlzLnNldFBhcmVudChwYXJlbnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZUhUTUw7XG4iLCIvKlxuQVBJIHYzLjAuMFxuXG5FbWl0c1xuICBjb250ZW50QWRkZWRcbiAgY29udGVudFJlbW92ZWRcbiAgICBub3QgdGhyb3duIGlmIHRoZSBjb250ZW50IHRvIHJlbW92ZSBkaWQgbm90IGV4aXN0IGluIHRoZSBmaXJzdCBwbGFjZS5cbiovXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8vIFVuaXF1ZSBJRCBnZW5lcmF0b3IuIFVuaXF1ZSBvdmVyIHNlc3Npb24uXG4vLyBVc2FnZTogc2VxaWQubmV4dCgpXG4vLyBSZXR1cm46IGludFxudmFyIHNlcWlkID0gcmVxdWlyZSgnc2VxaWQnKSgwKTtcblxudmFyIFNwYWNlTm9kZSA9IGZ1bmN0aW9uIChlbWl0dGVyKSB7XG4gIC8vIFBhcmFtZXRlcnNcbiAgLy8gICBlbWl0dGVyLCBhbiBFbWl0dGVyLlxuXG4gIC8vIEVhY2ggbm9kZSBoYXMgYW4gaWQuIFRoYXQgaXMgdXNlZCBieSB0aGUgcGFyZW50IG5vZGVzIGFuZCBpbiB2aWV3cy5cbiAgZW1pdHRlci5pZCA9IHNlcWlkLm5leHQoKS50b1N0cmluZygpO1xuXG4gIC8vIE5vZGVzIHdpdGggbnVsbCBwYXJlbnQgYXJlIHJvb3Qgbm9kZXMgaS5lLiBzcGFjZXMuXG4gIC8vIFNwYWNlTm9kZSNyZW1vdmUgc2V0cyBfcGFyZW50IHRvIG51bGwuXG4gIGVtaXR0ZXIuX3BhcmVudCA9IG51bGw7XG5cbiAgLy8gRGljdCBvdmVyIGxpc3QgYmVjYXVzZSBrZXkgc2VhcmNoIHRpbWUgY29tcGxleGl0eVxuICBlbWl0dGVyLl9jaGlsZHJlbiA9IHt9O1xuXG4gIC8vIFdlIG5lZWQgdG8gc3RvcmUgYnVpbHQgaGFuZGxlcnMgYm91bmQgdG8gY2hpbGRyZW5cbiAgLy8gdG8gYmUgYWJsZSB0byByZW1vdmUgdGhlIGhhbmRsZXJzIHdoZW4gY2hpbGQgaXMgcmVtb3ZlZC5cbiAgZW1pdHRlci5fYWRkZWRIYW5kbGVycyA9IHt9O1xuICBlbWl0dGVyLl9yZW1vdmVkSGFuZGxlcnMgPSB7fTtcblxuICBlbWl0dGVyLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9O1xuXG4gIGVtaXR0ZXIuZ2V0Um9vdFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBHZXQgdGhlIHByZWRlY2Vzc29yIHdpdGhvdXQgcGFyZW50cyBpbiByZWN1cnNpdmUgbWFubmVyLlxuICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gZWxzZVxuICAgIHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0Um9vdFBhcmVudCgpO1xuICB9O1xuXG4gIGVtaXR0ZXIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGNoaWxkIFNwYWNlTm9kZXMgaW4gYSBsaXN0LlxuICAgIC8vIERvZXMgbm90IGluY2x1ZGUgdGhlIGNoaWxkcmVuIG9mIHRoZSBjaGlsZHJlbi5cbiAgICB2YXIgaWQsIGFyciwgb2JqO1xuICAgIGFyciA9IFtdO1xuICAgIG9iaiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICBhcnIucHVzaChvYmpbaWRdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBlbWl0dGVyLmdldERlc2NlbmRhbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFsbCBkZXNjZW5kYW50cyBpbiBhIGxpc3QsIGluY2x1ZGluZyB0aGUgY2hpbGRyZW4uXG4gICAgdmFyIGksIGNoaWxkcmVuLCBjaGlsZCwgYXJyO1xuICAgIGFyciA9IFtdO1xuICAgIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGFyciA9IGFyci5jb25jYXQoY2hpbGQsIGNoaWxkLmdldERlc2NlbmRhbnRzKCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuXG4gIGVtaXR0ZXIuaGFzQ2hpbGQgPSBmdW5jdGlvbiAoc3BhY2VOb2RlKSB7XG4gICAgLy8gUmV0dXJuXG4gICAgLy8gICB0cnVlIGlmIHNwYWNlTm9kZSBpcyBhIGNoaWxkIG9mIHRoaXMuXG4gICAgcmV0dXJuIHNwYWNlTm9kZS5fcGFyZW50ID09PSB0aGlzO1xuICB9O1xuXG4gIGVtaXR0ZXIuc2V0UGFyZW50ID0gZnVuY3Rpb24gKG5ld1BhcmVudCkge1xuICAgIC8vIEFkZCB0byBuZXcgcGFyZW50LlxuXG4gICAgdmFyIG9sZFBhcmVudCA9IHRoaXMuX3BhcmVudDtcblxuICAgIGlmIChvbGRQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmIChuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRnJvbSByb290IHRvIHJvb3QuXG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZyb20gcm9vdCB0byBjaGlsZC5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2FkZENoaWxkKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoJ2FkZGVkJywgdGhpcywgdGhpcy5fcGFyZW50LCBudWxsKTtcbiAgICAgICAgbmV3UGFyZW50LmVtaXQoJ2NvbnRlbnRBZGRlZCcsIHRoaXMsIHRoaXMuX3BhcmVudCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRnJvbSBjaGlsZCB0byByb290LlxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsOyAvLyBCZWNvbWVzIG5ldyByb290IG5vZGUuXG4gICAgICAgIG9sZFBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbnVsbCk7XG4gICAgICAgIG9sZFBhcmVudC5lbWl0KCdjb250ZW50UmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGcm9tIGNoaWxkIHRvIGNoaWxkLlxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgIG9sZFBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIG5ld1BhcmVudC5fYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbmV3UGFyZW50KTtcbiAgICAgICAgdGhpcy5lbWl0KCdhZGRlZCcsIHRoaXMsIG5ld1BhcmVudCwgb2xkUGFyZW50KTtcbiAgICAgICAgLy8gV2l0aCBib3RoIG9sZFBhcmVudCBhbmQgbmV3UGFyZW50LCBTcGFjZVZpZXcgaXMgYWJsZSB0b1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciB0byBrZWVwIHNhbWUgSFRNTEVsZW1lbnQgb3IgcmVjcmVhdGUgaXQuXG4gICAgICAgIG9sZFBhcmVudC5lbWl0KCdjb250ZW50UmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbmV3UGFyZW50KTtcbiAgICAgICAgbmV3UGFyZW50LmVtaXQoJ2NvbnRlbnRBZGRlZCcsIHRoaXMsIG5ld1BhcmVudCwgb2xkUGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICBlbWl0dGVyLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZW1vdmUgdGhpcyBzcGFjZSBub2RlIGZyb20gaXRzIHBhcmVudC5cbiAgICAvLyBSZXR1cm46IHNlZSBzZXRQYXJlbnRcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJlbnQobnVsbCk7XG4gIH07XG5cbiAgZW1pdHRlci5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBUbyBiZSBjYWxsZWQgZnJvbSBjaGlsZC5zZXRQYXJlbnQoKS5cbiAgICAvL1xuICAgIC8vIFBhcmFtZXRlcnNcbiAgICAvLyAgIGNoaWxkLCBBIFNwYWNlTm9kZVxuICAgIC8vXG4gICAgLy8gUmV0dXJuXG4gICAgLy8gICB1bmRlZmluZWRcbiAgICAvL1xuICAgIC8vIERldi4gbm90ZTpcbiAgICAvLyAgIFByZXZpb3VzbHkgdGhpcyB3YXMgY2FsbGVkIGZyb20gdGhlIFNwYWNlTm9kZSBjb25zdHJ1Y3Rvci5cbiAgICAvLyAgIEhvd2V2ZXIsIGJlY2F1c2UgU3BhY2VOb2RlIHVwZ3JhZGUgaXMgZG9uZSBiZWZvcmUgb3RoZXJcbiAgICAvLyAgIHVwZ3JhZGVzLCB0aGUgY2hpbGQgd291bGQgbm90IGJlIHJlYWR5IHRvIGJlIGFkZGVkIHRvIHBhcmVudC5cblxuICAgIHZhciBzYyA9IGNoaWxkOyAvLyBhbGlhc1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuX2NoaWxkcmVuW3NjLmlkXSA9IHNjO1xuXG4gICAgLy8gU3RhcnQgdG8gbGlzdGVuIGlmIGNoaWxkIGhhcyBiZWVkIGFkZGVkLCByZW1vdmVkIG9yIHRyYW5zZm9ybWVkXG4gICAgdmFyIGFkZGVkSGFuZGxlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICBzZWxmLmVtaXQoJ2NvbnRlbnRBZGRlZCcsIGEsIGIsIGMpO1xuICAgIH07XG4gICAgdmFyIHJlbW92ZWRIYW5kbGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHNlbGYuZW1pdCgnY29udGVudFJlbW92ZWQnLCBhLCBiLCBjKTtcbiAgICB9O1xuICAgIC8vIGFkZGVkIGFuZCByZW1vdmVkIGV2ZW50cyBhcmUgbm90IGxpc3RlbmVkIGJlY2F1c2VcbiAgICAvLyBmb3IgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IG1hZGUgYWRkIG9yIHJlbW92ZSxcbiAgICAvLyBjb250ZW50QWRkZWQgYW5kIGNvbnRlbnRSZW1vdmVkIGFyZSBmaXJlZCBpbiBzZXRQYXJlbnQuXG4gICAgc2Mub24oJ2NvbnRlbnRBZGRlZCcsIGFkZGVkSGFuZGxlcik7XG4gICAgc2Mub24oJ2NvbnRlbnRSZW1vdmVkJywgcmVtb3ZlZEhhbmRsZXIpO1xuICAgIHRoaXMuX2FkZGVkSGFuZGxlcnNbc2MuaWRdID0gYWRkZWRIYW5kbGVyO1xuICAgIHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF0gPSByZW1vdmVkSGFuZGxlcjtcbiAgfTtcblxuICBlbWl0dGVyLl9yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIFRvIGJlIGNhbGxlZCBmcm9tIFNwYWNlTm9kZSNyZW1vdmVcbiAgICAvLyBQcmVjb25kaXRpb246IGNoaWxkIGluIHNwYWNlXG4gICAgdmFyIHNjLCBoO1xuXG4gICAgc2MgPSBjaGlsZDsgLy8gYWxpYXNcbiAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bc2MuaWRdO1xuXG4gICAgLy8gUmVtb3ZlIGhhbmRsZXJzXG4gICAgaCA9IHRoaXMuX2FkZGVkSGFuZGxlcnNbc2MuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLl9hZGRlZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBzYy5vZmYoJ2NvbnRlbnRBZGRlZCcsIGgpO1xuXG4gICAgaCA9IHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgZGVsZXRlIHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgc2Mub2ZmKCdjb250ZW50UmVtb3ZlZCcsIGgpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZU5vZGU7XG4iLCIvKlxuU3BhY2VQbGFuZVxuQVBJIHYwLjYuMFxuXG5BIFNwYWNlUGxhbmUgcmVwcmVzZW50cyBhIGNvb3JkaW5hdGUgc3lzdGVtLiBJdCBkb2VzIG5vdCBpbmNsdWRlXG5tZXRob2RzIHRvIHRyYW5zZm9ybSB0aGUgc3lzdGVtLiBTcGFjZVBsYW5lIGFuZCBUcmFuc2Zvcm1lciBhcmUgc2VwYXJhdGVkXG5iZWNhdXNlIHdlIHdhbnQgdG8gaGF2ZSBwbGFuZXMgdGhhdCBjYW5ub3QgYmUgdHJhbnNmb3JtZWQsIGFzIHRoZSBTcGFjZS5cblxuKi9cblxudmFyIG51ZGdlZCA9IHJlcXVpcmUoJ251ZGdlZCcpO1xudmFyIFNwYWNlUG9pbnQgPSByZXF1aXJlKCcuL1NwYWNlUG9pbnQnKTtcblxudmFyIGF0ID0gZnVuY3Rpb24gKHh5KSB7XG4gIC8vIFJldHVyblxuICAvLyAgIEEgU3BhY2VQb2ludCBhdCAoeCx5KSBvbiB0aGUgcGxhbmUuXG4gIGlmICh4eS5sZW5ndGggIT09IDIpIHsgIC8vIERFQlVHIFRPRE8gcmVtb3ZlIHRoaXNcbiAgICB0aHJvdyAnSW52YWxpZCBwb2ludCwgdXNlIGFycmF5IFt4LCB5XSc7XG4gIH1cbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5LCB0aGlzKTsgIC8vIE5vdGU6IHRoaXMgPT09IHNwYWNlTm9kZVxufTtcblxudmFyIFNwYWNlUGxhbmUgPSBmdW5jdGlvbiAoc3BhY2VOb2RlKSB7XG4gIC8vIFBhcmFtZXRlcnNcbiAgLy8gICBzcGFjZU5vZGVcbiAgLy8gICAgIEEgU3BhY2VOb2RlIHRvIG1vbmtleSBwYXRjaCB0byBTcGFjZVBsYW5lXG5cbiAgLy8gQ29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvbi5cbiAgLy8gVGhlIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIHBsYW5lIHRvIHRoZSBwYXJlbnQgKHNwYWNlKS5cbiAgLy8gU2VlIDIwMTYtMDMtMDUtMDlcbiAgLy8gTGV0OlxuICAvLyAgIHhfc3BhY2UsIGEgcG9pbnQgaW4gc3BhY2VcbiAgLy8gICB4X3BsYW5lLCBhIHBvaW50IG9uIHRoZSBwbGFuZS5cbiAgLy8gICBULCB0aGUgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgcGxhbmVcbiAgLy8gVGhlbjpcbiAgLy8gICB4X3NwYWNlID0gVCAqIHhfcGxhbmVcbiAgLy9cbiAgLy8gRm9yIFNwYWNlLCBpdCBpcyBvYnZpb3VzbHkgdGhlIGlkZW50aXR5IHRyYW5zZm9ybTpcbiAgLy8gICB4X3NwYWNlID0gVCAqIHhfc3BhY2VcbiAgc3BhY2VOb2RlLl9UID0gbnVkZ2VkLlRyYW5zZm9ybS5JREVOVElUWTsgLy8gaWRlbnRpdHkgdHJhbnNmb3JtYXRpb25cblxuICBzcGFjZU5vZGUuYXQgPSBhdDtcblxuICBzcGFjZU5vZGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIExvY2FsIHRyYW5zZm9ybSBmcm9tIHBsYW5lIHRvIHBhcmVudFxuICAgIC8vXG4gICAgLy8gUmV0dXJuXG4gICAgLy8gICB0cmFuc2Zvcm1hdGlvbiBmcm9tIHBsYW5lIHRvIHBhcmVudCwgaS5lLlxuICAgIC8vICAgICB4eV9wYXJlbnQgPSBUICogeHlfcGxhbmVcbiAgICAvLyBOZWVkZWQgd2hlbiB3ZSB3YW50IHRvIHN0b3JlIHRyYW5zZm9ybWVyJ3MgcG9zaXRpb24gZm9yIGxhdGVyIHVzZS5cbiAgICByZXR1cm4gdGhpcy5fVDtcbiAgfTtcblxuICBzcGFjZU5vZGUuZ2V0R2xvYmFsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgdHJhbnNmb3JtYXRpb24gZnJvbSB0aGUgcGxhbmUgdG8gcm9vdCBjb250YWluZXIuXG4gICAgLy9cbiAgICAvLyBEZXYgbm90ZTpcbiAgICAvLyAgIExvY2FsIHRyYW5zZm9ybWF0aW9ucyBnbyBsaWtlOlxuICAgIC8vICAgICB4eV9wYXJlbnQgPSBUX3BsYW5lICogeHlfcGxhbmVcbiAgICAvLyAgICAgeHlfcGFyZW50X3BhcmVudCA9IFRfcGFyZW50ICogeHlfcGFyZW50XG4gICAgLy8gICAgIC4uLlxuICAgIC8vICAgICB4eV9yb290ID0gVF9wYXJlbnRfcGFyZW50Li4uX3BhcmVudCAqIHh5X3BhcmVudF9wYXJlbnQuLi5fcGFyZW50XG4gICAgLy8gICBUaGVyZWZvcmUgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uIGlzOlxuICAgIC8vICAgICB4eV9yb290ID0gVF9wYXJlbnRfLi4uX3BhcmVudCAqIC4uLiAqIFRfcGFyZW50ICogVF9wbGFuZSAqIHh5X3BsYW5lXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gVE9ETyBtYXliZSB0b28gZmFyOiB0aGlzLl9wYXJlbnQuX3BhcmVudCBtaWdodCBiZSBzdWZmaWNpZW50LlxuICAgICAgcmV0dXJuIHRoaXMuX1Q7XG4gICAgfSAvLyBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudC5nZXRHbG9iYWxUcmFuc2Zvcm0oKS5tdWx0aXBseUJ5KHRoaXMuX1QpO1xuICB9O1xuXG4gIHNwYWNlTm9kZS5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBCZWNvbWUgc3BhY2UuIENhbGxlZCBlLmcuIHdoZW4gcGxhbmUgaXMgcmVtb3ZlZCBmcm9tIHBhcmVudC5cbiAgICB0aGlzLl9UID0gbnVkZ2VkLlRyYW5zZm9ybS5JREVOVElUWTtcbiAgfTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZVBsYW5lO1xuIiwiLy8gQVBJIHYwLjYuMFxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxudmFyIFNwYWNlUG9pbnQgPSBmdW5jdGlvbiAoeHksIHJlZmVyZW5jZSkge1xuICAvLyBFeGFtcGxlXG4gIC8vICAgdmFyIHAgPSB0YWFzcGFjZS5TcGFjZVBvaW50KFt4LCB5XSwgdGFhKTtcbiAgLy9cbiAgLy8gUGFyYW1ldGVyXG4gIC8vICAgeHlcbiAgLy8gICAgIDJEIGFycmF5XG4gIC8vICAgcmVmZXJlbmNlXG4gIC8vICAgICBhIFNwYWNlTm9kZSBvciBTcGFjZVBvaW50XG4gIC8vICAgICAgIGFuIGl0ZW0gaW4gc3BhY2UsIGVuYWJsaW5nIGNvb3JkIHByb2plY3Rpb25zLlxuICB0aGlzLnh5ID0geHk7XG5cbiAgLy8gVGhlIFNwYWNlUGxhbmUncyB0cmFuc2Zvcm1hdGlvbiB0aGUgeHkgYXJlIG9uLlxuICAvLyBEZXNpZ24gbm90ZTogYXQgZmlyc3QsIHRoZSByZWZlcmVuY2VzIHdlcmUgU3BhY2VQbGFuZXMgYW5kIG5vdFxuICAvLyB0cmFuc2Zvcm1hdGlvbnMuIEJ1dCBiZWNhdXNlIGEgU3BhY2VQbGFuZSBjYW4gbW92ZSBvciBiZSByZW1vdmVkLFxuICAvLyB3ZSBjaG9zZSBvbmx5IHRoZSB0cmFuc2Zvcm1hdGlvbiB0byBiZSByZW1lbWJlcmVkLlxuICAvLyBEZXNpZ24gbm90ZTogbGF0ZXIgd2UgZm91bmQgaXQgd291bGQgYmUgY29udmVuaWVudCBmb3IgZGVidWdnaW5nXG4gIC8vIHRvIGtub3cgd2hlcmUgdGhlIHBvaW50IGNhbWUgZnJvbSwgd2hpY2ggbGVkIHRvIHRoaXMuX29yaWdpbi5cbiAgLy8gQWZ0ZXIgdGhhdCB3ZSBmb3VuZCB0aGF0IGluIHRvU3BhY2UgbWV0aG9kLCB3ZSB3b3VsZCBuZWVkIHJlZmVyZW5jZVxuICAvLyB0byBzcGFjZSwgYWx0aG91Z2ggd2Ugb25seSBoYXZlIGltcGxpY2l0IHJlZmVyZW5jZSB0byBpdHMgY29vcmRzLlxuICAvLyBUaGVyZWZvcmUgdGhpcy5fb3JpZ2luIHdhcyBkcm9wcGVkLlxuXG4gIGlmIChyZWZlcmVuY2UuaGFzT3duUHJvcGVydHkoJ2dldEdsb2JhbFRyYW5zZm9ybScpKSB7XG4gICAgLy8gSXMgYSBTcGFjZVBsYW5lXG4gICAgdGhpcy5fVCA9IHJlZmVyZW5jZS5nZXRHbG9iYWxUcmFuc2Zvcm0oKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBhIFNwYWNlUG9pbnRcbiAgICB0aGlzLl9UID0gcmVmZXJlbmNlLl9UO1xuICB9XG59O1xuXG52YXIgcHJvdG8gPSBTcGFjZVBvaW50LnByb3RvdHlwZTtcblxucHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gIHJldHVybiAodGhpcy54eVswXSA9PT0gcG9pbnQueHlbMF0gJiZcbiAgICB0aGlzLnh5WzFdID09PSBwb2ludC54eVsxXSAmJlxuICAgIHRoaXMuX1QuZXF1YWxzKHBvaW50Ll9UKSk7XG4gIH07XG5cbnByb3RvLm9mZnNldCA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IG5lYXJieS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyXG4gIC8vICAgZHhcbiAgLy8gICAgIE1vdmVtZW50IHRvd2FyZHMgcG9zaXRpdmUgeFxuICAvLyAgIGR5XG4gIC8vICAgICAuLi5cbiAgdmFyIHh5ID0gW3RoaXMueHlbMF0gKyBkeCwgdGhpcy54eVsxXSArIGR5XTtcbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5LCB0aGlzKTtcbn07XG5cbnByb3RvLnBvbGFyT2Zmc2V0ID0gZnVuY3Rpb24gKHJhZGl1cywgcmFkaWFucykge1xuICAvLyBDcmVhdGUgYSBuZXcgcG9pbnQgbW92ZWQgYnkgdGhlIHBvbGFyIGNvb3JkaW5hdGVzXG4gIHZhciB4ID0gdGhpcy54eVswXSArIHJhZGl1cyAqIE1hdGguY29zKHJhZGlhbnMpO1xuICB2YXIgeSA9IHRoaXMueHlbMV0gKyByYWRpdXMgKiBNYXRoLnNpbihyYWRpYW5zKTtcbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt4LCB5XSwgdGhpcyk7XG59O1xuXG5wcm90by50byA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IFNwYWNlUG9pbnQgYXQgc2FtZSBsb2NhdGlvbiBidXQgb24gYVxuICAvLyBkaWZmZXJlbnQgU3BhY2VQbGFuZS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyXG4gIC8vICAgdGFyZ2V0LCBhIFNwYWNlUGxhbmUgb3IgbnVsbC5cbiAgLy9cbiAgLy8gSW1wbGVtZW50YXRpb24gbm90ZSAoU2VlIDIwMTYtMDMtMDUtMDkpOlxuICAvL1xuICAvLyBGaXJzdCwgY29tcHV0ZSBjb29yZC4gdHJhbnNmLiBCIGZyb20gdGhlIGN1cnJlbnQgcGxhbmVcbiAgLy8gdG8gdGhlIHNwYWNlOlxuICAvLyAgIHhfc3BhY2UgPSBCICogeF9wbGFuZSAgPD0+ICB4X3BsYW5lID0gaW52KEIpICogeF9zcGFjZVxuICAvLyAgIEIgPSBwbGFuZS5fVFxuICAvLyBTZWNvbmQsIGxldCBBIGJlIGNvb3JkLiB0cmFuc2YuIGZyb20gdGhlIHNwYWNlIHRvIHRoZSB0YXJnZXQgcGxhbmU6XG4gIC8vICAgeF90YXJnZXQgPSBBICogeF9zcGFjZVxuICAvLyAgIEEgPSBpbnYodGFyZ2V0Ll9UKVxuICAvLyBUaGVyZWZvcmUgY29tYmluZWQgY29vcmQuIHRyYW5zZi4gQyBmcm9tIHRoZSBjdXJyLiBwbGFuZSB0byB0aGUgdGFyZ2V0OlxuICAvLyAgIHhfdGFyZ2V0ID0gQyAqIHhfcGxhbmVcbiAgLy8gICA8PT4gQSAqIHhfc3BhY2UgPSBDICogaW52KEIpICogeF9zcGFjZVxuICAvLyAgIDw9PiBBID0gQyAqIGludihCKVxuICAvLyAgIDw9PiBDID0gQUJcbiAgLy8gICA8PT4gQyA9IGludih0YXJnZXQuX1QpICogcGxhbmUuX1RcbiAgLy9cblxuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gdGFyZ2V0IGlzIHRoZSByb290IG5vZGUgKHNwYWNlKVxuICAgIHJldHVybiB0aGlzLnRvU3BhY2UoKTtcbiAgfVxuXG4gIC8vIFRhcmdldCdzIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbi4gVGhpcy5fVCBpcyBhbHJlYWR5IGdsb2JhbC5cbiAgdmFyIHRhcmdldF9nVCA9IHRhcmdldC5nZXRHbG9iYWxUcmFuc2Zvcm0oKTtcblxuICBpZiAodGFyZ2V0X2dULmVxdWFscyh0aGlzLl9UKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIGVsc2VcbiAgdmFyIEMgPSB0YXJnZXRfZ1QuaW52ZXJzZSgpLm11bHRpcGx5QnkodGhpcy5fVCk7XG4gIHZhciB4eV90YXJnZXQgPSBDLnRyYW5zZm9ybSh0aGlzLnh5KTtcbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5X3RhcmdldCwgdGFyZ2V0KTtcbn07XG5cbnByb3RvLnRvU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBTcGFjZVBvaW50IGF0IHNhbWUgbG9jYXRpb24gYnV0IHJlcHJlc2VudGVkIG9uIHNwYWNlIGNvb3Jkcy5cbiAgLy9cbiAgLy8gSW1wbGVtZW50YXRpb24gbm90ZTpcbiAgLy8gICBXZSBhbHJlYWR5IGhhdmUgY29vcmQuIHRyYW5zZi4gZnJvbSB0aGUgY3VycmVudCBwbGFuZSB0byB0aGUgc3BhY2U6XG4gIC8vICAgICBwbGFuZS5fVFxuICB2YXIgeHlfc3BhY2UgPSB0aGlzLl9ULnRyYW5zZm9ybSh0aGlzLnh5KTtcbiAgdmFyIHNwYWNlX21vY2sgPSB7J19UJzogVHJhbnNmb3JtLklERU5USVRZfTtcbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5X3NwYWNlLCBzcGFjZV9tb2NrKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cikge1xuICAvLyBDcmVhdGUgYSBuZXcgcG9pbnQgYnkgdHJhbnNmb3JtYXRpb24uXG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHRyXG4gIC8vICAgICBhIFRyYW5zZm9ybVxuICB2YXIgeHlfaGF0ID0gdHIudHJhbnNmb3JtKHRoaXMueHkpO1xuICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoeHlfaGF0LCB0aGlzKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZVBvaW50O1xuIiwiLy8gQVBJIHYzLjAuMFxuXG52YXIgU3BhY2VQb2ludCA9IHJlcXVpcmUoJy4vU3BhY2VQb2ludCcpO1xuXG52YXIgU3BhY2VSZWN0YW5nbGUgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXIpIHtcblxuICB2YXIgdCA9IHRyYW5zZm9ybWVyOyAgLy8gQWxpYXNcblxuICAvLyBSZWN0YW5nbGVzIGhhdmUgc2l6ZS5cbiAgLy8gSW4gaXRzIG93biBjb29yZGluYXRlcywgcmVjdGFuZ2xlJ3MgcmlnaHQgYm90dG9tIGNvcm5lclxuICAvLyBpcyBsb2NhdGVkIGF0IFt3aWR0aCwgaGVpZ2h0XS5cbiAgLy8gQnkgZGVmYXVsdCB0cmFuc2Zvcm1hdGlvbiwgd2lkdGggMSBhbmQgaGVpZ2h0IDEgZXF1YWwgdG8gMSBzcGFjZSB1bml0LlxuICB2YXIgd2lkdGggPSAxO1xuICB2YXIgaGVpZ2h0ID0gMTtcblxuICB0LmF0Tm9ybSA9IGZ1bmN0aW9uICh4eSkge1xuICAgIC8vIFJldHVybiBhIFNwYWNlUG9pbnQgYnkgY29vcmRpbmF0ZXMgbm9ybWFsaXplZCBhYm91dCB0aGUgc2l6ZS5cbiAgICAvLyBhdE5vcm0oWzEsMF0pIHJldHVybnMgdGhlIHBvaW50IGF0IHRoZSByaWdodCB1cHBlciBjb3JuZXIuXG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCAqIHh5WzBdLCBoZWlnaHQgKiB4eVsxXV0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoIC8gMiwgMF0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWRXID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbMCwgaGVpZ2h0IC8gMl0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWRFID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGgsIGhlaWdodCAvIDJdLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkUyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoIC8gMiwgaGVpZ2h0XSwgdCk7XG4gIH07XG5cbiAgdC5hdE5XID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbMCwgMF0sIHQpO1xuICB9O1xuXG4gIHQuYXRORSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoLCAwXSwgdCk7XG4gIH07XG5cbiAgdC5hdFNXID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbMCwgaGVpZ2h0XSwgdCk7XG4gIH07XG5cbiAgdC5hdFNFID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGgsIGhlaWdodF0sIHQpO1xuICB9O1xuXG4gIHQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHRdO1xuICB9O1xuXG4gIHQucmVzaXplID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRpbWVuc2lvbnMsIFt3aWR0aCwgaGVpZ2h0XVxuICAgIHdpZHRoID0gZGltZW5zaW9uc1swXTtcbiAgICBoZWlnaHQgPSBkaW1lbnNpb25zWzFdO1xuXG4gICAgdGhpcy5lbWl0KCdyZXNpemVkJywgdCk7XG4gIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VSZWN0YW5nbGU7XG4iLCIvLyBBUEkgdjAuNi4wXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBTcGFjZU5vZGUgPSByZXF1aXJlKCcuL1NwYWNlTm9kZScpO1xudmFyIFNwYWNlUGxhbmUgPSByZXF1aXJlKCcuL1NwYWNlUGxhbmUnKTtcbnZhciBUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtZXInKTtcbnZhciBTcGFjZVJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vU3BhY2VSZWN0YW5nbGUnKTtcblxudmFyIFNwYWNlVGFhID0gZnVuY3Rpb24gKHBhcmVudCwgdGFhKSB7XG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICAgcGFyZW50XG4gIC8vICAgICBhIFNwYWNlTm9kZVxuICAvLyAgIHRhYVxuICAvLyAgICAgYSBUYWFcbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VOb2RlKHRoaXMpO1xuICBTcGFjZVBsYW5lKHRoaXMpO1xuICBUcmFuc2Zvcm1lcih0aGlzKTtcbiAgU3BhY2VSZWN0YW5nbGUodGhpcyk7XG5cbiAgdGhpcy50YWEgPSB0YWE7XG4gIHRoaXMucmVzaXplKFsyNTYsIDI1Nl0pOyAgLy8gU2l6ZSBvZiB0YWEuXG5cbiAgdGhpcy5zZXRQYXJlbnQocGFyZW50KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VUYWE7XG4iLCIvLyBBUEkgdjAuNi4wXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgbG9hZGltYWdlcyA9IHJlcXVpcmUoJ2xvYWRpbWFnZXMnKTtcblxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIFRhYSA9IGZ1bmN0aW9uIChpbWdTcmMsIG9uTG9hZGVkKSB7XG4gIC8vIFBhcmFtZXRlcnNcbiAgLy8gICBpbWdTcmNcbiAgLy8gICBvbkxvYWRlZChlcnIsIHRhYSlcbiAgLy8gICAgIG9wdGlvbmFsLCBmdW5jdGlvbiAodGFhKVxuICBFbWl0dGVyKHRoaXMpO1xuICB2YXIgdGhpczIgPSB0aGlzO1xuXG4gIC8vIG9uTG9hZGVkIGlzIG9wdGlvbmFsXG4gIGlmICh0eXBlb2Ygb25Mb2FkZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkxvYWRlZCA9IE5PT1A7XG4gIH1cblxuICAvLyBUaGlzIG9iamVjdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgcmVhbCBJbWFnZSBvYmplY3QgYnV0IGJlZm9yZSB0aGF0XG4gIC8vIHNyYyBpcyBuZWVkZWQgaW4gU3BhY2VWaWV3LlxuICB0aGlzLmltYWdlID0geyBzcmM6IGltZ1NyYyB9O1xuXG4gIC8vIElmIHRoZSBpbWFnZSBpcyBjYWNoZWQsIHRoZSAnbG9hZCcgZXZlbnQgb2YgSW1hZ2UgZWxlbWVudCBpc1xuICAvLyBmaXJlZCBpbnN0YW50bHkgd2hlbiBjYWxsaW5nIGxvYWRpbWFnZXMuIElmIHdlIGRpZCBub3QgY2FyZVxuICAvLyBhYm91dCB0aGlzLCB0aGUgb24oJ2xvYWRlZCcsIGZuKSBsaXN0ZW5lcnMgd291bGQgZXhwZXJpZW5jZVxuICAvLyBkaWZmZXJlbnQgZXhlY3V0aW9uIG9yZGVyIGRlcGVuZGluZyB3aGV0aGVyIHRoZSBpbWFnZXMgd2FzXG4gIC8vIGNhY2hlZCBvciBub3QuXG4gIHZhciBub3RDYWNoZWQgPSBmYWxzZTtcblxuICBsb2FkaW1hZ2VzKGltZ1NyYywgZnVuY3Rpb24gKGVyciwgaW1hZ2UpIHtcbiAgICB2YXIgZW1pdGVyciwgZW1pdHRhYTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlbWl0ZXJyID0gZXJyO1xuICAgICAgZW1pdHRhYSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMyLmltYWdlID0gaW1hZ2U7XG4gICAgICBlbWl0ZXJyID0gbnVsbDtcbiAgICAgIGVtaXR0YWEgPSB0aGlzMjtcbiAgICB9XG5cbiAgICBpZiAobm90Q2FjaGVkKSB7XG4gICAgICB0aGlzMi5lbWl0KCdsb2FkZWQnLCBlbWl0ZXJyLCBlbWl0dGFhKTtcbiAgICAgIG9uTG9hZGVkKGVtaXRlcnIsIGVtaXR0YWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb3N0cG9uZSBlbWl0dGluZyBvZiB0aGUgbG9hZGVkIGV2ZW50XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpczIuZW1pdCgnbG9hZGVkJywgZW1pdGVyciwgZW1pdHRhYSk7XG4gICAgICAgIG9uTG9hZGVkKGVtaXRlcnIsIGVtaXR0YWEpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9KTtcblxuICBub3RDYWNoZWQgPSB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWE7XG4iLCIvLyBBUEkgdjAuNi4wXG52YXIgbnVkZ2VkID0gcmVxdWlyZSgnbnVkZ2VkJyk7XG5cbi8vIFRPRE9cbi8vIG1vbmtleXBhdGNoIFwidG8ocGxhbmUpXCJcblxubW9kdWxlLmV4cG9ydHMgPSBudWRnZWQuVHJhbnNmb3JtO1xuIiwiLy8gQVBJIHYzLjAuMFxudmFyIG51ZGdlZCA9IHJlcXVpcmUoJ251ZGdlZCcpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgU3BhY2VQb2ludCA9IHJlcXVpcmUoJy4vU3BhY2VQb2ludCcpO1xuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKHBvaW50cywgcGxhbmUpIHtcbiAgLy8gVHJhbnNmb3JtIGFsbCB0aGUgcG9pbnRzIG9udG8gdGhlIHBhcmVudCBhbmRcbiAgLy8gcmVwcmVzZW50IHRoZW0gaW4gYXJyYXkgW1t4MCx5MF0sIFt4MSx5MV0sIC4uLl0uXG4gIC8vXG4gIC8vIEFyZ3VtZW50czpcbiAgLy8gICBwb2ludHMsIGEgc2luZ2xlIHNwYWNlcG9pbnQgb3IgYSBsaXN0IG9mIHNwYWNlcG9pbnRzXG4gIC8vICAgcGxhbmUsIGEgU3BhY2VQbGFuZSBlLmcuIGEgU3BhY2VUYWEgb250byBub3JtYWxpemUuXG4gIC8vIFJldHVybjpcbiAgLy8gICBhcnJheSBvZiB4eSBwb2ludHMgaW4gc3BhY2UuXG4gIHZhciBpLCBwLCBucCwgbm9ybWFsaXplZDtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xuICAgIC8vIFNpbmdsZSBTcGFjZVBvaW50XG4gICAgcCA9IHBvaW50cztcbiAgICBucCA9IHAudG8ocGxhbmUpLnh5O1xuICAgIHJldHVybiBbbnBdO1xuICB9IC8vIGVsc2VcbiAgbm9ybWFsaXplZCA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICBucCA9IHAudG8ocGxhbmUpLnh5O1xuICAgIG5vcm1hbGl6ZWQucHVzaChucCk7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbnZhciB0cmFuc2Zvcm1CeUVzdGltYXRlID0gZnVuY3Rpb24gKHBsYW5lLCB0eXBlLCBkb21haW4sIHJhbmdlLCBwaXZvdCkge1xuICAvLyBUeXBlczogVCxTLFIsVFMsVFIsU1IsVFNSIChzZWUgbnVkZ2VkIGZvciBmdXJ0aGVyIGRldGFpbHMpXG5cbiAgdmFyIG5vcm1QaXZvdDtcbiAgaWYgKHR5cGVvZiBwaXZvdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBub3JtUGl2b3QgPSBub3JtYWxpemUocGl2b3QsIHBsYW5lLl9wYXJlbnQpWzBdO1xuICB9XG5cbiAgLy8gQ29udmVydCBhbGwgU3BhY2VQb2ludHMgb250byB0aGUgc3BhY2UgYW5kIHRvIGFycmF5c1xuICB2YXIgbm9ybURvbWFpbiA9IG5vcm1hbGl6ZShkb21haW4sIHBsYW5lLl9wYXJlbnQpO1xuICB2YXIgbm9ybVJhbmdlID0gbm9ybWFsaXplKHJhbmdlLCBwbGFuZS5fcGFyZW50KTtcblxuICAvLyBUaGVuIGNvbXB1dGUgb3B0aW1hbCB0cmFuc2Zvcm1hdGlvbiBpbiBzcGFjZVxuICB2YXIgSF9zcGFjZSA9IG51ZGdlZC5lc3RpbWF0ZSh0eXBlLCBub3JtRG9tYWluLCBub3JtUmFuZ2UsIG5vcm1QaXZvdCk7XG4gIC8vIFNlZSAyMDE2LTAzLTA1LTExOlxuICAvLyAgIFRvIGFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGEgc3BhY2Ugb2JqZWN0OlxuICAvLyAgICAgVF9oYXQgPSB0b1BhcmVudChIKSAqIFRcbiAgLy8gVGhlcmVmb3JlOlxuICBwbGFuZS5fVCA9IEhfc3BhY2UubXVsdGlwbHlCeShwbGFuZS5fVCk7XG5cbiAgLy8gTm90aWZ5IGVzcGVjaWFsbHkgdmlldyBhYm91dCB0cmFuc2Zvcm1hdGlvbi5cbiAgcGxhbmUuZW1pdCgndHJhbnNmb3JtZWQnLCBwbGFuZSk7XG59O1xuXG5cbnZhciBUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChwbGFuZSkge1xuICAvL1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgcGxhbmVcbiAgLy8gICAgIGEgU3BhY2VQbGFuZVxuXG4gIHBsYW5lLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChUKSB7XG4gICAgLy8gTmVlZGVkIHdoZW4gd2Ugd2hhbiB0byByZXN0b3JlIHN0b3JlZCBwb3NpdGlvbiwgbWF5YmUgYWZ0ZXJcbiAgICAvLyBtb2RpZmljYXRpb24uXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgYXJlIHJvb3QsIGNhbm5vdCBzZXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX1QgPSBUO1xuICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgfTtcblxuICBwbGFuZS5zZXRHbG9iYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoVCkge1xuICAgIC8vIFNldCBsb2NhbCB0cmFuc2Zvcm0gc28gdGhhdCB0aGUgZ2xvYmFsIHRyYW5zZm9ybSBiZWNvbWVzIHRoZSBnaXZlbiBULlxuICAgIC8vXG4gICAgLy8gRGV2IG5vdGU6XG4gICAgLy8gICBHaXZlbiBUIGlzIGNvb3JkLiB0cmFuc2YuIGZyb20gdGhlIHBsYW5lIHRvIHJvb3QgKHNwYWNlKS5cbiAgICAvLyAgIFNvIGlzIHRoaXMuX1QuXG4gICAgLy8gICBjdXJyZW50X2dsb2JfdHJhbnMgPSBwYXJlbnRfZ2xvYl90cmFucyAqIHRoaXNfVFxuICAgIC8vICAgbmV3X2dsb2JfdHJhbnMgPSBwYXJlbnRfZ2xvYl90cmFucyAqIFhcbiAgICAvLyAgIDw9PiBYID0gaW52KHBhcmVudF9nbG9iX3RyYW5zKSAqIG5ld19nbG9iX3RyYW5zXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgYXJlIHJvb3QsIGNhbm5vdCBzZXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJlbnRfZ2xvYmFsID0gdGhpcy5fcGFyZW50LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX1QgPSBwYXJlbnRfZ2xvYmFsLmludmVyc2UoKS5tdWx0aXBseUJ5KFQpO1xuICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgfTtcblxuICBwbGFuZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAgIC8vIE1vdmUgcGxhbmUgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5IGJ5IGV4YW1wbGUuXG4gICAgLy9cbiAgICAvLyBUcmFuc2xhdGUgdGhlIHBsYW5lIHNvIHRoYXQgYWZ0ZXIgdGhlIHRyYW5zbGF0aW9uLCB0aGUgZG9tYWluIHBvaW50c1xuICAgIC8vIHdvdWxkIGJlIGFzIGNsb3NlIHRvIGdpdmVuIHJhbmdlIHBvaW50cyBhcyBwb3NzaWJsZS5cbiAgICAvL1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgZG9tYWluXG4gICAgLy8gICByYW5nZVxuXG4gICAgdHJhbnNmb3JtQnlFc3RpbWF0ZSh0aGlzLCAnVCcsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIHBsYW5lLnNjYWxlID0gZnVuY3Rpb24gKHBpdm90LCBtdWx0aXBsaWVyT3JEb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBwaXZvdCwgYSBTcGFjZVBvaW50XG4gICAgLy8gICBtdWx0aXBsaWVyLCB0aGUgc2NhbGUgZmFjdG9yLCA+IDBcbiAgICAvLyAgT1JcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB2YXIgdXNlTXVsdGlwbGllciA9ICh0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKTtcblxuICAgIGlmICh1c2VNdWx0aXBsaWVyKSB7XG4gICAgICB2YXIgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCB0aGlzLl9wYXJlbnQpWzBdO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyT3JEb21haW47XG4gICAgICAvLyBNdWx0aXBsaWVyIGRvZXMgbm90IGRlcGVuZCBvbiBwbGFuZS5cbiAgICAgIC8vIFdlIGNyZWF0ZSBhIHBpdm90ZWQgc2NhbGluZyB0cmFuc2Zvcm0gb24gcGFyZW50LlxuICAgICAgdmFyIFNfcGFyZW50ID0gVHJhbnNmb3JtLklERU5USVRZLnNjYWxlQnkobXVsdGlwbGllciwgbm9ybVBpdm90KTtcbiAgICAgIC8vIFNlZSAyMDE2LTAzLTA1LTExXG4gICAgICAvLyAgIFdlIHRyYW5zZm9ybSBzcGFjZSBvYmplY3RzIGJ5OlxuICAgICAgLy8gICBUX2hhdCA9IEhfc3BhY2UgKiBUXG4gICAgICB0aGlzLl9UID0gU19wYXJlbnQubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvbWFpbiA9IG11bHRpcGxpZXJPckRvbWFpbjtcbiAgICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1MnLCBkb21haW4sIHJhbmdlLCBwaXZvdCk7XG4gICAgfVxuICB9O1xuXG4gIHBsYW5lLnJvdGF0ZSA9IGZ1bmN0aW9uIChwaXZvdCwgcmFkaWFuc09yRG9tYWluLCByYW5nZSkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgcGl2b3RcbiAgICAvLyAgIHJhZGlhbnNcbiAgICAvLyAgT1JcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB2YXIgdXNlUmFkaWFucyA9ICh0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKTtcblxuICAgIGlmICh1c2VSYWRpYW5zKSB7XG4gICAgICB2YXIgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCB0aGlzLl9wYXJlbnQpWzBdO1xuICAgICAgdmFyIHJhZGlhbnMgPSByYWRpYW5zT3JEb21haW47XG4gICAgICAvLyBSYWRpYW5zIGRvIG5vdCBkZXBlbmQgb24gcGxhbmUuXG4gICAgICAvLyBXZSBjcmVhdGUgYSBwaXZvdGVkIHJvdGF0aW9uIHRyYW5zZm9ybSBvbiBwYXJlbnQuXG4gICAgICB2YXIgUl9wYXJlbnQgPSBUcmFuc2Zvcm0uSURFTlRJVFkucm90YXRlQnkocmFkaWFucywgbm9ybVBpdm90KTtcbiAgICAgIC8vIFNlZSAyMDE2LTAzLTA1LTExXG4gICAgICAvLyAgIFdlIHRyYW5zZm9ybSBzcGFjZSBvYmplY3RzIGJ5OlxuICAgICAgLy8gICBUX2hhdCA9IEhfc3BhY2UgKiBUXG4gICAgICB0aGlzLl9UID0gUl9wYXJlbnQubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvbWFpbiA9IHJhZGlhbnNPckRvbWFpbjtcbiAgICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1InLCBkb21haW4sIHJhbmdlLCBwaXZvdCk7XG4gICAgfVxuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1RTJywgZG9tYWluLCByYW5nZSk7XG4gIH07XG5cbiAgcGxhbmUudHJhbnNsYXRlUm90YXRlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1RSJywgZG9tYWluLCByYW5nZSk7XG4gIH07XG5cbiAgcGxhbmUuc2NhbGVSb3RhdGUgPSBmdW5jdGlvbiAocGl2b3QsIGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1NSJywgZG9tYWluLCByYW5nZSwgcGl2b3QpO1xuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZVNjYWxlUm90YXRlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1RTUicsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIC8vIHBsYW5lLnRyYW5zbGF0ZUFuZFNjYWxlVG9GaXQsIG5vdCBzdXJlIGlmIG5lY2Vzc2FyeSBmb3Igbm93XG5cbiAgcGxhbmUub24oJ3JlbW92ZWQnLCBmdW5jdGlvbiAoc2VsZiwgb2xkUGFyZW50LCBuZXdQYXJlbnQpIHtcbiAgICAvLyBNYWludGFpbiBnbG9iYWwgbG9jYXRpb25cbiAgICBcbiAgICBpZiAodHlwZW9mIG9sZFBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgb2xkUGFyZW50ID0gbnVsbDsgfVxuICAgIGlmICh0eXBlb2YgbmV3UGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBuZXdQYXJlbnQgPSBudWxsOyB9XG5cbiAgICB2YXIgc2FtZVJvb3Q7XG4gICAgaWYgKG5ld1BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUm9vdCBub2RlcyBjYW5ub3QgbW92ZS5cbiAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9sZFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBSZW1vdmVkIGZyb20gbnVsbCBwYXJlbnQ/XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0Nhbm5vdCByZW1vdmUgZnJvbSBudWxsIHBhcmVudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW92ZWQgb250byBhbm90aGVyIHBhcmVudC5cbiAgICAgICAgLy8gTGV0IHVzIGtlZXAgdGhlIGxvY2F0aW9uIGluIHNwYWNlIHRoZSBzYW1lIGlmIHBvc3NpYmxlLlxuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSBvbmx5IGlmIHRoZSBwYXJlbnRzIHNoYXJlIHNhbWUgcm9vdCBpLmUuXG4gICAgICAgIC8vIGFyZSBpbiB0aGUgc2FtZSBzcGFjZS5cbiAgICAgICAgc2FtZVJvb3QgPSBvbGRQYXJlbnQuZ2V0Um9vdFBhcmVudCgpID09PSBuZXdQYXJlbnQuZ2V0Um9vdFBhcmVudCgpO1xuICAgICAgICBpZiAoc2FtZVJvb3QpIHtcbiAgICAgICAgICAvLyBLZWVwIHRoZSBsb2NhdGlvbi5cbiAgICAgICAgICAvLyBMZXRcbiAgICAgICAgICAvLyAgIE9UIGJlIHRoZSBvbGQgbG9jYWwgY29vcmQuIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgICAgIC8vICAgTlQgYmUgdGhlIHVua25vd24gbmV3IGxvY2FsIGNvb3JkLiB0cmFuc2YuXG4gICAgICAgICAgLy8gICBPUEdUIGJlIHRoZSBnbG9iYWwgY29vcmQuIHRyYW5zZi4gb2Ygb2xkIHBhcmVudFxuICAgICAgICAgIC8vICAgTlBHVCBiZSB0aGUgZ2xvYmFsIGNvb3JkLiB0cmFuc2YuIG9mIG5ldyBwYXJlbnRcbiAgICAgICAgICAvLyBOb3csIHdlIHdhbnQgdG8ga2VlcCBnbG9iYWwgdHJhbnNmLiB1bmNoYW5nZWQuXG4gICAgICAgICAgLy8gICBPUEdUICogT1QgPSBOUEdUICogTlRcbiAgICAgICAgICAvLyAgIDw9PiBOVCA9IGludihOUEdUKSAqIE9QR1QgKiBPVFxuICAgICAgICAgIHZhciBvcGd0ID0gb2xkUGFyZW50LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgICAgICAgIHZhciBucGd0ID0gbmV3UGFyZW50LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgICAgICAgIHZhciBvdCA9IHRoaXMuX1Q7XG4gICAgICAgICAgdmFyIG50ID0gbnBndC5pbnZlcnNlKCkubXVsdGlwbHlCeShvcGd0KS5tdWx0aXBseUJ5KG90KTtcbiAgICAgICAgICB0aGlzLl9UID0gbnQ7XG4gICAgICAgICAgdGhpcy5lbWl0KCd0cmFuc2Zvcm1lZCcsIHRoaXMpOyAvLyBUT0RPIElzIG5lZWRlZCBiZWNhdXNlIGlucGxhY2U/XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW4gZGlmZmVyZW50IHNwYWNlOiByZXNldFxuICAgICAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiB0aGVyZSBjb3VsZCBiZSBhIG5lZWQgdG8gY2hhbmdlIHBhcmVudCB3aXRoIHRoZSBzYW1lXG4gICAgICAgIC8vIGxvY2FsIHRyYW5zZm9ybWF0aW9uLiBOb3QgbmVlZGVkIGZvciBub3cuXG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1lcjtcbiIsIlxuZXhwb3J0cy5UYWEgPSByZXF1aXJlKCcuL1RhYScpO1xuZXhwb3J0cy5TcGFjZVRhYSA9IHJlcXVpcmUoJy4vU3BhY2VUYWEnKTtcbmV4cG9ydHMuU3BhY2VIVE1MID0gcmVxdWlyZSgnLi9TcGFjZUhUTUwnKTtcbmV4cG9ydHMuU3BhY2UgPSByZXF1aXJlKCcuL1NwYWNlJyk7XG5leHBvcnRzLkhUTUxTcGFjZVZpZXcgPSByZXF1aXJlKCcuL0hUTUxTcGFjZVZpZXcnKTtcblxuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICczLjAuMCc7XG4iXX0=
