(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.taaspace = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
module.exports = function loadimages(imgSrcs, then) {
  // Parameters
  //   imgSrcs
  //     array of image source paths OR single source path string.
  //   then(err, imgElements)
  //     Will be called after all the images are loaded. If string was given,
  //     imgElements is an Image instead of array of Images.

  var numberOfImages, stringGiven, thereWasSuccess, thereWasError, imgs;
  var onloadsCalled, onload, onerror;

  if (typeof then !== 'function') {
    throw new Error('callback should be a function: ' + then);
  }

  if (typeof imgSrcs === 'string') {
    numberOfImages = 1;
    stringGiven = true;
    imgSrcs = [imgSrcs]; // Normalize
  } else {
    // Array of images
    numberOfImages = imgSrcs.length;
    stringGiven = false;
  }
  thereWasSuccess = false;
  thereWasError = false;

  imgs = [];

  onloadsCalled = 0;
  onload = function () {
    // Note:
    //   this = Image
    if (!thereWasError) {
      onloadsCalled += 1;
      var isFinalImage = (onloadsCalled === numberOfImages);
      if (isFinalImage) {
        thereWasSuccess = true;
        if (stringGiven) {
          then(null, imgs[0]);
        } else {
          then(null, imgs);
        }
      }
    }
  };

  onerror = function (errMsg) {
    // Note:
    //   this = Image

    // No errors after success.
    if (!thereWasSuccess) {
      thereWasError = true;
      then(errMsg, null);
    }

    // Prevent firing the default event handler
    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror#Parameters
    return true;
  };

  for (i = 0; i < imgSrcs.length; i += 1) {
    imgs.push(new Image());
    imgs[i].onload = onload;
    imgs[i].onerror = onerror;
    imgs[i].src = imgSrcs[i];
  }
};

},{}],3:[function(require,module,exports){
/**
 * Module Dependencies.
 */

var Emitter = require('component-emitter');
var query = require('component-query');
var after = require('after-transition');
var has3d = require('has-translate3d');
var ease = require('css-ease');

/**
 * CSS Translate
 */

var translate = has3d
  ? ['translate3d(', ', 0)']
  : ['translate(', ')'];

/**
 * Export `Move`
 */

module.exports = Move;

/**
 * Get computed style.
 */

var style = window.getComputedStyle
  || window.currentStyle;

/**
 * Library version.
 */

Move.version = '0.5.0';

/**
 * Export `ease`
 */

Move.ease = ease;

/**
 * Defaults.
 *
 *   `duration` - default duration of 500ms
 *
 */

Move.defaults = {
  duration: 500
};

/**
 * Default element selection utilized by `move(selector)`.
 *
 * Override to implement your own selection, for example
 * with jQuery one might write:
 *
 *     move.select = function(selector) {
 *       return jQuery(selector).get(0);
 *     };
 *
 * @param {Object|String} selector
 * @return {Element}
 * @api public
 */

Move.select = function(selector){
  if ('string' != typeof selector) return selector;
  return query(selector);
};

/**
 * Initialize a new `Move` with the given `el`.
 *
 * @param {Element} el
 * @api public
 */

function Move(el) {
  if (!(this instanceof Move)) return new Move(el);
  if ('string' == typeof el) el = query(el);
  if (!el) throw new TypeError('Move must be initialized with element or selector');
  this.el = el;
  this._props = {};
  this._rotate = 0;
  this._transitionProps = [];
  this._transforms = [];
  this.duration(Move.defaults.duration)
};


/**
 * Inherit from `EventEmitter.prototype`.
 */

Emitter(Move.prototype);

/**
 * Buffer `transform`.
 *
 * @param {String} transform
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transform = function(transform){
  this._transforms.push(transform);
  return this;
};

/**
 * Skew `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skew = function(x, y){
  return this.transform('skew('
    + x + 'deg, '
    + (y || 0)
    + 'deg)');
};

/**
 * Skew x by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewX = function(n){
  return this.transform('skewX(' + n + 'deg)');
};

/**
 * Skew y by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewY = function(n){
  return this.transform('skewY(' + n + 'deg)');
};

/**
 * Translate `x` and `y` axis.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translate =
Move.prototype.to = function(x, y){
  return this.transform(translate.join(''
    + x +'px, '
    + (y || 0)
    + 'px'));
};

/**
 * Translate on the x axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateX =
Move.prototype.x = function(n){
  return this.transform('translateX(' + n + 'px)');
};

/**
 * Translate on the y axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateY =
Move.prototype.y = function(n){
  return this.transform('translateY(' + n + 'px)');
};

/**
 * Scale the x and y axis by `x`, or
 * individually scale `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scale = function(x, y){
  return this.transform('scale('
    + x + ', '
    + (y || x)
    + ')');
};

/**
 * Scale x axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleX = function(n){
  return this.transform('scaleX(' + n + ')')
};

/**
 * Apply a matrix transformation
 *
 * @param {Number} m11 A matrix coefficient
 * @param {Number} m12 A matrix coefficient
 * @param {Number} m21 A matrix coefficient
 * @param {Number} m22 A matrix coefficient
 * @param {Number} m31 A matrix coefficient
 * @param {Number} m32 A matrix coefficient
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.matrix = function(m11, m12, m21, m22, m31, m32){
  return this.transform('matrix(' + [m11,m12,m21,m22,m31,m32].join(',') + ')');
};

/**
 * Scale y axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleY = function(n){
  return this.transform('scaleY(' + n + ')')
};

/**
 * Rotate `n` degrees.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.rotate = function(n){
  return this.transform('rotate(' + n + 'deg)');
};

/**
 * Set transition easing function to to `fn` string.
 *
 * When:
 *
 *   - null "ease" is used
 *   - "in" "ease-in" is used
 *   - "out" "ease-out" is used
 *   - "in-out" "ease-in-out" is used
 *
 * @param {String} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.ease = function(fn){
  fn = ease[fn] || fn || 'ease';
  return this.setVendorProperty('transition-timing-function', fn);
};

/**
 * Set animation properties
 *
 * @param {String} name
 * @param {Object} props
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.animate = function(name, props){
  for (var i in props){
    if (props.hasOwnProperty(i)){
      this.setVendorProperty('animation-' + i, props[i])
    }
  }
  return this.setVendorProperty('animation-name', name);
}

/**
 * Set duration to `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.duration = function(n){
  n = this._duration = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-duration', n + 'ms');
};

/**
 * Delay the animation by `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.delay = function(n){
  n = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-delay', n + 'ms');
};

/**
 * Set `prop` to `val`, deferred until `.end()` is invoked.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setProperty = function(prop, val){
  this._props[prop] = val;
  return this;
};

/**
 * Set a vendor prefixed `prop` with the given `val`.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setVendorProperty = function(prop, val){
  this.setProperty('-webkit-' + prop, val);
  this.setProperty('-moz-' + prop, val);
  this.setProperty('-ms-' + prop, val);
  this.setProperty('-o-' + prop, val);
  return this;
};

/**
 * Set `prop` to `value`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.set = function(prop, val){
  this.transition(prop);
  this._props[prop] = val;
  return this;
};

/**
 * Increment `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.add = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr + val + 'px');
  });
};

/**
 * Decrement `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.sub = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr - val + 'px');
  });
};

/**
 * Get computed or "current" value of `prop`.
 *
 * @param {String} prop
 * @return {String}
 * @api public
 */

Move.prototype.current = function(prop){
  return style(this.el).getPropertyValue(prop);
};

/**
 * Add `prop` to the list of internal transition properties.
 *
 * @param {String} prop
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transition = function(prop){
  if (!this._transitionProps.indexOf(prop)) return this;
  this._transitionProps.push(prop);
  return this;
};

/**
 * Commit style properties, aka apply them to `el.style`.
 *
 * @return {Move} for chaining
 * @see Move#end()
 * @api private
 */

Move.prototype.applyProperties = function(){
  for (var prop in this._props) {
    this.el.style.setProperty(prop, this._props[prop], '');
  }
  return this;
};

/**
 * Re-select element via `selector`, replacing
 * the current element.
 *
 * @param {String} selector
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.move =
Move.prototype.select = function(selector){
  this.el = Move.select(selector);
  return this;
};

/**
 * Defer the given `fn` until the animation
 * is complete. `fn` may be one of the following:
 *
 *   - a function to invoke
 *   - an instanceof `Move` to call `.end()`
 *   - nothing, to return a clone of this `Move` instance for chaining
 *
 * @param {Function|Move} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.then = function(fn){
  // invoke .end()
  if (fn instanceof Move) {
    this.on('end', function(){
      fn.end();
    });
  // callback
  } else if ('function' == typeof fn) {
    this.on('end', fn);
  // chain
  } else {
    var clone = new Move(this.el);
    clone._transforms = this._transforms.slice(0);
    this.then(clone);
    clone.parent = this;
    return clone;
  }

  return this;
};

/**
 * Pop the move context.
 *
 * @return {Move} parent Move
 * @api public
 */

Move.prototype.pop = function(){
  return this.parent;
};

/**
 * Reset duration.
 *
 * @return {Move}
 * @api public
 */

Move.prototype.reset = function(){
  this.el.style.webkitTransitionDuration =
  this.el.style.mozTransitionDuration =
  this.el.style.msTransitionDuration =
  this.el.style.oTransitionDuration = '';
  return this;
};

/**
 * Start animation, optionally calling `fn` when complete.
 *
 * @param {Function} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.end = function(fn){
  var self = this;

  // emit "start" event
  this.emit('start');

  // transforms
  if (this._transforms.length) {
    this.setVendorProperty('transform', this._transforms.join(' '));
  }

  // transition properties
  this.setVendorProperty('transition-properties', this._transitionProps.join(', '));
  this.applyProperties();

  // callback given
  if (fn) this.then(fn);

  // emit "end" when complete
  after.once(this.el, function(){
    self.reset();
    self.emit('end');
  });

  return this;
};

},{"after-transition":4,"component-emitter":1,"component-query":8,"css-ease":9,"has-translate3d":10}],4:[function(require,module,exports){
var hasTransitions = require('has-transitions');
var emitter = require('css-emitter');

function afterTransition(el, callback) {
  if(hasTransitions(el)) {
    return emitter(el).bind(callback);
  }
  return callback.apply(el);
};

afterTransition.once = function(el, callback) {
  afterTransition(el, function fn(){
    callback.apply(el);
    emitter(el).unbind(fn);
  });
};

module.exports = afterTransition;
},{"css-emitter":5,"has-transitions":7}],5:[function(require,module,exports){
/**
 * Module Dependencies
 */

var events = require('event');

// CSS events

var watch = [
  'transitionend'
, 'webkitTransitionEnd'
, 'oTransitionEnd'
, 'MSTransitionEnd'
, 'animationend'
, 'webkitAnimationEnd'
, 'oAnimationEnd'
, 'MSAnimationEnd'
];

/**
 * Expose `CSSnext`
 */

module.exports = CssEmitter;

/**
 * Initialize a new `CssEmitter`
 *
 */

function CssEmitter(element){
  if (!(this instanceof CssEmitter)) return new CssEmitter(element);
  this.el = element;
}

/**
 * Bind CSS events.
 *
 * @api public
 */

CssEmitter.prototype.bind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.bind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Unbind CSS events
 * 
 * @api public
 */

CssEmitter.prototype.unbind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.unbind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Fire callback only once
 * 
 * @api public
 */

CssEmitter.prototype.once = function(fn){
  var self = this;
  function on(){
    self.unbind(on);
    fn.apply(self.el, arguments);
  }
  self.bind(on);
  return this;
};


},{"event":6}],6:[function(require,module,exports){

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  if (el.addEventListener) {
    el.addEventListener(type, fn, capture);
  } else {
    el.attachEvent('on' + type, fn);
  }
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  if (el.removeEventListener) {
    el.removeEventListener(type, fn, capture);
  } else {
    el.detachEvent('on' + type, fn);
  }
  return fn;
};

},{}],7:[function(require,module,exports){
/**
 * This will store the property that the current
 * browser uses for transitionDuration
 */
var property;

/**
 * The properties we'll check on an element
 * to determine if it actually has transitions
 * We use duration as this is the only property
 * needed to technically have transitions
 * @type {Array}
 */
var types = [
  "transitionDuration",
  "MozTransitionDuration",
  "webkitTransitionDuration"
];

/**
 * Determine the correct property for this browser
 * just once so we done need to check every time
 */
while(types.length) {
  var type = types.shift();
  if(type in document.body.style) {
    property = type;
  }
}

/**
 * Determine if the browser supports transitions or
 * if an element has transitions at all.
 * @param  {Element}  el Optional. Returns browser support if not included
 * @return {Boolean}
 */
function hasTransitions(el){
  if(!property) {
    return false; // No browser support for transitions
  }
  if(!el) {
    return property != null; // We just want to know if browsers support it
  }
  var duration = getComputedStyle(el)[property];
  return duration !== "" && parseFloat(duration) !== 0; // Does this element have transitions?
}

module.exports = hasTransitions;
},{}],8:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],9:[function(require,module,exports){

/**
 * CSS Easing functions
 */

module.exports = {
    'in':                'ease-in'
  , 'out':               'ease-out'
  , 'in-out':            'ease-in-out'
  , 'snap':              'cubic-bezier(0,1,.5,1)'
  , 'linear':            'cubic-bezier(0.250, 0.250, 0.750, 0.750)'
  , 'ease-in-quad':      'cubic-bezier(0.550, 0.085, 0.680, 0.530)'
  , 'ease-in-cubic':     'cubic-bezier(0.550, 0.055, 0.675, 0.190)'
  , 'ease-in-quart':     'cubic-bezier(0.895, 0.030, 0.685, 0.220)'
  , 'ease-in-quint':     'cubic-bezier(0.755, 0.050, 0.855, 0.060)'
  , 'ease-in-sine':      'cubic-bezier(0.470, 0.000, 0.745, 0.715)'
  , 'ease-in-expo':      'cubic-bezier(0.950, 0.050, 0.795, 0.035)'
  , 'ease-in-circ':      'cubic-bezier(0.600, 0.040, 0.980, 0.335)'
  , 'ease-in-back':      'cubic-bezier(0.600, -0.280, 0.735, 0.045)'
  , 'ease-out-quad':     'cubic-bezier(0.250, 0.460, 0.450, 0.940)'
  , 'ease-out-cubic':    'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
  , 'ease-out-quart':    'cubic-bezier(0.165, 0.840, 0.440, 1.000)'
  , 'ease-out-quint':    'cubic-bezier(0.230, 1.000, 0.320, 1.000)'
  , 'ease-out-sine':     'cubic-bezier(0.390, 0.575, 0.565, 1.000)'
  , 'ease-out-expo':     'cubic-bezier(0.190, 1.000, 0.220, 1.000)'
  , 'ease-out-circ':     'cubic-bezier(0.075, 0.820, 0.165, 1.000)'
  , 'ease-out-back':     'cubic-bezier(0.175, 0.885, 0.320, 1.275)'
  , 'ease-out-quad':     'cubic-bezier(0.455, 0.030, 0.515, 0.955)'
  , 'ease-out-cubic':    'cubic-bezier(0.645, 0.045, 0.355, 1.000)'
  , 'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'
  , 'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'
  , 'ease-in-out-sine':  'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
  , 'ease-in-out-expo':  'cubic-bezier(1.000, 0.000, 0.000, 1.000)'
  , 'ease-in-out-circ':  'cubic-bezier(0.785, 0.135, 0.150, 0.860)'
  , 'ease-in-out-back':  'cubic-bezier(0.680, -0.550, 0.265, 1.550)'
};

},{}],10:[function(require,module,exports){

var prop = require('transform-property');

// IE <=8 doesn't have `getComputedStyle`
if (!prop || !window.getComputedStyle) {
  module.exports = false;

} else {
  var map = {
    webkitTransform: '-webkit-transform',
    OTransform: '-o-transform',
    msTransform: '-ms-transform',
    MozTransform: '-moz-transform',
    transform: 'transform'
  };

  // from: https://gist.github.com/lorenzopolidori/3794226
  var el = document.createElement('div');
  el.style[prop] = 'translate3d(1px,1px,1px)';
  document.body.insertBefore(el, null);
  var val = getComputedStyle(el).getPropertyValue(map[prop]);
  document.body.removeChild(el);
  module.exports = null != val && val.length && 'none' != val;
}

},{"transform-property":11}],11:[function(require,module,exports){

var styles = [
  'webkitTransform',
  'MozTransform',
  'msTransform',
  'OTransform',
  'transform'
];

var el = document.createElement('p');
var style;

for (var i = 0; i < styles.length; i++) {
  style = styles[i];
  if (null != el.style[style]) {
    module.exports = style;
    break;
  }
}

},{}],12:[function(require,module,exports){
/*

*/
exports.Transform = require('./lib/Transform');
exports.estimateT = require('./lib/estimateT');
exports.estimateS = require('./lib/estimateS');
exports.estimateR = require('./lib/estimateR');
exports.estimateTS = require('./lib/estimateTS');
exports.estimateTR = require('./lib/estimateTR');
exports.estimateSR = require('./lib/estimateSR');
exports.estimateTSR = require('./lib/estimateTSR');
exports.version = require('./lib/version');

exports.estimate = function (type, domain, range, pivot) {
  // Parameter
  //   type
  //     string. One of the following: 'T', 'S', 'R', 'TS', 'TR', 'SR', 'TSR'
  //   domain
  //     array of 2d arrays
  //   range
  //     array of 2d arrays
  //   pivot
  //     optional 2d array, does nothing for translation estimators
  var name = 'estimate' + type.toUpperCase();
  if (exports.hasOwnProperty(name)) {
    return exports[name](domain, range, pivot);
  } // else
  throw new Error('Unknown estimator type: ' + type);
};

},{"./lib/Transform":13,"./lib/estimateR":14,"./lib/estimateS":15,"./lib/estimateSR":16,"./lib/estimateT":17,"./lib/estimateTR":18,"./lib/estimateTS":19,"./lib/estimateTSR":20,"./lib/version":21}],13:[function(require,module,exports){

var Transform = function (s, r, tx, ty) {

  // Public, to allow user access
  this.s = s;
  this.r = r;
  this.tx = tx;
  this.ty = ty;

  this.equals = function (t) {
    return (s === t.s && r === t.r && tx === t.tx && ty === t.ty);
  };

  this.transform = function (p) {
    // p
    //   point [x, y] or array of points [[x1,y1], [x2, y2], ...]

    if (typeof p[0] === 'number') {
      // Single point
      return [s * p[0] - r * p[1] + tx, r * p[0] + s * p[1] + ty];
    } // else

    var i, c = [];
    for (i = 0; i < p.length; i += 1) {
      c.push([s * p[i][0] - r * p[i][1] + tx, r * p[i][0] + s * p[i][1] + ty]);
    }
    return c;
  };

  this.getMatrix = function () {
    // Get the transformation matrix in the format common to
    // many APIs, including:
    // - kld-affine
    //
    // Return
    //   object o, having properties a, b, c, d, e, f:
    //   [ s  -r  tx ]   [ o.a  o.c  o.e ]
    //   [ r   s  ty ] = [ o.b  o.d  o.f ]
    //   [ 0   0   1 ]   [  -    -    -  ]
    return { a: s, b: r, c: -r, d: s, e: tx, f: ty };
  };

  this.getRotation = function () {
    // in rads
    return Math.atan2(r, s);
  };

  this.getScale = function () {
    // scale multiplier
    return Math.sqrt(r * r + s * s);
  };

  this.getTranslation = function () {
    return [tx, ty];
  };

  this.inverse = function () {
    // Return inversed transform instance
    // See note 2015-10-26-16-30
    var det = s * s + r * r;
    // Test if singular transformation. These might occur when all the range
    // points are the same, forcing the scale to drop to zero.
    var eps = 0.00000001;
    if (Math.abs(det) < eps) {
      throw new Error('Singular transformations cannot be inversed.');
    }
    var shat = s / det;
    var rhat = -r / det;
    var txhat = (-s * tx - r * ty) / det;
    var tyhat = ( r * tx - s * ty) / det;
    return new Transform(shat, rhat, txhat, tyhat);
  };

  this.translateBy = function (dx, dy) {
    return new Transform(s, r, tx + dx, ty + dy);
  };

  this.scaleBy = function (multiplier, pivot) {
    // Parameter
    //   multiplier
    //   pivot
    //     optional, a [x, y] point
    var m, x, y;
    m = multiplier; // alias
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    return new Transform(m * s, m * r, m * tx + (1-m) * x, m * ty + (1-m) * y);
  };

  this.rotateBy = function (radians, pivot) {
    // Parameter
    //   radians
    //     from positive x to positive y axis
    //   pivot
    //     optional, a [x, y] point
    var co, si, x, y, shat, rhat, txhat, tyhat;
    co = Math.cos(radians);
    si = Math.sin(radians);
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    shat = s * co - r * si;
    rhat = s * si + r * co;
    txhat = (tx - x) * co - (ty - y) * si + x;
    tyhat = (tx - x) * si + (ty - y) * co + y;
    return new Transform(shat, rhat, txhat, tyhat);
  };


  this.multiplyBy = function (transform) {
    // Multiply this transformation matrix A
    // from the right with the given transformation matrix B
    // and return the result AB

    // For reading aid:
    // s -r tx  t.s -r tx
    // r  s ty *  r  s ty
    // 0  0  1    0  0  1
    var t = transform; // alias
    var shat = s * t.s - r * t.r;
    var rhat = s * t.r + r * t.s;
    var txhat = s * t.tx - r * t.ty + tx;
    var tyhat = r * t.tx + s * t.ty + ty;
    return new Transform(shat, rhat, txhat, tyhat);
  };
};

Transform.IDENTITY = new Transform(1, 0, 0, 0);

module.exports = Transform;

},{}],14:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, ad, bc, bd, shat, rhat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = ad = bc = bd = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  p = ac + bd;
  q = ad - bc;

  D = Math.sqrt(p * p + q * q);

  if (D === 0) {
    // D === 0
    // <=> q === 0 and p === 0.
    // <=> ad === bc and ac === -bd
    // <=> domain in pivot OR range in pivot OR yet unknown cases
    //     where the angle cannot be determined.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  shat = p / D;
  rhat = q / D;
  tx = a0 - a0 * shat + b0 * rhat;
  ty = b0 - a0 * rhat - b0 * shat;

  return new Transform(shat, rhat, tx, ty);
};

},{"./Transform":13}],15:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, bd, aa, bb, shat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = bd = aa = bb = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    bd += b * d;
    aa += a * a;
    bb += b * b;
  }

  D = aa + bb;

  if (D === 0) {
    // All domain points equal the pivot.
    // Identity transform is then only solution.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  // Prevent negative scaling because it would be same as positive scaling
  // and rotation => limit to zero
  shat = Math.max(0, (ac + bd) / D);
  tx = (1 - shat) * a0;
  ty = (1 - shat) * b0;

  return new Transform(shat, 0, tx, ty);
};

},{"./Transform":13}],16:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  // Estimate optimal transformation given the domain and the range
  // so that the pivot point remains the same.
  //
  // Use cases
  //   - transform an image that has one corner fixed with a pin.
  //   - allow only scale and rotation by fixing the middle of the object
  //     to transform.
  //
  // Parameters
  //   domain, an array of [x, y] points
  //   range, an array of [x, y] points
  //   pivot, optional
  //     the point [x, y] that must remain constant in the tranformation.
  //     Defaults to origo [0, 0]
  //
  //
  var X, Y, N, s, r, tx, ty;

  // Optional pivot
  if (typeof pivot === 'undefined') {
    pivot = [0, 0];
  }

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  var v = pivot[0];
  var w = pivot[1];

  var i, a, b, c, d;
  var a2, b2;
  a2 = b2 = 0;
  var ac, bd, bc, ad;
  ac = bd = bc = ad = 0;

  for (i = 0; i < N; i += 1) {
    a = X[i][0] - v;
    b = X[i][1] - w;
    c = Y[i][0] - v;
    d = Y[i][1] - w;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
    bc += b * c;
    ad += a * d;
  }

  // Denominator = determinant.
  // It becomes zero iff N = 0 or X[i] = [v, w] for every i in [0, n).
  // In other words, iff all the domain points are under the fixed point or
  // there is no domain points.
  var den = a2 + b2;

  var eps = 0.00000001;
  if (Math.abs(den) < eps) {
    // The domain points are under the pivot or there is no domain points.
    // We assume identity transform be the simplest guess. It keeps
    // the domain points under the pivot if there is some.
    return new Transform(1, 0, 0, 0);
  }

  // Estimators
  s = (ac + bd) / den;
  r = (-bc + ad) / den;
  tx =  w * r - v * s + v;
  ty = -v * r - w * s + w;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],17:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  var i, N, a1, b1, c1, d1, txhat, tyhat;

  N = Math.min(domain.length, range.length);
  a1 = b1 = c1 = d1 = 0;

  if (N < 1) {
    // Assume identity transform be the best guess
    return Transform.IDENTITY;
  }

  for (i = 0; i < N; i += 1) {
    a1 += domain[i][0];
    b1 += domain[i][1];
    c1 += range[i][0];
    d1 += range[i][1];
  }

  txhat = (c1 - a1) / N;
  tyhat = (d1 - b1) / N;

  return new Transform(1, 0, txhat, tyhat);
};

},{"./Transform":13}],18:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, ac, ad, bc, bd;
  a1 = b1 = c1 = d1 = ac = ad = bc = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  // Denominator.
  var v = N * (ad - bc) - a1 * d1 + b1 * c1;
  var w = N * (ac + bd) - a1 * c1 - b1 * d1;
  var D = Math.sqrt(v * v + w * w);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> undecidable
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 - a1) / N, (d1 - b1) / N);
  }

  // Estimators
  var shat = w / D;
  var rhat = v / D;
  var txhat = (-a1 * shat + b1 * rhat + c1) / N;
  var tyhat = (-a1 * rhat - b1 * shat + d1) / N;

  return new Transform(shat, rhat, txhat, tyhat);
};

},{"./Transform":13}],19:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, a2, b2, ac, bd;
  a1 = b1 = c1 = d1 = a2 = b2 = ac = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  var N2 = N * N;
  var a12 = a1 * a1;
  var b12 = b1 * b1;
  var p = a2 + b2;
  var q = ac + bd;
  var D = N2 * p - N * (a12 + b12);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> all the domain points are the same
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  var shat = (N2 * q - N * (a1 * c1 + b1 * d1)) / D;
  var txhat = (-N * a1 * q + N * c1 * p - b12 * c1 + a1 * b1 * d1) / D;
  var tyhat = (-N * b1 * q + N * d1 * p - a12 * d1 + a1 * b1 * c1) / D;

  return new Transform(shat, 0, txhat, tyhat);
};

},{"./Transform":13}],20:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays
  var X, Y, N, s, r, tx, ty;

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  // If length is zero, no estimation can be done. We choose the indentity
  // transformation be the best quess.
  if (N === 0) {
    return new Transform(1, 0, 0, 0);
  } // else

  var i, a, b, c, d;
  var a1 = 0;
  var b1 = 0;
  var c1 = 0;
  var d1 = 0;
  var a2 = 0;
  var b2 = 0;
  var ad = 0;
  var bc = 0;
  var ac = 0;
  var bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ad += a * d;
    bc += b * c;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  // It is zero iff X[i] = X[j] for every i and j in [0, n).
  // In other words, iff all the domain points are the same or there is only one domain point.
  var den = N * a2 + N * b2 - a1 * a1 - b1 * b1;

  var eps = 0.00000001;
  if (-eps < den && den < eps) {
    // The domain points are the same.
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  s = (N * (ac + bd) - a1 * c1 - b1 * d1) / den;
  r = (N * (ad - bc) + b1 * c1 - a1 * d1) / den;
  tx = (-a1 * (ac + bd) + b1 * (ad - bc) + a2 * c1 + b2 * c1) / den;
  ty = (-b1 * (ac + bd) - a1 * (ad - bc) + a2 * d1 + b2 * d1) / den;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],21:[function(require,module,exports){
module.exports = '1.0.1';

},{}],22:[function(require,module,exports){
"use strict";

module.exports = SeqId

function SeqId(initial) {
  if (!(this instanceof SeqId)) {
    return new SeqId(initial)
  }
  if (initial == null) {
    initial = (Math.random() - 0.5) * Math.pow(2, 32)
  }
  this._id = initial | 0
}
SeqId.prototype.next = function () {
  this._id = (this._id + 1) | 0
  return this._id
}

},{}],23:[function(require,module,exports){
/*
API v0.4.0
View
*/
var Emitter = require('component-emitter');
var SpaceContainer = require('./SpaceContainer');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');
var SpaceTaa = require('./SpaceTaa');
var move = require('movejs');

// Disable animations by default.
move.defaults = { duration: 0 };

var HTMLSpaceView = function (space, htmlContainer) {
  // Test if valid dom element
  if (!('tagName' in htmlContainer)) {
    throw 'Container should be a DOM Element';
  }

  Emitter(this);
  SpaceContainer(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);
  var this2 = this;

  this._el = htmlContainer;

  // Two mappings from space taa ids:
  // 1. to HTML elements of the space taas.
  // 2. to SpaceTaa instances
  // Dev decision:
  //   For data structure, dict over list because key search time complexity.
  this._elements = {};
  this._spacetaas = {};

  (function initSize() {
    var w = this2._el.clientWidth;
    var h = this2._el.clientHeight;
    this2.resize([w, h]);
  }());

  var transformImage = function (img, spacetaa) {
    // Transform images because the view orientation.
    // See 2016-03-05-09.
    var spacetaa_global_T = spacetaa.getGlobalTransform();
    var T = this2._T.inverse().multiplyBy(spacetaa_global_T);
    // TODO What if view parent is not the root?
    //   Solution: getTransformTo(plane)
    // TODO Current move.js does not prevent scientific notation reaching CSS
    // which leads to problems with Safari and Opera. Therefore we must
    // prevent the notation here.
    // Of course this will cause error in the presentation.
    // However the error is only in the presentation and thus not a problem.
    var prec = 8;
    var s = T.s.toFixed(prec);
    var r = T.r.toFixed(prec);
    var tx = T.tx.toFixed(prec);
    var ty = T.ty.toFixed(prec);
    move(img).matrix(s, r,-r, s, tx, ty).end();
  };

  // Listen the space for new or removed taas or transformations

  var contentAddedHandler = function (spacecontainer, newParent, oldParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    // SpaceView, SpaceTaa ...
    var con = spacecontainer;

    if (this2._elements.hasOwnProperty(con.id)) {
      // Content is already drawn.
    } else {
      if (con instanceof SpaceTaa) {
        var taa = con.taa;
        var el = new Image(256, 256);
        el.src = taa.image.src;
        el.id = this2.id + '/' + con.id; // View-specific unique elem id
        el.className = 'taaspace-taa';
        // Show to client
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[con.id] = el;
        this2._spacetaas[con.id] = con;
        // Make transformation
        transformImage(el, con);
      } else if (con instanceof HTMLSpaceView) {
        // No representation for views.
      } else {
        throw new Exception('Unknown space content; cannot represent');
      }
    }
  };

  var contentRemovedHandler = function (spacecontent, oldParent, newParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot, el, con;

    con = spacecontent; // Alias

    // Decide sameRoot
    if (oldParent === null || newParent === null) {
      sameRoot = false;
    } else {
      sameRoot = oldParent.getRootParent() === newParent.getRootParent();
    }

    if (sameRoot) {
      // No reason to remove and then add again.
    } else {
      // New parent in different space, so not displayed in this view anymore.
      if (this2._elements.hasOwnProperty(con.id)) {
        // Remove HTML element
        el = this2._elements[con.id];
        this2._el.removeChild(el);
        // Remove from memory.
        // JS feature: does not throw if does not exist
        delete this2._elements[con.id];
        delete this2._spacetaas[con.id];
      }
    }

  };

  var contentTransformedHandler = function (spacecontent) {
    // Update css transformation.
    // If a container has children, they must also be transformed.
    var cons, i, con, el;
    cons = spacecontent.getAllChildren();
    cons.push(spacecontent);

    for (i = 0; i < cons.length; i += 1) {
      con = cons[i];
      if (this2._elements.hasOwnProperty(con.id)) {
        if (con instanceof SpaceTaa) {
          el = this2._elements[con.id];
          // Make transformation
          transformImage(el, con);
        }
        // Else: no transformable representation for Views.
      }
    }
  };

  // View added to new parent.
  this.on('added', function (self, newParent) {
    // TODO add content of the new space.
    newParent.on('contentAdded', contentAddedHandler);
    newParent.on('contentRemoved', contentRemovedHandler);
    newParent.on('contentTransformed', contentTransformedHandler);
  });
  // View removed from parent.
  this.on('removed', function (self, oldParent) {
    // TODO remove content of the old space.
    oldParent.off('contentAdded', contentAddedHandler);
    oldParent.off('contentRemoved', contentRemovedHandler);
    oldParent.off('contentTransformed', contentTransformedHandler);
  });

  // If the view is transformed, we of course need to retransform everything.
  this.on('transformed', function () {
    var id, element, spacetaa;
    for (id in this2._elements) {
      if (this2._elements.hasOwnProperty(id)) {
        element  = this2._elements[id];
        spacetaa = this2._spacetaas[id];
        transformImage(element, spacetaa);
      }
    }
  });

  this.getElementBySpaceTaa = function (spaceTaa) {
    // Get HTML element representation of the space taa.
    if (this._elements.hasOwnProperty(spaceTaa.id)) {
      return this._elements[spaceTaa.id];
    }
  };

  this.getSpaceTaaByElementId = function (id) {
    // Get space taa by HTML element id
    // Return null if no space taa for such id.
    var i = id.split('/');
    var spaceViewId = i[0];
    var spaceTaaId = i[1];
    if (this.id === spaceViewId) {
      if (this._spacetaas.hasOwnProperty(spaceTaaId)) {
        return this._spacetaas[spaceTaaId];
      }
    }
    return null;
  };

  this.getRootElement = function () {
    return this._el;
  };

  // View ready to be added to Space.
  this.setParent(space);
};

module.exports = HTMLSpaceView;

},{"./SpaceContainer":25,"./SpacePlane":26,"./SpaceRectangle":28,"./SpaceTaa":29,"./Transformer":32,"component-emitter":1,"movejs":3}],24:[function(require,module,exports){
/*
Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
  contentTransformed
*/
var Emitter = require('component-emitter');
var SpacePlane = require('./SpacePlane');
var SpaceContainer = require('./SpaceContainer');

var Space = function () {
  Emitter(this);

  SpaceContainer(this);
  // TODO remove possibility to add to parent.

  SpacePlane(this);
  // Space has constant identity transformation _T
};

module.exports = Space;

},{"./SpaceContainer":25,"./SpacePlane":26,"component-emitter":1}],25:[function(require,module,exports){
/*
Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
  contentTransformed
*/
var Emitter = require('component-emitter');

// Unique ID generator. Unique over session.
// Usage: seqid.next()
// Return: int
var seqid = require('seqid')(0);

var SpaceContainer = function (emitter) {
  // Parameters
  //   emitter, an Emitter.

  // Each container has an id. That is used by the parent containers.
  emitter.id = seqid.next().toString();

  // Containers with null parent are root containers i.e. spaces.
  // SpaceContainer#remove sets _parent to null.
  emitter._parent = null;

  // Dict over list because key search time complexity
  emitter._content = {};

  // We need to store built handlers bound to children
  // to be able to remove the handlers when child is removed.
  emitter._addedHandlers = {};
  emitter._removedHandlers = {};
  emitter._transformedHandlers = {};

  emitter.has = function (spacecontainer) {
    // Return
    //   true if spacetaa in space
    return spacecontainer._parent === this;
  };

  emitter.getParent = function () {
    return this._parent;
  };

  emitter.getRootParent = function () {
    if (this._parent === null) {
      return this;
    } // else
    return this._parent.getRootParent();
  };

  emitter.getChildren = function () {
    // Immediate child SpaceContainers in a list.
    var id, arr, obj;
    arr = [];
    obj = this._content;
    for (id in obj) {
      arr.push(obj[id]);
    }
    return arr;
  };

  emitter.getAllChildren = function () {
    // Descendants in a list.
    var i, children, child, arr;
    arr = [];
    children = this.getChildren();
    for (i = 0; i < children.length; i += 1) {
      child = children[i];
      arr = arr.concat(child, child.getAllChildren());
    }
    return arr;
  };

  emitter.setParent = function (newParent) {
    // Add to new parent container.

    var oldParent = this._parent;

    if (oldParent === null) {
      if (newParent === null) {
        // From root to root.
        // Do nothing
      } else {
        // From root to child.
        this._parent = newParent;
        this._parent._addChild(this);
        this.emit('added', this, this._parent, null);
        newParent.emit('contentAdded', this, this._parent, null);
      }
    } else {
      if (newParent === null) {
        // From child to root.
        this._parent = null; // Becomes new root container.
        oldParent._removeChild(this);
        this.emit('removed', this, oldParent, null);
        oldParent.emit('contentRemoved', this, oldParent, null);
      } else {
        // From child to child.
        this._parent = newParent;
        oldParent._removeChild(this);
        newParent._addChild(this);
        this.emit('removed', this, oldParent, newParent);
        this.emit('added', this, newParent, oldParent);
        // With both oldParent and newParent, SpaceView is able to
        // decide whether to keep same HTMLElement or recreate it.
        oldParent.emit('contentRemoved', this, oldParent, newParent);
        newParent.emit('contentAdded', this, newParent, oldParent);
      }
    }

  };

  emitter.remove = function () {
    // Remove this space container from parent container.
    // Return: see setParent
    return this.setParent(null);
  };

  emitter._addChild = function (child) {
    // To be called from child.setParent().
    //
    // Parameters
    //   child, A SpaceContainer
    //
    // Return
    //   undefined
    //
    // Dev. note:
    //   Previously this was called from the SpaceContainer constructor.
    //   However, because SpaceContainer upgrade is done before other
    //   upgrades, the child would not be ready to be added to parent.
    //   Therefore

    var sc = child; // alias
    var self = this;

    this._content[sc.id] = sc;

    // Start to listen if child has beed added, removed or transformed
    var addedHandler = function (a, b, c) {
      self.emit('contentAdded', a, b, c);
    };
    var removedHandler = function (a, b, c) {
      self.emit('contentRemoved', a, b, c);
    };
    var transformedHandler = function (a, b, c) {
      self.emit('contentTransformed', a, b, c);
    };
    // added and removed events are not listened because
    // for after successfully made add or remove,
    // contentAdded and contentRemoved are fired in setParent.
    sc.on('contentAdded', addedHandler);
    sc.on('contentRemoved', removedHandler);
    sc.on('transformed', transformedHandler);
    sc.on('contentTransformed', transformedHandler);
    this._addedHandlers[sc.id] = addedHandler;
    this._removedHandlers[sc.id] = removedHandler;
    this._transformedHandlers[sc.id] = transformedHandler;
  };

  emitter._removeChild = function (spacecontainer) {
    // To be called from SpaceContainer#remove
    // Precondition: spacecontainer in space
    var sc, h;

    sc = spacecontainer; // alias
    delete this._content[sc.id];

    // Remove handlers
    h = this._addedHandlers[sc.id];
    delete this._addedHandlers[sc.id];
    sc.off('contentAdded', h);

    h = this._removedHandlers[sc.id];
    delete this._removedHandlers[sc.id];
    sc.off('contentRemoved', h);

    h = this._transformedHandlers[sc.id];
    delete this._transformedHandlers[sc.id];
    sc.off('transformed', h);
    sc.off('contentTransformed', h);
  };
};

module.exports = SpaceContainer;

},{"component-emitter":1,"seqid":22}],26:[function(require,module,exports){
/*
SpacePlane
API v0.6.0

A SpacePlane represents a coordinate system. It does not include
methods to transform the system. SpacePlane and Transformer are separated
because we want to have planes that cannot be transformed, as Space.

*/

var nudged = require('nudged');
var SpacePoint = require('./SpacePoint');

var at = function (xy) {
  // Return
  //   A SpacePoint at (x,y) on the plane.
  if (xy.length !== 2) {  // DEBUG TODO remove this
    throw 'Invalid point, use array [x, y]';
  }
  return new SpacePoint(xy, this);  // Note: this === emitter
};

var SpacePlane = function (emitter) {
  // Parameters
  //   emitter
  //     A SpaceContainer to monkey patch to SpacePlane

  // Coordinate transformation.
  // The transformation from the plane to the parent (space).
  // See 2016-03-05-09
  // Let:
  //   x_space, a point in space
  //   x_plane, a point on the plane.
  //   T, the coordinate transformation of the plane
  // Then:
  //   x_space = T * x_plane
  //
  // For Space, it is obviously the identity transform:
  //   x_space = T * x_space
  emitter._T = nudged.Transform.IDENTITY; // identity transformation

  emitter.at = at;

  emitter.getTransform = function () {
    // Local transform from plane to parent
    //
    // Return
    //   transformation from plane to parent, i.e.
    //     xy_parent = T * xy_plane
    // Needed when we want to store transformer's position for later use.
    return this._T;
  };

  emitter.getGlobalTransform = function () {
    // Return
    //   transformation from the plane to root container.
    //
    // Dev note:
    //   Local transformations go like:
    //     xy_parent = T_plane * xy_plane
    //     xy_parent_parent = T_parent * xy_parent
    //     ...
    //     xy_root = T_parent_parent..._parent * xy_parent_parent..._parent
    //   Therefore global transformation is:
    //     xy_root = T_parent_..._parent * ... * T_parent * T_plane * xy_plane
    if (this._parent === null) {
      // TODO maybe too far: this._parent._parent might be sufficient.
      return this._T;
    } // else
    return this._parent.getGlobalTransform().multiplyBy(this._T);
  };

  emitter.resetTransform = function () {
    // Become space. Called e.g. when plane is removed from parent.
    this._T = nudged.Transform.IDENTITY;
  };
  
};

module.exports = SpacePlane;

},{"./SpacePoint":27,"nudged":12}],27:[function(require,module,exports){
// API v0.3.0

var Transform = require('./Transform');

var SpacePoint = function (xy, reference) {
  // Example
  //   var p = taaspace.Point([x, y], taa);
  //
  // Parameter
  //   xy
  //     2D array
  //   reference
  //     a SpaceContainer or SpacePoint
  //       an item in space, enabling coord projections.
  this.xy = xy;

  // The SpacePlane's transformation the xy are on.
  // Design note: at first, the references were SpacePlanes and not
  // transformations. But because a SpacePlane can move or be removed,
  // we chose only the transformation to be remembered.
  // Design note: later we found it would be convenient for debugging
  // to know where the point came from, which led to this._origin.
  // After that we found that in toSpace method, we would need reference
  // to space, although we only have implicit reference to its coords.
  // Therefore this._origin was dropped.

  if (reference.hasOwnProperty('getGlobalTransform')) {
    // Is a SpacePlane
    this._T = reference.getGlobalTransform();
  } else {
    // Is a SpacePoint
    this._T = reference._T;
  }
};

var proto = SpacePoint.prototype;


proto.offset = function (dx, dy) {
  // Create a new point nearby.
  //
  // Parameter
  //   dx
  //     Movement towards positive x
  //   dy
  //     ...
  var xy = [this.xy[0] + dx, this.xy[1] + dy];
  return new SpacePoint(xy, this);
};

proto.polarOffset = function (radius, radians) {
  // Create a new point moved by the polar coordinates
  var x = this.xy[0] + radius * Math.cos(radians);
  var y = this.xy[1] + radius * Math.sin(radians);
  return new SpacePoint([x, y], this);
};

proto.equals = function (point) {
  return (this.xy[0] === point.xy[0] &&
          this.xy[1] === point.xy[1] &&
          this._T.equals(point._T));
};

proto.to = function (target) {
  // Create a new SpacePoint at same location but on a
  // different SpacePlane.
  //
  // Parameter
  //   target, a SpacePlane or null.
  //
  // Implementation note (See 2016-03-05-09):
  //
  // First, compute coord. transf. B from the current plane
  // to the space:
  //   x_space = B * x_plane  <=>  x_plane = inv(B) * x_space
  //   B = plane._T
  // Second, let A be coord. transf. from the space to the target plane:
  //   x_target = A * x_space
  //   A = inv(target._T)
  // Therefore combined coord. transf. C from the curr. plane to the target:
  //   x_target = C * x_plane
  //   <=> A * x_space = C * inv(B) * x_space
  //   <=> A = C * inv(B)
  //   <=> C = AB
  //   <=> C = inv(target._T) * plane._T
  //

  if (target === null) {
    // target is the root container (space)
    return this.toSpace();
  }

  // Target's global transformation. This._T is already global.
  var target_gT = target.getGlobalTransform();

  if (target_gT.equals(this._T)) {
    return this;
  } // else
  var C = target_gT.inverse().multiplyBy(this._T);
  var xy_target = C.transform(this.xy);
  return new SpacePoint(xy_target, target);
};

proto.toSpace = function () {
  // Create a new SpacePoint at same location but represented on space coords.
  //
  // Implementation note:
  //   We already have coord. transf. from the current plane to the space:
  //     plane._T
  var xy_space = this._T.transform(this.xy);
  var space_mock = {'_T': Transform.IDENTITY};
  return new SpacePoint(xy_space, space_mock);
};

proto.transform = function (tr) {
  // Create a new point by transformation.
  //
  // Parameter
  //   tr
  //     a Transform
  var xy_hat = tr.transform(this.xy);
  return new SpacePoint(xy_hat, this);
};


module.exports = SpacePoint;

},{"./Transform":31}],28:[function(require,module,exports){
// API v0.5.0
//var nudged = require('nudged');
var SpacePoint = require('./SpacePoint');

var SpaceRectangle = function (transformer) {

  var t = transformer;  // Alias

  // Rectangles have size.
  // In its own coordinates, rectangle's right bottom corner
  // is located at [width, height].
  // By default transformation, width 1 and height 1 equal to 1 space unit.
  var width = 1;
  var height = 1;

  t.resize = function (dimensions) {
    // Parameter
    //   dimensions, [width, height]
    width = dimensions[0];
    height = dimensions[1];

    this.emit('resized', t);
  };

  t.getSize = function () {
    return [width, height];
  };

  t.atNorm = function (xy) {
    // Return a SpacePoint by coordinates normalized about the size.
    // atNorm([1,0]) returns the point at the right upper corner.
    return new SpacePoint([width * xy[0], height * xy[1]], t);
  };

  t.atMid = function () {
    return new SpacePoint([width / 2, height / 2], t);
  };

  t.atMidN = function () {
    return new SpacePoint([width / 2, 0], t);
  };

  t.atMidW = function () {
    return new SpacePoint([0, height / 2], t);
  };

  t.atMidE = function () {
    return new SpacePoint([width, height / 2], t);
  };

  t.atMidS = function () {
    return new SpacePoint([width / 2, height], t);
  };

  t.atNW = function () {
    return new SpacePoint([0, 0], t);
  };

  t.atNE = function () {
    return new SpacePoint([width, 0], t);
  };

  t.atSW = function () {
    return new SpacePoint([0, height], t);
  };

  t.atSE = function () {
    return new SpacePoint([width, height], t);
  };

};

module.exports = SpaceRectangle;

},{"./SpacePoint":27}],29:[function(require,module,exports){
// v0.3.0

var Emitter = require('component-emitter');
var SpaceContainer = require('./SpaceContainer');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceTaa = function (parent, taa) {
  Emitter(this);
  SpaceContainer(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);

  this.taa = taa;
  this.resize([256, 256]); // Size of taa.

  this.setParent(parent);
};

module.exports = SpaceTaa;

},{"./SpaceContainer":25,"./SpacePlane":26,"./SpaceRectangle":28,"./Transformer":32,"component-emitter":1}],30:[function(require,module,exports){
// API v0.3.0
var Emitter = require('component-emitter');
var loadimages = require('loadimages');

var NOOP = function () {};

var Taa = function (imgSrc, onLoaded) {
  // Parameters
  //   imgSrc
  //   onLoaded(err, taa)
  //     optional, function (taa)
  Emitter(this);
  var this2 = this;

  // onLoaded is optional
  if (typeof onLoaded !== 'function') {
    onLoaded = NOOP;
  }

  // This object will be replaced by a real Image object but before that
  // src is needed in SpaceView.
  this.image = { src: imgSrc };

  // If the image is cached, the 'load' event of Image element is
  // fired instantly when calling loadimages. If we did not care
  // about this, the on('loaded', fn) listeners would experience
  // different execution order depending whether the images was
  // cached or not.
  var notCached = false;

  loadimages(imgSrc, function (err, image) {
    this2.image = image;

    if (notCached) {
      this2.emit('loaded', err, this2);
      onLoaded(err, this2);
    } else {
      setTimeout(function () {
        this2.emit('loaded', err, this2);
        onLoaded(err, this2);
      }, 0);
    }
  });
  notCached = true;
};

module.exports = Taa;

},{"component-emitter":1,"loadimages":2}],31:[function(require,module,exports){
// API v0.2.0
var nudged = require('nudged');

// TODO
// monkeypatch "to(plane)"

module.exports = nudged.Transform;

},{"nudged":12}],32:[function(require,module,exports){
// API v0.2.0
var nudged = require('nudged');
var Transform = require('./Transform');
var SpacePoint = require('./SpacePoint');

var normalize = function (points, plane) {
  // Transform all the points onto the parent and
  // represent them in array [[x0,y0], [x1,y1], ...].
  //
  // Arguments
  //   points, a single spacepoint or a list of spacepoints
  //   plane, a SpacePlane e.g. a SpaceTaa onto normalize.
  // Return
  //   array of xy points in space.
  var i, p, np, normalized;

  if (!Array.isArray(points)) {
    // Single SpacePoint
    p = points;
    np = p.to(plane).xy;
    return [np];
  } // else
  normalized = [];
  for (i = 0; i < points.length; i += 1) {
    p = points[i];
    np = p.to(plane).xy;
    normalized.push(np);
  }
  return normalized;
};


var transformByEstimate = function (plane, type, domain, range, pivot) {
  // Types: T,S,R,TS,TR,SR,TSR (see nudged for further details)

  var normPivot;
  if (typeof pivot !== 'undefined') {
    normPivot = normalize(pivot, plane._parent)[0];
  }

  // Convert all SpacePoints onto the space and to arrays
  var normDomain = normalize(domain, plane._parent);
  var normRange = normalize(range, plane._parent);

  // Then compute optimal transformation in space
  var H_space = nudged.estimate(type, normDomain, normRange, normPivot);
  // See 2016-03-05-11:
  //   To apply transformation to a space object:
  //     T_hat = toParent(H) * T
  // Therefore:
  plane._T = H_space.multiplyBy(plane._T);

  // Notify especially view about transformation.
  plane.emit('transformed', plane);
};


var Transformer = function (plane) {
  //
  // Parameters
  //   plane
  //     a SpaceContainer

  plane.setTransform = function (T) {
    // Needed when we whan to restore stored position, maybe after
    // modification.
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    this._T = T;
    this.emit('transformed', this);
  };

  plane.setGlobalTransform = function (T) {
    // Set local transform so that the global transform becomes the given T.
    //
    // Dev note:
    //   Given T is coord. transf. from the plane to root (space).
    //   So is this._T.
    //   current_glob_trans = parent_glob_trans * this_T
    //   new_glob_trans = parent_glob_trans * X
    //   <=> X = inv(parent_glob_trans) * new_glob_trans
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    var parent_global = this._parent.getGlobalTransform();
    this._T = parent_global.inverse().multiplyBy(T);
    this.emit('transformed', this);
  };

  plane.translate = function (domain, range) {
    // Move plane horizontally and vertically by example.
    //
    // Translate the plane so that after the translation, the domain points
    // would be as close to given range points as possible.
    //
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'T', domain, range);
  };

  plane.scale = function (pivot, multiplierOrDomain, range) {
    // Parameter
    //   pivot, a SpacePoint
    //   multiplier, the scale factor, > 0
    //  OR
    //   pivot
    //   domain
    //   range

    var useMultiplier = (typeof range === 'undefined');

    if (useMultiplier) {
      var normPivot = normalize(pivot, this._parent)[0];
      var multiplier = multiplierOrDomain;
      // Multiplier does not depend on plane.
      // We create a pivoted scaling transform on parent.
      var S_parent = Transform.IDENTITY.scaleBy(multiplier, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = S_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = multiplierOrDomain;
      transformByEstimate(this, 'S', domain, range, pivot);
    }
  };

  plane.rotate = function (pivot, radiansOrDomain, range) {
    // Parameter
    //   pivot
    //   radians
    //  OR
    //   pivot
    //   domain
    //   range

    var useRadians = (typeof range === 'undefined');

    if (useRadians){
      var normPivot = normalize(pivot, this._parent)[0];
      var radians = radiansOrDomain;
      // Radians do not depend on plane.
      // We create a pivoted rotation transform on parent.
      var R_parent = Transform.IDENTITY.rotateBy(radians, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = R_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = radiansOrDomain;
      transformByEstimate(this, 'R', domain, range, pivot);
    }
  };

  plane.translateScale = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TS', domain, range);
  };

  plane.translateRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TR', domain, range);
  };

  plane.scaleRotate = function (pivot, domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'SR', domain, range, pivot);
  };

  plane.translateScaleRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TSR', domain, range);
  };

  // plane.translateAndScaleToFit, not sure if necessary for now

  plane.on('removed', function (self, oldParent, newParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot;
    if (newParent === null) {
      // Root containers cannot move.
      this.resetTransform();
    } else {
      if (oldParent === null) {
        // Removed from null parent?
        throw new Exception('Cannot remove from null parent');
      } else {
        // Moved onto another parent.
        // Let us keep the location in space the same if possible.
        // It is possible only if the parents share same root i.e.
        // are in the same space.
        sameRoot = oldParent.getRootParent() === newParent.getRootParent();
        if (sameRoot) {
          // Keep the location.
          // Let
          //   OT be the old local coord. transformation.
          //   NT be the unknown new local coord. transf.
          //   OPGT be the global coord. transf. of old parent
          //   NPGT be the global coord. transf. of new parent
          // Now, we want to keep global transf. unchanged.
          //   OPGT * OT = NPGT * NT
          //   <=> NT = inv(NPGT) * OPGT * OT
          var opgt = oldParent.getGlobalTransform();
          var npgt = newParent.getGlobalTransform();
          var ot = this._T;
          var nt = npgt.inverse().multiplyBy(opgt).multiplyBy(ot);
          this._T = nt;
          this.emit('transformed', this); // TODO Is needed because inplace?
        } else {
          // In different space: reset
          this.resetTransform();
        }
        // Note: there could be a need to change parent with the same
        // local transformation. Not needed for now.
      }

    }
  });
};

module.exports = Transformer;

},{"./SpacePoint":27,"./Transform":31,"nudged":12}],33:[function(require,module,exports){

exports.Taa = require('./Taa');
exports.SpaceTaa = require('./SpaceTaa');
exports.Space = require('./Space');
exports.HTMLSpaceView = require('./HTMLSpaceView');

exports.version = require('./version');

},{"./HTMLSpaceView":23,"./Space":24,"./SpaceTaa":29,"./Taa":30,"./version":34}],34:[function(require,module,exports){
module.exports = '3.0.0';

},{}]},{},[33])(33)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9hZGltYWdlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L25vZGVfbW9kdWxlcy9ldmVudC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL25vZGVfbW9kdWxlcy9oYXMtdHJhbnNpdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jb21wb25lbnQtcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jc3MtZWFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9ub2RlX21vZHVsZXMvdHJhbnNmb3JtLXByb3BlcnR5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL1RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUi5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlU1IuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVQuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVRSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvZXN0aW1hdGVUUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlVFNSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZXFpZC9zZXFpZC5qcyIsInNyYy9IVE1MU3BhY2VWaWV3LmpzIiwic3JjL1NwYWNlLmpzIiwic3JjL1NwYWNlQ29udGFpbmVyLmpzIiwic3JjL1NwYWNlUGxhbmUuanMiLCJzcmMvU3BhY2VQb2ludC5qcyIsInNyYy9TcGFjZVJlY3RhbmdsZS5qcyIsInNyYy9TcGFjZVRhYS5qcyIsInNyYy9UYWEuanMiLCJzcmMvVHJhbnNmb3JtLmpzIiwic3JjL1RyYW5zZm9ybWVyLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3ZlcnNpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDempCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkaW1hZ2VzKGltZ1NyY3MsIHRoZW4pIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGltZ1NyY3NcbiAgLy8gICAgIGFycmF5IG9mIGltYWdlIHNvdXJjZSBwYXRocyBPUiBzaW5nbGUgc291cmNlIHBhdGggc3RyaW5nLlxuICAvLyAgIHRoZW4oZXJyLCBpbWdFbGVtZW50cylcbiAgLy8gICAgIFdpbGwgYmUgY2FsbGVkIGFmdGVyIGFsbCB0aGUgaW1hZ2VzIGFyZSBsb2FkZWQuIElmIHN0cmluZyB3YXMgZ2l2ZW4sXG4gIC8vICAgICBpbWdFbGVtZW50cyBpcyBhbiBJbWFnZSBpbnN0ZWFkIG9mIGFycmF5IG9mIEltYWdlcy5cblxuICB2YXIgbnVtYmVyT2ZJbWFnZXMsIHN0cmluZ0dpdmVuLCB0aGVyZVdhc1N1Y2Nlc3MsIHRoZXJlV2FzRXJyb3IsIGltZ3M7XG4gIHZhciBvbmxvYWRzQ2FsbGVkLCBvbmxvYWQsIG9uZXJyb3I7XG5cbiAgaWYgKHR5cGVvZiB0aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbjogJyArIHRoZW4pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbWdTcmNzID09PSAnc3RyaW5nJykge1xuICAgIG51bWJlck9mSW1hZ2VzID0gMTtcbiAgICBzdHJpbmdHaXZlbiA9IHRydWU7XG4gICAgaW1nU3JjcyA9IFtpbWdTcmNzXTsgLy8gTm9ybWFsaXplXG4gIH0gZWxzZSB7XG4gICAgLy8gQXJyYXkgb2YgaW1hZ2VzXG4gICAgbnVtYmVyT2ZJbWFnZXMgPSBpbWdTcmNzLmxlbmd0aDtcbiAgICBzdHJpbmdHaXZlbiA9IGZhbHNlO1xuICB9XG4gIHRoZXJlV2FzU3VjY2VzcyA9IGZhbHNlO1xuICB0aGVyZVdhc0Vycm9yID0gZmFsc2U7XG5cbiAgaW1ncyA9IFtdO1xuXG4gIG9ubG9hZHNDYWxsZWQgPSAwO1xuICBvbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTm90ZTpcbiAgICAvLyAgIHRoaXMgPSBJbWFnZVxuICAgIGlmICghdGhlcmVXYXNFcnJvcikge1xuICAgICAgb25sb2Fkc0NhbGxlZCArPSAxO1xuICAgICAgdmFyIGlzRmluYWxJbWFnZSA9IChvbmxvYWRzQ2FsbGVkID09PSBudW1iZXJPZkltYWdlcyk7XG4gICAgICBpZiAoaXNGaW5hbEltYWdlKSB7XG4gICAgICAgIHRoZXJlV2FzU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIGlmIChzdHJpbmdHaXZlbikge1xuICAgICAgICAgIHRoZW4obnVsbCwgaW1nc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhlbihudWxsLCBpbWdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvbmVycm9yID0gZnVuY3Rpb24gKGVyck1zZykge1xuICAgIC8vIE5vdGU6XG4gICAgLy8gICB0aGlzID0gSW1hZ2VcblxuICAgIC8vIE5vIGVycm9ycyBhZnRlciBzdWNjZXNzLlxuICAgIGlmICghdGhlcmVXYXNTdWNjZXNzKSB7XG4gICAgICB0aGVyZVdhc0Vycm9yID0gdHJ1ZTtcbiAgICAgIHRoZW4oZXJyTXNnLCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IGZpcmluZyB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dsb2JhbEV2ZW50SGFuZGxlcnMub25lcnJvciNQYXJhbWV0ZXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZm9yIChpID0gMDsgaSA8IGltZ1NyY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpbWdzLnB1c2gobmV3IEltYWdlKCkpO1xuICAgIGltZ3NbaV0ub25sb2FkID0gb25sb2FkO1xuICAgIGltZ3NbaV0ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgaW1nc1tpXS5zcmMgPSBpbWdTcmNzW2ldO1xuICB9XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgRGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBxdWVyeSA9IHJlcXVpcmUoJ2NvbXBvbmVudC1xdWVyeScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXItdHJhbnNpdGlvbicpO1xudmFyIGhhczNkID0gcmVxdWlyZSgnaGFzLXRyYW5zbGF0ZTNkJyk7XG52YXIgZWFzZSA9IHJlcXVpcmUoJ2Nzcy1lYXNlJyk7XG5cbi8qKlxuICogQ1NTIFRyYW5zbGF0ZVxuICovXG5cbnZhciB0cmFuc2xhdGUgPSBoYXMzZFxuICA/IFsndHJhbnNsYXRlM2QoJywgJywgMCknXVxuICA6IFsndHJhbnNsYXRlKCcsICcpJ107XG5cbi8qKlxuICogRXhwb3J0IGBNb3ZlYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW92ZTtcblxuLyoqXG4gKiBHZXQgY29tcHV0ZWQgc3R5bGUuXG4gKi9cblxudmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgfHwgd2luZG93LmN1cnJlbnRTdHlsZTtcblxuLyoqXG4gKiBMaWJyYXJ5IHZlcnNpb24uXG4gKi9cblxuTW92ZS52ZXJzaW9uID0gJzAuNS4wJztcblxuLyoqXG4gKiBFeHBvcnQgYGVhc2VgXG4gKi9cblxuTW92ZS5lYXNlID0gZWFzZTtcblxuLyoqXG4gKiBEZWZhdWx0cy5cbiAqXG4gKiAgIGBkdXJhdGlvbmAgLSBkZWZhdWx0IGR1cmF0aW9uIG9mIDUwMG1zXG4gKlxuICovXG5cbk1vdmUuZGVmYXVsdHMgPSB7XG4gIGR1cmF0aW9uOiA1MDBcbn07XG5cbi8qKlxuICogRGVmYXVsdCBlbGVtZW50IHNlbGVjdGlvbiB1dGlsaXplZCBieSBgbW92ZShzZWxlY3RvcilgLlxuICpcbiAqIE92ZXJyaWRlIHRvIGltcGxlbWVudCB5b3VyIG93biBzZWxlY3Rpb24sIGZvciBleGFtcGxlXG4gKiB3aXRoIGpRdWVyeSBvbmUgbWlnaHQgd3JpdGU6XG4gKlxuICogICAgIG1vdmUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgICAgIHJldHVybiBqUXVlcnkoc2VsZWN0b3IpLmdldCgwKTtcbiAqICAgICB9O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHNlbGVjdG9yKSByZXR1cm4gc2VsZWN0b3I7XG4gIHJldHVybiBxdWVyeShzZWxlY3Rvcik7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1vdmVgIHdpdGggdGhlIGdpdmVuIGBlbGAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNb3ZlKGVsKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb3ZlKSkgcmV0dXJuIG5ldyBNb3ZlKGVsKTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBlbCkgZWwgPSBxdWVyeShlbCk7XG4gIGlmICghZWwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ01vdmUgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGVsZW1lbnQgb3Igc2VsZWN0b3InKTtcbiAgdGhpcy5lbCA9IGVsO1xuICB0aGlzLl9wcm9wcyA9IHt9O1xuICB0aGlzLl9yb3RhdGUgPSAwO1xuICB0aGlzLl90cmFuc2l0aW9uUHJvcHMgPSBbXTtcbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLmR1cmF0aW9uKE1vdmUuZGVmYXVsdHMuZHVyYXRpb24pXG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cbiAqL1xuXG5FbWl0dGVyKE1vdmUucHJvdG90eXBlKTtcblxuLyoqXG4gKiBCdWZmZXIgYHRyYW5zZm9ybWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0pe1xuICB0aGlzLl90cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNrZXcgYHhgIGFuZCBgeWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2tldyA9IGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXcoJ1xuICAgICsgeCArICdkZWcsICdcbiAgICArICh5IHx8IDApXG4gICAgKyAnZGVnKScpO1xufTtcblxuLyoqXG4gKiBTa2V3IHggYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2tld1ggPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdza2V3WCgnICsgbiArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNrZXcgeSBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3WSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXdZKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIGB4YCBhbmQgYHlgIGF4aXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUudHJhbnNsYXRlID1cbk1vdmUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSh0cmFuc2xhdGUuam9pbignJ1xuICAgICsgeCArJ3B4LCAnXG4gICAgKyAoeSB8fCAwKVxuICAgICsgJ3B4JykpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgb24gdGhlIHggYXhpcyB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGVYID1cbk1vdmUucHJvdG90eXBlLnggPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGVYKCcgKyBuICsgJ3B4KScpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgb24gdGhlIHkgYXhpcyB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGVZID1cbk1vdmUucHJvdG90eXBlLnkgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGVZKCcgKyBuICsgJ3B4KScpO1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgeCBhbmQgeSBheGlzIGJ5IGB4YCwgb3JcbiAqIGluZGl2aWR1YWxseSBzY2FsZSBgeGAgYW5kIGB5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlKCdcbiAgICArIHggKyAnLCAnXG4gICAgKyAoeSB8fCB4KVxuICAgICsgJyknKTtcbn07XG5cbi8qKlxuICogU2NhbGUgeCBheGlzIGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlWCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlWCgnICsgbiArICcpJylcbn07XG5cbi8qKlxuICogQXBwbHkgYSBtYXRyaXggdHJhbnNmb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIEEgbWF0cml4IGNvZWZmaWNpZW50XG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUubWF0cml4ID0gZnVuY3Rpb24obTExLCBtMTIsIG0yMSwgbTIyLCBtMzEsIG0zMil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnbWF0cml4KCcgKyBbbTExLG0xMixtMjEsbTIyLG0zMSxtMzJdLmpvaW4oJywnKSArICcpJyk7XG59O1xuXG4vKipcbiAqIFNjYWxlIHkgYXhpcyBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zY2FsZVkgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdzY2FsZVkoJyArIG4gKyAnKScpXG59O1xuXG4vKipcbiAqIFJvdGF0ZSBgbmAgZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3JvdGF0ZSgnICsgbiArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNldCB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvbiB0byB0byBgZm5gIHN0cmluZy5cbiAqXG4gKiBXaGVuOlxuICpcbiAqICAgLSBudWxsIFwiZWFzZVwiIGlzIHVzZWRcbiAqICAgLSBcImluXCIgXCJlYXNlLWluXCIgaXMgdXNlZFxuICogICAtIFwib3V0XCIgXCJlYXNlLW91dFwiIGlzIHVzZWRcbiAqICAgLSBcImluLW91dFwiIFwiZWFzZS1pbi1vdXRcIiBpcyB1c2VkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKGZuKXtcbiAgZm4gPSBlYXNlW2ZuXSB8fCBmbiB8fCAnZWFzZSc7XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIGZuKTtcbn07XG5cbi8qKlxuICogU2V0IGFuaW1hdGlvbiBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbihuYW1lLCBwcm9wcyl7XG4gIGZvciAodmFyIGkgaW4gcHJvcHMpe1xuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShpKSl7XG4gICAgICB0aGlzLnNldFZlbmRvclByb3BlcnR5KCdhbmltYXRpb24tJyArIGksIHByb3BzW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgnYW5pbWF0aW9uLW5hbWUnLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBTZXQgZHVyYXRpb24gdG8gYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24obil7XG4gIG4gPSB0aGlzLl9kdXJhdGlvbiA9ICdzdHJpbmcnID09IHR5cGVvZiBuXG4gICAgPyBwYXJzZUZsb2F0KG4pICogMTAwMFxuICAgIDogbjtcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCBuICsgJ21zJyk7XG59O1xuXG4vKipcbiAqIERlbGF5IHRoZSBhbmltYXRpb24gYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24obil7XG4gIG4gPSAnc3RyaW5nJyA9PSB0eXBlb2YgblxuICAgID8gcGFyc2VGbG9hdChuKSAqIDEwMDBcbiAgICA6IG47XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2l0aW9uLWRlbGF5JywgbiArICdtcycpO1xufTtcblxuLyoqXG4gKiBTZXQgYHByb3BgIHRvIGB2YWxgLCBkZWZlcnJlZCB1bnRpbCBgLmVuZCgpYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICB0aGlzLl9wcm9wc1twcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBhIHZlbmRvciBwcmVmaXhlZCBgcHJvcGAgd2l0aCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXRWZW5kb3JQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy13ZWJraXQtJyArIHByb3AsIHZhbCk7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy1tb3otJyArIHByb3AsIHZhbCk7XG4gIHRoaXMuc2V0UHJvcGVydHkoJy1tcy0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW8tJyArIHByb3AsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYHByb3BgIHRvIGB2YWx1ZWAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgdGhpcy50cmFuc2l0aW9uKHByb3ApO1xuICB0aGlzLl9wcm9wc1twcm9wXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluY3JlbWVudCBgcHJvcGAgYnkgYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgaWYgKCFzdHlsZSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1cnIgPSBwYXJzZUludChzZWxmLmN1cnJlbnQocHJvcCksIDEwKTtcbiAgICBzZWxmLnNldChwcm9wLCBjdXJyICsgdmFsICsgJ3B4Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWNyZW1lbnQgYHByb3BgIGJ5IGB2YWxgLCBkZWZlcnJlZCB1bnRpbCBgLmVuZCgpYCBpcyBpbnZva2VkXG4gKiBhbmQgYWRkcyB0aGUgcHJvcGVydHkgdG8gdGhlIGxpc3Qgb2YgdHJhbnNpdGlvbiBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIGlmICghc3R5bGUpIHJldHVybjtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gdGhpcy5vbignc3RhcnQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBjdXJyID0gcGFyc2VJbnQoc2VsZi5jdXJyZW50KHByb3ApLCAxMCk7XG4gICAgc2VsZi5zZXQocHJvcCwgY3VyciAtIHZhbCArICdweCcpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IGNvbXB1dGVkIG9yIFwiY3VycmVudFwiIHZhbHVlIG9mIGBwcm9wYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocHJvcCl7XG4gIHJldHVybiBzdHlsZSh0aGlzLmVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xufTtcblxuLyoqXG4gKiBBZGQgYHByb3BgIHRvIHRoZSBsaXN0IG9mIGludGVybmFsIHRyYW5zaXRpb24gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24ocHJvcCl7XG4gIGlmICghdGhpcy5fdHJhbnNpdGlvblByb3BzLmluZGV4T2YocHJvcCkpIHJldHVybiB0aGlzO1xuICB0aGlzLl90cmFuc2l0aW9uUHJvcHMucHVzaChwcm9wKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbW1pdCBzdHlsZSBwcm9wZXJ0aWVzLCBha2EgYXBwbHkgdGhlbSB0byBgZWwuc3R5bGVgLlxuICpcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQHNlZSBNb3ZlI2VuZCgpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5hcHBseVByb3BlcnRpZXMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBwcm9wIGluIHRoaXMuX3Byb3BzKSB7XG4gICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB0aGlzLl9wcm9wc1twcm9wXSwgJycpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZS1zZWxlY3QgZWxlbWVudCB2aWEgYHNlbGVjdG9yYCwgcmVwbGFjaW5nXG4gKiB0aGUgY3VycmVudCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLm1vdmUgPVxuTW92ZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICB0aGlzLmVsID0gTW92ZS5zZWxlY3Qoc2VsZWN0b3IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmZXIgdGhlIGdpdmVuIGBmbmAgdW50aWwgdGhlIGFuaW1hdGlvblxuICogaXMgY29tcGxldGUuIGBmbmAgbWF5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAgLSBhIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICAtIGFuIGluc3RhbmNlb2YgYE1vdmVgIHRvIGNhbGwgYC5lbmQoKWBcbiAqICAgLSBub3RoaW5nLCB0byByZXR1cm4gYSBjbG9uZSBvZiB0aGlzIGBNb3ZlYCBpbnN0YW5jZSBmb3IgY2hhaW5pbmdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE1vdmV9IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKGZuKXtcbiAgLy8gaW52b2tlIC5lbmQoKVxuICBpZiAoZm4gaW5zdGFuY2VvZiBNb3ZlKSB7XG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgIGZuLmVuZCgpO1xuICAgIH0pO1xuICAvLyBjYWxsYmFja1xuICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGZuKSB7XG4gICAgdGhpcy5vbignZW5kJywgZm4pO1xuICAvLyBjaGFpblxuICB9IGVsc2Uge1xuICAgIHZhciBjbG9uZSA9IG5ldyBNb3ZlKHRoaXMuZWwpO1xuICAgIGNsb25lLl90cmFuc2Zvcm1zID0gdGhpcy5fdHJhbnNmb3Jtcy5zbGljZSgwKTtcbiAgICB0aGlzLnRoZW4oY2xvbmUpO1xuICAgIGNsb25lLnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBvcCB0aGUgbW92ZSBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge01vdmV9IHBhcmVudCBNb3ZlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbi8qKlxuICogUmVzZXQgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TW92ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVsLnN0eWxlLndlYmtpdFRyYW5zaXRpb25EdXJhdGlvbiA9XG4gIHRoaXMuZWwuc3R5bGUubW96VHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5tc1RyYW5zaXRpb25EdXJhdGlvbiA9XG4gIHRoaXMuZWwuc3R5bGUub1RyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnQgYW5pbWF0aW9uLCBvcHRpb25hbGx5IGNhbGxpbmcgYGZuYCB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZW1pdCBcInN0YXJ0XCIgZXZlbnRcbiAgdGhpcy5lbWl0KCdzdGFydCcpO1xuXG4gIC8vIHRyYW5zZm9ybXNcbiAgaWYgKHRoaXMuX3RyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNmb3JtJywgdGhpcy5fdHJhbnNmb3Jtcy5qb2luKCcgJykpO1xuICB9XG5cbiAgLy8gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tcHJvcGVydGllcycsIHRoaXMuX3RyYW5zaXRpb25Qcm9wcy5qb2luKCcsICcpKTtcbiAgdGhpcy5hcHBseVByb3BlcnRpZXMoKTtcblxuICAvLyBjYWxsYmFjayBnaXZlblxuICBpZiAoZm4pIHRoaXMudGhlbihmbik7XG5cbiAgLy8gZW1pdCBcImVuZFwiIHdoZW4gY29tcGxldGVcbiAgYWZ0ZXIub25jZSh0aGlzLmVsLCBmdW5jdGlvbigpe1xuICAgIHNlbGYucmVzZXQoKTtcbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG4iLCJ2YXIgaGFzVHJhbnNpdGlvbnMgPSByZXF1aXJlKCdoYXMtdHJhbnNpdGlvbnMnKTtcbnZhciBlbWl0dGVyID0gcmVxdWlyZSgnY3NzLWVtaXR0ZXInKTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2l0aW9uKGVsLCBjYWxsYmFjaykge1xuICBpZihoYXNUcmFuc2l0aW9ucyhlbCkpIHtcbiAgICByZXR1cm4gZW1pdHRlcihlbCkuYmluZChjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGVsKTtcbn07XG5cbmFmdGVyVHJhbnNpdGlvbi5vbmNlID0gZnVuY3Rpb24oZWwsIGNhbGxiYWNrKSB7XG4gIGFmdGVyVHJhbnNpdGlvbihlbCwgZnVuY3Rpb24gZm4oKXtcbiAgICBjYWxsYmFjay5hcHBseShlbCk7XG4gICAgZW1pdHRlcihlbCkudW5iaW5kKGZuKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmdGVyVHJhbnNpdGlvbjsiLCIvKipcbiAqIE1vZHVsZSBEZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnQnKTtcblxuLy8gQ1NTIGV2ZW50c1xuXG52YXIgd2F0Y2ggPSBbXG4gICd0cmFuc2l0aW9uZW5kJ1xuLCAnd2Via2l0VHJhbnNpdGlvbkVuZCdcbiwgJ29UcmFuc2l0aW9uRW5kJ1xuLCAnTVNUcmFuc2l0aW9uRW5kJ1xuLCAnYW5pbWF0aW9uZW5kJ1xuLCAnd2Via2l0QW5pbWF0aW9uRW5kJ1xuLCAnb0FuaW1hdGlvbkVuZCdcbiwgJ01TQW5pbWF0aW9uRW5kJ1xuXTtcblxuLyoqXG4gKiBFeHBvc2UgYENTU25leHRgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDc3NFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYENzc0VtaXR0ZXJgXG4gKlxuICovXG5cbmZ1bmN0aW9uIENzc0VtaXR0ZXIoZWxlbWVudCl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDc3NFbWl0dGVyKSkgcmV0dXJuIG5ldyBDc3NFbWl0dGVyKGVsZW1lbnQpO1xuICB0aGlzLmVsID0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBCaW5kIENTUyBldmVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Dc3NFbWl0dGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZm4pe1xuICBmb3IgKHZhciBpPTA7IGkgPCB3YXRjaC5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50cy5iaW5kKHRoaXMuZWwsIHdhdGNoW2ldLCBmbik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVuYmluZCBDU1MgZXZlbnRzXG4gKiBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ3NzRW1pdHRlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZm4pe1xuICBmb3IgKHZhciBpPTA7IGkgPCB3YXRjaC5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50cy51bmJpbmQodGhpcy5lbCwgd2F0Y2hbaV0sIGZuKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmlyZSBjYWxsYmFjayBvbmx5IG9uY2VcbiAqIFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Dc3NFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIG9uKCl7XG4gICAgc2VsZi51bmJpbmQob24pO1xuICAgIGZuLmFwcGx5KHNlbGYuZWwsIGFyZ3VtZW50cyk7XG4gIH1cbiAgc2VsZi5iaW5kKG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4iLCJcbi8qKlxuICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICB9XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogVW5iaW5kIGBlbGAgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgaWYgKGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBjYXB0dXJlKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO1xuICB9XG4gIHJldHVybiBmbjtcbn07XG4iLCIvKipcbiAqIFRoaXMgd2lsbCBzdG9yZSB0aGUgcHJvcGVydHkgdGhhdCB0aGUgY3VycmVudFxuICogYnJvd3NlciB1c2VzIGZvciB0cmFuc2l0aW9uRHVyYXRpb25cbiAqL1xudmFyIHByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBwcm9wZXJ0aWVzIHdlJ2xsIGNoZWNrIG9uIGFuIGVsZW1lbnRcbiAqIHRvIGRldGVybWluZSBpZiBpdCBhY3R1YWxseSBoYXMgdHJhbnNpdGlvbnNcbiAqIFdlIHVzZSBkdXJhdGlvbiBhcyB0aGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5XG4gKiBuZWVkZWQgdG8gdGVjaG5pY2FsbHkgaGF2ZSB0cmFuc2l0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICovXG52YXIgdHlwZXMgPSBbXG4gIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gIFwiTW96VHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gIFwid2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXCJcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHByb3BlcnR5IGZvciB0aGlzIGJyb3dzZXJcbiAqIGp1c3Qgb25jZSBzbyB3ZSBkb25lIG5lZWQgdG8gY2hlY2sgZXZlcnkgdGltZVxuICovXG53aGlsZSh0eXBlcy5sZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlcy5zaGlmdCgpO1xuICBpZih0eXBlIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcbiAgICBwcm9wZXJ0eSA9IHR5cGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHJhbnNpdGlvbnMgb3JcbiAqIGlmIGFuIGVsZW1lbnQgaGFzIHRyYW5zaXRpb25zIGF0IGFsbC5cbiAqIEBwYXJhbSAge0VsZW1lbnR9ICBlbCBPcHRpb25hbC4gUmV0dXJucyBicm93c2VyIHN1cHBvcnQgaWYgbm90IGluY2x1ZGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNUcmFuc2l0aW9ucyhlbCl7XG4gIGlmKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gTm8gYnJvd3NlciBzdXBwb3J0IGZvciB0cmFuc2l0aW9uc1xuICB9XG4gIGlmKCFlbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eSAhPSBudWxsOyAvLyBXZSBqdXN0IHdhbnQgdG8ga25vdyBpZiBicm93c2VycyBzdXBwb3J0IGl0XG4gIH1cbiAgdmFyIGR1cmF0aW9uID0gZ2V0Q29tcHV0ZWRTdHlsZShlbClbcHJvcGVydHldO1xuICByZXR1cm4gZHVyYXRpb24gIT09IFwiXCIgJiYgcGFyc2VGbG9hdChkdXJhdGlvbikgIT09IDA7IC8vIERvZXMgdGhpcyBlbGVtZW50IGhhdmUgdHJhbnNpdGlvbnM/XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVHJhbnNpdGlvbnM7IiwiZnVuY3Rpb24gb25lKHNlbGVjdG9yLCBlbCkge1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlbCl7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG4gIHJldHVybiBvbmUoc2VsZWN0b3IsIGVsKTtcbn07XG5cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufTtcblxuZXhwb3J0cy5lbmdpbmUgPSBmdW5jdGlvbihvYmope1xuICBpZiAoIW9iai5vbmUpIHRocm93IG5ldyBFcnJvcignLm9uZSBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBpZiAoIW9iai5hbGwpIHRocm93IG5ldyBFcnJvcignLmFsbCBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBvbmUgPSBvYmoub25lO1xuICBleHBvcnRzLmFsbCA9IG9iai5hbGw7XG4gIHJldHVybiBleHBvcnRzO1xufTtcbiIsIlxuLyoqXG4gKiBDU1MgRWFzaW5nIGZ1bmN0aW9uc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdpbic6ICAgICAgICAgICAgICAgICdlYXNlLWluJ1xuICAsICdvdXQnOiAgICAgICAgICAgICAgICdlYXNlLW91dCdcbiAgLCAnaW4tb3V0JzogICAgICAgICAgICAnZWFzZS1pbi1vdXQnXG4gICwgJ3NuYXAnOiAgICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLDEsLjUsMSknXG4gICwgJ2xpbmVhcic6ICAgICAgICAgICAgJ2N1YmljLWJlemllcigwLjI1MCwgMC4yNTAsIDAuNzUwLCAwLjc1MCknXG4gICwgJ2Vhc2UtaW4tcXVhZCc6ICAgICAgJ2N1YmljLWJlemllcigwLjU1MCwgMC4wODUsIDAuNjgwLCAwLjUzMCknXG4gICwgJ2Vhc2UtaW4tY3ViaWMnOiAgICAgJ2N1YmljLWJlemllcigwLjU1MCwgMC4wNTUsIDAuNjc1LCAwLjE5MCknXG4gICwgJ2Vhc2UtaW4tcXVhcnQnOiAgICAgJ2N1YmljLWJlemllcigwLjg5NSwgMC4wMzAsIDAuNjg1LCAwLjIyMCknXG4gICwgJ2Vhc2UtaW4tcXVpbnQnOiAgICAgJ2N1YmljLWJlemllcigwLjc1NSwgMC4wNTAsIDAuODU1LCAwLjA2MCknXG4gICwgJ2Vhc2UtaW4tc2luZSc6ICAgICAgJ2N1YmljLWJlemllcigwLjQ3MCwgMC4wMDAsIDAuNzQ1LCAwLjcxNSknXG4gICwgJ2Vhc2UtaW4tZXhwbyc6ICAgICAgJ2N1YmljLWJlemllcigwLjk1MCwgMC4wNTAsIDAuNzk1LCAwLjAzNSknXG4gICwgJ2Vhc2UtaW4tY2lyYyc6ICAgICAgJ2N1YmljLWJlemllcigwLjYwMCwgMC4wNDAsIDAuOTgwLCAwLjMzNSknXG4gICwgJ2Vhc2UtaW4tYmFjayc6ICAgICAgJ2N1YmljLWJlemllcigwLjYwMCwgLTAuMjgwLCAwLjczNSwgMC4wNDUpJ1xuICAsICdlYXNlLW91dC1xdWFkJzogICAgICdjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApJ1xuICAsICdlYXNlLW91dC1jdWJpYyc6ICAgICdjdWJpYy1iZXppZXIoMC4yMTUsIDAuNjEwLCAwLjM1NSwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1xdWFydCc6ICAgICdjdWJpYy1iZXppZXIoMC4xNjUsIDAuODQwLCAwLjQ0MCwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1xdWludCc6ICAgICdjdWJpYy1iZXppZXIoMC4yMzAsIDEuMDAwLCAwLjMyMCwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1zaW5lJzogICAgICdjdWJpYy1iZXppZXIoMC4zOTAsIDAuNTc1LCAwLjU2NSwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1leHBvJzogICAgICdjdWJpYy1iZXppZXIoMC4xOTAsIDEuMDAwLCAwLjIyMCwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1jaXJjJzogICAgICdjdWJpYy1iZXppZXIoMC4wNzUsIDAuODIwLCAwLjE2NSwgMS4wMDApJ1xuICAsICdlYXNlLW91dC1iYWNrJzogICAgICdjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyMCwgMS4yNzUpJ1xuICAsICdlYXNlLW91dC1xdWFkJzogICAgICdjdWJpYy1iZXppZXIoMC40NTUsIDAuMDMwLCAwLjUxNSwgMC45NTUpJ1xuICAsICdlYXNlLW91dC1jdWJpYyc6ICAgICdjdWJpYy1iZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1xdWFydCc6ICdjdWJpYy1iZXppZXIoMC43NzAsIDAuMDAwLCAwLjE3NSwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1xdWludCc6ICdjdWJpYy1iZXppZXIoMC44NjAsIDAuMDAwLCAwLjA3MCwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1zaW5lJzogICdjdWJpYy1iZXppZXIoMC40NDUsIDAuMDUwLCAwLjU1MCwgMC45NTApJ1xuICAsICdlYXNlLWluLW91dC1leHBvJzogICdjdWJpYy1iZXppZXIoMS4wMDAsIDAuMDAwLCAwLjAwMCwgMS4wMDApJ1xuICAsICdlYXNlLWluLW91dC1jaXJjJzogICdjdWJpYy1iZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1MCwgMC44NjApJ1xuICAsICdlYXNlLWluLW91dC1iYWNrJzogICdjdWJpYy1iZXppZXIoMC42ODAsIC0wLjU1MCwgMC4yNjUsIDEuNTUwKSdcbn07XG4iLCJcbnZhciBwcm9wID0gcmVxdWlyZSgndHJhbnNmb3JtLXByb3BlcnR5Jyk7XG5cbi8vIElFIDw9OCBkb2Vzbid0IGhhdmUgYGdldENvbXB1dGVkU3R5bGVgXG5pZiAoIXByb3AgfHwgIXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbn0gZWxzZSB7XG4gIHZhciBtYXAgPSB7XG4gICAgd2Via2l0VHJhbnNmb3JtOiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICAgIE9UcmFuc2Zvcm06ICctby10cmFuc2Zvcm0nLFxuICAgIG1zVHJhbnNmb3JtOiAnLW1zLXRyYW5zZm9ybScsXG4gICAgTW96VHJhbnNmb3JtOiAnLW1vei10cmFuc2Zvcm0nLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zZm9ybSdcbiAgfTtcblxuICAvLyBmcm9tOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9sb3JlbnpvcG9saWRvcmkvMzc5NDIyNlxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuc3R5bGVbcHJvcF0gPSAndHJhbnNsYXRlM2QoMXB4LDFweCwxcHgpJztcbiAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZWwsIG51bGwpO1xuICB2YXIgdmFsID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShtYXBbcHJvcF0pO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBudWxsICE9IHZhbCAmJiB2YWwubGVuZ3RoICYmICdub25lJyAhPSB2YWw7XG59XG4iLCJcbnZhciBzdHlsZXMgPSBbXG4gICd3ZWJraXRUcmFuc2Zvcm0nLFxuICAnTW96VHJhbnNmb3JtJyxcbiAgJ21zVHJhbnNmb3JtJyxcbiAgJ09UcmFuc2Zvcm0nLFxuICAndHJhbnNmb3JtJ1xuXTtcblxudmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xudmFyIHN0eWxlO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgaWYgKG51bGwgIT0gZWwuc3R5bGVbc3R5bGVdKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzdHlsZTtcbiAgICBicmVhaztcbiAgfVxufVxuIiwiLypcblxuKi9cbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvVHJhbnNmb3JtJyk7XG5leHBvcnRzLmVzdGltYXRlVCA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlVCcpO1xuZXhwb3J0cy5lc3RpbWF0ZVMgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVMnKTtcbmV4cG9ydHMuZXN0aW1hdGVSID0gcmVxdWlyZSgnLi9saWIvZXN0aW1hdGVSJyk7XG5leHBvcnRzLmVzdGltYXRlVFMgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVRTJyk7XG5leHBvcnRzLmVzdGltYXRlVFIgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVRSJyk7XG5leHBvcnRzLmVzdGltYXRlU1IgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVNSJyk7XG5leHBvcnRzLmVzdGltYXRlVFNSID0gcmVxdWlyZSgnLi9saWIvZXN0aW1hdGVUU1InKTtcbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4vbGliL3ZlcnNpb24nKTtcblxuZXhwb3J0cy5lc3RpbWF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBkb21haW4sIHJhbmdlLCBwaXZvdCkge1xuICAvLyBQYXJhbWV0ZXJcbiAgLy8gICB0eXBlXG4gIC8vICAgICBzdHJpbmcuIE9uZSBvZiB0aGUgZm9sbG93aW5nOiAnVCcsICdTJywgJ1InLCAnVFMnLCAnVFInLCAnU1InLCAnVFNSJ1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgMmQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIDJkIGFycmF5c1xuICAvLyAgIHBpdm90XG4gIC8vICAgICBvcHRpb25hbCAyZCBhcnJheSwgZG9lcyBub3RoaW5nIGZvciB0cmFuc2xhdGlvbiBlc3RpbWF0b3JzXG4gIHZhciBuYW1lID0gJ2VzdGltYXRlJyArIHR5cGUudG9VcHBlckNhc2UoKTtcbiAgaWYgKGV4cG9ydHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICByZXR1cm4gZXhwb3J0c1tuYW1lXShkb21haW4sIHJhbmdlLCBwaXZvdCk7XG4gIH0gLy8gZWxzZVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXN0aW1hdG9yIHR5cGU6ICcgKyB0eXBlKTtcbn07XG4iLCJcbnZhciBUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocywgciwgdHgsIHR5KSB7XG5cbiAgLy8gUHVibGljLCB0byBhbGxvdyB1c2VyIGFjY2Vzc1xuICB0aGlzLnMgPSBzO1xuICB0aGlzLnIgPSByO1xuICB0aGlzLnR4ID0gdHg7XG4gIHRoaXMudHkgPSB0eTtcblxuICB0aGlzLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIChzID09PSB0LnMgJiYgciA9PT0gdC5yICYmIHR4ID09PSB0LnR4ICYmIHR5ID09PSB0LnR5KTtcbiAgfTtcblxuICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgLy8gcFxuICAgIC8vICAgcG9pbnQgW3gsIHldIG9yIGFycmF5IG9mIHBvaW50cyBbW3gxLHkxXSwgW3gyLCB5Ml0sIC4uLl1cblxuICAgIGlmICh0eXBlb2YgcFswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbmdsZSBwb2ludFxuICAgICAgcmV0dXJuIFtzICogcFswXSAtIHIgKiBwWzFdICsgdHgsIHIgKiBwWzBdICsgcyAqIHBbMV0gKyB0eV07XG4gICAgfSAvLyBlbHNlXG5cbiAgICB2YXIgaSwgYyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjLnB1c2goW3MgKiBwW2ldWzBdIC0gciAqIHBbaV1bMV0gKyB0eCwgciAqIHBbaV1bMF0gKyBzICogcFtpXVsxXSArIHR5XSk7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9O1xuXG4gIHRoaXMuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEdldCB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGluIHRoZSBmb3JtYXQgY29tbW9uIHRvXG4gICAgLy8gbWFueSBBUElzLCBpbmNsdWRpbmc6XG4gICAgLy8gLSBrbGQtYWZmaW5lXG4gICAgLy9cbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIG9iamVjdCBvLCBoYXZpbmcgcHJvcGVydGllcyBhLCBiLCBjLCBkLCBlLCBmOlxuICAgIC8vICAgWyBzICAtciAgdHggXSAgIFsgby5hICBvLmMgIG8uZSBdXG4gICAgLy8gICBbIHIgICBzICB0eSBdID0gWyBvLmIgIG8uZCAgby5mIF1cbiAgICAvLyAgIFsgMCAgIDAgICAxIF0gICBbICAtICAgIC0gICAgLSAgXVxuICAgIHJldHVybiB7IGE6IHMsIGI6IHIsIGM6IC1yLCBkOiBzLCBlOiB0eCwgZjogdHkgfTtcbiAgfTtcblxuICB0aGlzLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGluIHJhZHNcbiAgICByZXR1cm4gTWF0aC5hdGFuMihyLCBzKTtcbiAgfTtcblxuICB0aGlzLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNjYWxlIG11bHRpcGxpZXJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHIgKiByICsgcyAqIHMpO1xuICB9O1xuXG4gIHRoaXMuZ2V0VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt0eCwgdHldO1xuICB9O1xuXG4gIHRoaXMuaW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gaW52ZXJzZWQgdHJhbnNmb3JtIGluc3RhbmNlXG4gICAgLy8gU2VlIG5vdGUgMjAxNS0xMC0yNi0xNi0zMFxuICAgIHZhciBkZXQgPSBzICogcyArIHIgKiByO1xuICAgIC8vIFRlc3QgaWYgc2luZ3VsYXIgdHJhbnNmb3JtYXRpb24uIFRoZXNlIG1pZ2h0IG9jY3VyIHdoZW4gYWxsIHRoZSByYW5nZVxuICAgIC8vIHBvaW50cyBhcmUgdGhlIHNhbWUsIGZvcmNpbmcgdGhlIHNjYWxlIHRvIGRyb3AgdG8gemVyby5cbiAgICB2YXIgZXBzID0gMC4wMDAwMDAwMTtcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IGVwcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaW5ndWxhciB0cmFuc2Zvcm1hdGlvbnMgY2Fubm90IGJlIGludmVyc2VkLicpO1xuICAgIH1cbiAgICB2YXIgc2hhdCA9IHMgLyBkZXQ7XG4gICAgdmFyIHJoYXQgPSAtciAvIGRldDtcbiAgICB2YXIgdHhoYXQgPSAoLXMgKiB0eCAtIHIgKiB0eSkgLyBkZXQ7XG4gICAgdmFyIHR5aGF0ID0gKCByICogdHggLSBzICogdHkpIC8gZGV0O1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdCk7XG4gIH07XG5cbiAgdGhpcy50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShzLCByLCB0eCArIGR4LCB0eSArIGR5KTtcbiAgfTtcblxuICB0aGlzLnNjYWxlQnkgPSBmdW5jdGlvbiAobXVsdGlwbGllciwgcGl2b3QpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIG11bHRpcGxpZXJcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICAgIG9wdGlvbmFsLCBhIFt4LCB5XSBwb2ludFxuICAgIHZhciBtLCB4LCB5O1xuICAgIG0gPSBtdWx0aXBsaWVyOyAvLyBhbGlhc1xuICAgIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBwaXZvdFswXTtcbiAgICAgIHkgPSBwaXZvdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0obSAqIHMsIG0gKiByLCBtICogdHggKyAoMS1tKSAqIHgsIG0gKiB0eSArICgxLW0pICogeSk7XG4gIH07XG5cbiAgdGhpcy5yb3RhdGVCeSA9IGZ1bmN0aW9uIChyYWRpYW5zLCBwaXZvdCkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgcmFkaWFuc1xuICAgIC8vICAgICBmcm9tIHBvc2l0aXZlIHggdG8gcG9zaXRpdmUgeSBheGlzXG4gICAgLy8gICBwaXZvdFxuICAgIC8vICAgICBvcHRpb25hbCwgYSBbeCwgeV0gcG9pbnRcbiAgICB2YXIgY28sIHNpLCB4LCB5LCBzaGF0LCByaGF0LCB0eGhhdCwgdHloYXQ7XG4gICAgY28gPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICBzaSA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBwaXZvdFswXTtcbiAgICAgIHkgPSBwaXZvdFsxXTtcbiAgICB9XG4gICAgc2hhdCA9IHMgKiBjbyAtIHIgKiBzaTtcbiAgICByaGF0ID0gcyAqIHNpICsgciAqIGNvO1xuICAgIHR4aGF0ID0gKHR4IC0geCkgKiBjbyAtICh0eSAtIHkpICogc2kgKyB4O1xuICAgIHR5aGF0ID0gKHR4IC0geCkgKiBzaSArICh0eSAtIHkpICogY28gKyB5O1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdCk7XG4gIH07XG5cblxuICB0aGlzLm11bHRpcGx5QnkgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG4gICAgLy8gTXVsdGlwbHkgdGhpcyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggQVxuICAgIC8vIGZyb20gdGhlIHJpZ2h0IHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBCXG4gICAgLy8gYW5kIHJldHVybiB0aGUgcmVzdWx0IEFCXG5cbiAgICAvLyBGb3IgcmVhZGluZyBhaWQ6XG4gICAgLy8gcyAtciB0eCAgdC5zIC1yIHR4XG4gICAgLy8gciAgcyB0eSAqICByICBzIHR5XG4gICAgLy8gMCAgMCAgMSAgICAwICAwICAxXG4gICAgdmFyIHQgPSB0cmFuc2Zvcm07IC8vIGFsaWFzXG4gICAgdmFyIHNoYXQgPSBzICogdC5zIC0gciAqIHQucjtcbiAgICB2YXIgcmhhdCA9IHMgKiB0LnIgKyByICogdC5zO1xuICAgIHZhciB0eGhhdCA9IHMgKiB0LnR4IC0gciAqIHQudHkgKyB0eDtcbiAgICB2YXIgdHloYXQgPSByICogdC50eCArIHMgKiB0LnR5ICsgdHk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbiAgfTtcbn07XG5cblRyYW5zZm9ybS5JREVOVElUWSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCwgMCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UsIHBpdm90KSB7XG4gIHZhciBpLCBOLCBELCBhMCwgYjAsIGEsIGIsIGMsIGQsIGFjLCBhZCwgYmMsIGJkLCBzaGF0LCByaGF0LCB0eCwgdHk7XG5cbiAgTiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCk7XG4gIGFjID0gYWQgPSBiYyA9IGJkID0gMDtcblxuICBpZiAodHlwZW9mIHBpdm90ID09PSAndW5kZWZpbmVkJykge1xuICAgIGEwID0gYjAgPSAwO1xuICB9IGVsc2Uge1xuICAgIGEwID0gcGl2b3RbMF07XG4gICAgYjAgPSBwaXZvdFsxXTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gZG9tYWluW2ldWzBdIC0gYTA7XG4gICAgYiA9IGRvbWFpbltpXVsxXSAtIGIwO1xuICAgIGMgPSByYW5nZVtpXVswXSAtIGEwO1xuICAgIGQgPSByYW5nZVtpXVsxXSAtIGIwO1xuICAgIGFjICs9IGEgKiBjO1xuICAgIGFkICs9IGEgKiBkO1xuICAgIGJjICs9IGIgKiBjO1xuICAgIGJkICs9IGIgKiBkO1xuICB9XG5cbiAgcCA9IGFjICsgYmQ7XG4gIHEgPSBhZCAtIGJjO1xuXG4gIEQgPSBNYXRoLnNxcnQocCAqIHAgKyBxICogcSk7XG5cbiAgaWYgKEQgPT09IDApIHtcbiAgICAvLyBEID09PSAwXG4gICAgLy8gPD0+IHEgPT09IDAgYW5kIHAgPT09IDAuXG4gICAgLy8gPD0+IGFkID09PSBiYyBhbmQgYWMgPT09IC1iZFxuICAgIC8vIDw9PiBkb21haW4gaW4gcGl2b3QgT1IgcmFuZ2UgaW4gcGl2b3QgT1IgeWV0IHVua25vd24gY2FzZXNcbiAgICAvLyAgICAgd2hlcmUgdGhlIGFuZ2xlIGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICAgIC8vIEQgPT09IDAgYWxzbyBpZiBOID09PSAwLlxuICAgIC8vIEFzc3VtZSBpZGVudGl0eSB0cmFuc2Zvcm0gdG8gYmUgdGhlIGJlc3QgZ3Vlc3NcbiAgICByZXR1cm4gVHJhbnNmb3JtLklERU5USVRZO1xuICB9XG5cbiAgc2hhdCA9IHAgLyBEO1xuICByaGF0ID0gcSAvIEQ7XG4gIHR4ID0gYTAgLSBhMCAqIHNoYXQgKyBiMCAqIHJoYXQ7XG4gIHR5ID0gYjAgLSBhMCAqIHJoYXQgLSBiMCAqIHNoYXQ7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHgsIHR5KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgdmFyIGksIE4sIEQsIGEwLCBiMCwgYSwgYiwgYywgZCwgYWMsIGJkLCBhYSwgYmIsIHNoYXQsIHR4LCB0eTtcblxuICBOID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKTtcbiAgYWMgPSBiZCA9IGFhID0gYmIgPSAwO1xuXG4gIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYTAgPSBiMCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYTAgPSBwaXZvdFswXTtcbiAgICBiMCA9IHBpdm90WzFdO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBkb21haW5baV1bMF0gLSBhMDtcbiAgICBiID0gZG9tYWluW2ldWzFdIC0gYjA7XG4gICAgYyA9IHJhbmdlW2ldWzBdIC0gYTA7XG4gICAgZCA9IHJhbmdlW2ldWzFdIC0gYjA7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gICAgYWEgKz0gYSAqIGE7XG4gICAgYmIgKz0gYiAqIGI7XG4gIH1cblxuICBEID0gYWEgKyBiYjtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIEFsbCBkb21haW4gcG9pbnRzIGVxdWFsIHRoZSBwaXZvdC5cbiAgICAvLyBJZGVudGl0eSB0cmFuc2Zvcm0gaXMgdGhlbiBvbmx5IHNvbHV0aW9uLlxuICAgIC8vIEQgPT09IDAgYWxzbyBpZiBOID09PSAwLlxuICAgIC8vIEFzc3VtZSBpZGVudGl0eSB0cmFuc2Zvcm0gdG8gYmUgdGhlIGJlc3QgZ3Vlc3NcbiAgICByZXR1cm4gVHJhbnNmb3JtLklERU5USVRZO1xuICB9XG5cbiAgLy8gUHJldmVudCBuZWdhdGl2ZSBzY2FsaW5nIGJlY2F1c2UgaXQgd291bGQgYmUgc2FtZSBhcyBwb3NpdGl2ZSBzY2FsaW5nXG4gIC8vIGFuZCByb3RhdGlvbiA9PiBsaW1pdCB0byB6ZXJvXG4gIHNoYXQgPSBNYXRoLm1heCgwLCAoYWMgKyBiZCkgLyBEKTtcbiAgdHggPSAoMSAtIHNoYXQpICogYTA7XG4gIHR5ID0gKDEgLSBzaGF0KSAqIGIwO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIDAsIHR4LCB0eSk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UsIHBpdm90KSB7XG4gIC8vIEVzdGltYXRlIG9wdGltYWwgdHJhbnNmb3JtYXRpb24gZ2l2ZW4gdGhlIGRvbWFpbiBhbmQgdGhlIHJhbmdlXG4gIC8vIHNvIHRoYXQgdGhlIHBpdm90IHBvaW50IHJlbWFpbnMgdGhlIHNhbWUuXG4gIC8vXG4gIC8vIFVzZSBjYXNlc1xuICAvLyAgIC0gdHJhbnNmb3JtIGFuIGltYWdlIHRoYXQgaGFzIG9uZSBjb3JuZXIgZml4ZWQgd2l0aCBhIHBpbi5cbiAgLy8gICAtIGFsbG93IG9ubHkgc2NhbGUgYW5kIHJvdGF0aW9uIGJ5IGZpeGluZyB0aGUgbWlkZGxlIG9mIHRoZSBvYmplY3RcbiAgLy8gICAgIHRvIHRyYW5zZm9ybS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpbiwgYW4gYXJyYXkgb2YgW3gsIHldIHBvaW50c1xuICAvLyAgIHJhbmdlLCBhbiBhcnJheSBvZiBbeCwgeV0gcG9pbnRzXG4gIC8vICAgcGl2b3QsIG9wdGlvbmFsXG4gIC8vICAgICB0aGUgcG9pbnQgW3gsIHldIHRoYXQgbXVzdCByZW1haW4gY29uc3RhbnQgaW4gdGhlIHRyYW5mb3JtYXRpb24uXG4gIC8vICAgICBEZWZhdWx0cyB0byBvcmlnbyBbMCwgMF1cbiAgLy9cbiAgLy9cbiAgdmFyIFgsIFksIE4sIHMsIHIsIHR4LCB0eTtcblxuICAvLyBPcHRpb25hbCBwaXZvdFxuICBpZiAodHlwZW9mIHBpdm90ID09PSAndW5kZWZpbmVkJykge1xuICAgIHBpdm90ID0gWzAsIDBdO1xuICB9XG5cbiAgLy8gQWxpYXNcbiAgWCA9IGRvbWFpbjtcbiAgWSA9IHJhbmdlO1xuXG4gIC8vIEFsbG93IGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3RoIGJ1dFxuICAvLyBpZ25vcmUgdGhlIGV4dHJhIHBvaW50cy5cbiAgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgdmFyIHYgPSBwaXZvdFswXTtcbiAgdmFyIHcgPSBwaXZvdFsxXTtcblxuICB2YXIgaSwgYSwgYiwgYywgZDtcbiAgdmFyIGEyLCBiMjtcbiAgYTIgPSBiMiA9IDA7XG4gIHZhciBhYywgYmQsIGJjLCBhZDtcbiAgYWMgPSBiZCA9IGJjID0gYWQgPSAwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gWFtpXVswXSAtIHY7XG4gICAgYiA9IFhbaV1bMV0gLSB3O1xuICAgIGMgPSBZW2ldWzBdIC0gdjtcbiAgICBkID0gWVtpXVsxXSAtIHc7XG4gICAgYTIgKz0gYSAqIGE7XG4gICAgYjIgKz0gYiAqIGI7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYWQgKz0gYSAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvciA9IGRldGVybWluYW50LlxuICAvLyBJdCBiZWNvbWVzIHplcm8gaWZmIE4gPSAwIG9yIFhbaV0gPSBbdiwgd10gZm9yIGV2ZXJ5IGkgaW4gWzAsIG4pLlxuICAvLyBJbiBvdGhlciB3b3JkcywgaWZmIGFsbCB0aGUgZG9tYWluIHBvaW50cyBhcmUgdW5kZXIgdGhlIGZpeGVkIHBvaW50IG9yXG4gIC8vIHRoZXJlIGlzIG5vIGRvbWFpbiBwb2ludHMuXG4gIHZhciBkZW4gPSBhMiArIGIyO1xuXG4gIHZhciBlcHMgPSAwLjAwMDAwMDAxO1xuICBpZiAoTWF0aC5hYnMoZGVuKSA8IGVwcykge1xuICAgIC8vIFRoZSBkb21haW4gcG9pbnRzIGFyZSB1bmRlciB0aGUgcGl2b3Qgb3IgdGhlcmUgaXMgbm8gZG9tYWluIHBvaW50cy5cbiAgICAvLyBXZSBhc3N1bWUgaWRlbnRpdHkgdHJhbnNmb3JtIGJlIHRoZSBzaW1wbGVzdCBndWVzcy4gSXQga2VlcHNcbiAgICAvLyB0aGUgZG9tYWluIHBvaW50cyB1bmRlciB0aGUgcGl2b3QgaWYgdGhlcmUgaXMgc29tZS5cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcbiAgfVxuXG4gIC8vIEVzdGltYXRvcnNcbiAgcyA9IChhYyArIGJkKSAvIGRlbjtcbiAgciA9ICgtYmMgKyBhZCkgLyBkZW47XG4gIHR4ID0gIHcgKiByIC0gdiAqIHMgKyB2O1xuICB0eSA9IC12ICogciAtIHcgKiBzICsgdztcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybShzLCByLCB0eCwgdHkpO1xufTtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gIHZhciBpLCBOLCBhMSwgYjEsIGMxLCBkMSwgdHhoYXQsIHR5aGF0O1xuXG4gIE4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICBhMSA9IGIxID0gYzEgPSBkMSA9IDA7XG5cbiAgaWYgKE4gPCAxKSB7XG4gICAgLy8gQXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybSBiZSB0aGUgYmVzdCBndWVzc1xuICAgIHJldHVybiBUcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSAxKSB7XG4gICAgYTEgKz0gZG9tYWluW2ldWzBdO1xuICAgIGIxICs9IGRvbWFpbltpXVsxXTtcbiAgICBjMSArPSByYW5nZVtpXVswXTtcbiAgICBkMSArPSByYW5nZVtpXVsxXTtcbiAgfVxuXG4gIHR4aGF0ID0gKGMxIC0gYTEpIC8gTjtcbiAgdHloYXQgPSAoZDEgLSBiMSkgLyBOO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIHR4aGF0LCB0eWhhdCk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgW3gsIHldIDJEIGFycmF5c1xuICAvLyAgIHJhbmdlXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG5cbiAgLy8gQWxpYXNcbiAgdmFyIFggPSBkb21haW47XG4gIHZhciBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICB2YXIgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgdmFyIGksIGEsIGIsIGMsIGQsIGExLCBiMSwgYzEsIGQxLCBhYywgYWQsIGJjLCBiZDtcbiAgYTEgPSBiMSA9IGMxID0gZDEgPSBhYyA9IGFkID0gYmMgPSBiZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gWFtpXVswXTtcbiAgICBiID0gWFtpXVsxXTtcbiAgICBjID0gWVtpXVswXTtcbiAgICBkID0gWVtpXVsxXTtcbiAgICBhMSArPSBhO1xuICAgIGIxICs9IGI7XG4gICAgYzEgKz0gYztcbiAgICBkMSArPSBkO1xuICAgIGFjICs9IGEgKiBjO1xuICAgIGFkICs9IGEgKiBkO1xuICAgIGJjICs9IGIgKiBjO1xuICAgIGJkICs9IGIgKiBkO1xuICB9XG5cbiAgLy8gRGVub21pbmF0b3IuXG4gIHZhciB2ID0gTiAqIChhZCAtIGJjKSAtIGExICogZDEgKyBiMSAqIGMxO1xuICB2YXIgdyA9IE4gKiAoYWMgKyBiZCkgLSBhMSAqIGMxIC0gYjEgKiBkMTtcbiAgdmFyIEQgPSBNYXRoLnNxcnQodiAqIHYgKyB3ICogdyk7XG5cbiAgaWYgKEQgPT09IDApIHtcbiAgICAvLyBOID09PSAwID0+IEQgPT09IDBcbiAgICBpZiAoTiA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCwgMCk7XG4gICAgfSAvLyBlbHNlXG4gICAgLy8gRCA9PT0gMCA8PT4gdW5kZWNpZGFibGVcbiAgICAvLyBXZSBndWVzcyB0aGUgdHJhbnNsYXRpb24gdG8gdGhlIG1lYW4gb2YgdGhlIHJhbmdlIHRvIGJlIHRoZSBiZXN0IGd1ZXNzLlxuICAgIC8vIEhlcmUgYSwgYiByZXByZXNlbnRzIHRoZSBtZWFuIG9mIGRvbWFpbiBwb2ludHMuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgKGMxIC0gYTEpIC8gTiwgKGQxIC0gYjEpIC8gTik7XG4gIH1cblxuICAvLyBFc3RpbWF0b3JzXG4gIHZhciBzaGF0ID0gdyAvIEQ7XG4gIHZhciByaGF0ID0gdiAvIEQ7XG4gIHZhciB0eGhhdCA9ICgtYTEgKiBzaGF0ICsgYjEgKiByaGF0ICsgYzEpIC8gTjtcbiAgdmFyIHR5aGF0ID0gKC1hMSAqIHJoYXQgLSBiMSAqIHNoYXQgKyBkMSkgLyBOO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdCk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgW3gsIHldIDJEIGFycmF5c1xuICAvLyAgIHJhbmdlXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG5cbiAgLy8gQWxpYXNcbiAgdmFyIFggPSBkb21haW47XG4gIHZhciBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICB2YXIgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgdmFyIGksIGEsIGIsIGMsIGQsIGExLCBiMSwgYzEsIGQxLCBhMiwgYjIsIGFjLCBiZDtcbiAgYTEgPSBiMSA9IGMxID0gZDEgPSBhMiA9IGIyID0gYWMgPSBiZCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhID0gWFtpXVswXTtcbiAgICBiID0gWFtpXVsxXTtcbiAgICBjID0gWVtpXVswXTtcbiAgICBkID0gWVtpXVsxXTtcbiAgICBhMSArPSBhO1xuICAgIGIxICs9IGI7XG4gICAgYzEgKz0gYztcbiAgICBkMSArPSBkO1xuICAgIGEyICs9IGEgKiBhO1xuICAgIGIyICs9IGIgKiBiO1xuICAgIGFjICs9IGEgKiBjO1xuICAgIGJkICs9IGIgKiBkO1xuICB9XG5cbiAgLy8gRGVub21pbmF0b3IuXG4gIHZhciBOMiA9IE4gKiBOO1xuICB2YXIgYTEyID0gYTEgKiBhMTtcbiAgdmFyIGIxMiA9IGIxICogYjE7XG4gIHZhciBwID0gYTIgKyBiMjtcbiAgdmFyIHEgPSBhYyArIGJkO1xuICB2YXIgRCA9IE4yICogcCAtIE4gKiAoYTEyICsgYjEyKTtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIE4gPT09IDAgPT4gRCA9PT0gMFxuICAgIGlmIChOID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcbiAgICB9IC8vIGVsc2VcbiAgICAvLyBEID09PSAwIDw9PiBhbGwgdGhlIGRvbWFpbiBwb2ludHMgYXJlIHRoZSBzYW1lXG4gICAgLy8gV2UgZ3Vlc3MgdGhlIHRyYW5zbGF0aW9uIHRvIHRoZSBtZWFuIG9mIHRoZSByYW5nZSB0byBiZSB0aGUgYmVzdCBndWVzcy5cbiAgICAvLyBIZXJlIGEsIGIgcmVwcmVzZW50cyB0aGUgbWVhbiBvZiBkb21haW4gcG9pbnRzLlxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIChjMSAvIE4pIC0gYSwgKGQxIC8gTikgLSBiKTtcbiAgfVxuXG4gIC8vIEVzdGltYXRvcnNcbiAgdmFyIHNoYXQgPSAoTjIgKiBxIC0gTiAqIChhMSAqIGMxICsgYjEgKiBkMSkpIC8gRDtcbiAgdmFyIHR4aGF0ID0gKC1OICogYTEgKiBxICsgTiAqIGMxICogcCAtIGIxMiAqIGMxICsgYTEgKiBiMSAqIGQxKSAvIEQ7XG4gIHZhciB0eWhhdCA9ICgtTiAqIGIxICogcSArIE4gKiBkMSAqIHAgLSBhMTIgKiBkMSArIGExICogYjEgKiBjMSkgLyBEO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHNoYXQsIDAsIHR4aGF0LCB0eWhhdCk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGRvbWFpblxuICAvLyAgICAgYXJyYXkgb2YgW3gsIHldIDJEIGFycmF5c1xuICAvLyAgIHJhbmdlXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIHZhciBYLCBZLCBOLCBzLCByLCB0eCwgdHk7XG5cbiAgLy8gQWxpYXNcbiAgWCA9IGRvbWFpbjtcbiAgWSA9IHJhbmdlO1xuXG4gIC8vIEFsbG93IGFycmF5cyBvZiBkaWZmZXJlbnQgbGVuZ3RoIGJ1dFxuICAvLyBpZ25vcmUgdGhlIGV4dHJhIHBvaW50cy5cbiAgTiA9IE1hdGgubWluKFgubGVuZ3RoLCBZLmxlbmd0aCk7XG5cbiAgLy8gSWYgbGVuZ3RoIGlzIHplcm8sIG5vIGVzdGltYXRpb24gY2FuIGJlIGRvbmUuIFdlIGNob29zZSB0aGUgaW5kZW50aXR5XG4gIC8vIHRyYW5zZm9ybWF0aW9uIGJlIHRoZSBiZXN0IHF1ZXNzLlxuICBpZiAoTiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIDAsIDApO1xuICB9IC8vIGVsc2VcblxuICB2YXIgaSwgYSwgYiwgYywgZDtcbiAgdmFyIGExID0gMDtcbiAgdmFyIGIxID0gMDtcbiAgdmFyIGMxID0gMDtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGEyID0gMDtcbiAgdmFyIGIyID0gMDtcbiAgdmFyIGFkID0gMDtcbiAgdmFyIGJjID0gMDtcbiAgdmFyIGFjID0gMDtcbiAgdmFyIGJkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdO1xuICAgIGIgPSBYW2ldWzFdO1xuICAgIGMgPSBZW2ldWzBdO1xuICAgIGQgPSBZW2ldWzFdO1xuICAgIGExICs9IGE7XG4gICAgYjEgKz0gYjtcbiAgICBjMSArPSBjO1xuICAgIGQxICs9IGQ7XG4gICAgYTIgKz0gYSAqIGE7XG4gICAgYjIgKz0gYiAqIGI7XG4gICAgYWQgKz0gYSAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvci5cbiAgLy8gSXQgaXMgemVybyBpZmYgWFtpXSA9IFhbal0gZm9yIGV2ZXJ5IGkgYW5kIGogaW4gWzAsIG4pLlxuICAvLyBJbiBvdGhlciB3b3JkcywgaWZmIGFsbCB0aGUgZG9tYWluIHBvaW50cyBhcmUgdGhlIHNhbWUgb3IgdGhlcmUgaXMgb25seSBvbmUgZG9tYWluIHBvaW50LlxuICB2YXIgZGVuID0gTiAqIGEyICsgTiAqIGIyIC0gYTEgKiBhMSAtIGIxICogYjE7XG5cbiAgdmFyIGVwcyA9IDAuMDAwMDAwMDE7XG4gIGlmICgtZXBzIDwgZGVuICYmIGRlbiA8IGVwcykge1xuICAgIC8vIFRoZSBkb21haW4gcG9pbnRzIGFyZSB0aGUgc2FtZS5cbiAgICAvLyBXZSBndWVzcyB0aGUgdHJhbnNsYXRpb24gdG8gdGhlIG1lYW4gb2YgdGhlIHJhbmdlIHRvIGJlIHRoZSBiZXN0IGd1ZXNzLlxuICAgIC8vIEhlcmUgYSwgYiByZXByZXNlbnRzIHRoZSBtZWFuIG9mIGRvbWFpbiBwb2ludHMuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgKGMxIC8gTikgLSBhLCAoZDEgLyBOKSAtIGIpO1xuICB9XG5cbiAgLy8gRXN0aW1hdG9yc1xuICBzID0gKE4gKiAoYWMgKyBiZCkgLSBhMSAqIGMxIC0gYjEgKiBkMSkgLyBkZW47XG4gIHIgPSAoTiAqIChhZCAtIGJjKSArIGIxICogYzEgLSBhMSAqIGQxKSAvIGRlbjtcbiAgdHggPSAoLWExICogKGFjICsgYmQpICsgYjEgKiAoYWQgLSBiYykgKyBhMiAqIGMxICsgYjIgKiBjMSkgLyBkZW47XG4gIHR5ID0gKC1iMSAqIChhYyArIGJkKSAtIGExICogKGFkIC0gYmMpICsgYTIgKiBkMSArIGIyICogZDEpIC8gZGVuO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHMsIHIsIHR4LCB0eSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMS4wLjEnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VxSWRcblxuZnVuY3Rpb24gU2VxSWQoaW5pdGlhbCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VxSWQpKSB7XG4gICAgcmV0dXJuIG5ldyBTZXFJZChpbml0aWFsKVxuICB9XG4gIGlmIChpbml0aWFsID09IG51bGwpIHtcbiAgICBpbml0aWFsID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogTWF0aC5wb3coMiwgMzIpXG4gIH1cbiAgdGhpcy5faWQgPSBpbml0aWFsIHwgMFxufVxuU2VxSWQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2lkID0gKHRoaXMuX2lkICsgMSkgfCAwXG4gIHJldHVybiB0aGlzLl9pZFxufVxuIiwiLypcbkFQSSB2MC40LjBcblZpZXdcbiovXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VDb250YWluZXIgPSByZXF1aXJlKCcuL1NwYWNlQ29udGFpbmVyJyk7XG52YXIgU3BhY2VQbGFuZSA9IHJlcXVpcmUoJy4vU3BhY2VQbGFuZScpO1xudmFyIFRyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1lcicpO1xudmFyIFNwYWNlUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9TcGFjZVJlY3RhbmdsZScpO1xudmFyIFNwYWNlVGFhID0gcmVxdWlyZSgnLi9TcGFjZVRhYScpO1xudmFyIG1vdmUgPSByZXF1aXJlKCdtb3ZlanMnKTtcblxuLy8gRGlzYWJsZSBhbmltYXRpb25zIGJ5IGRlZmF1bHQuXG5tb3ZlLmRlZmF1bHRzID0geyBkdXJhdGlvbjogMCB9O1xuXG52YXIgSFRNTFNwYWNlVmlldyA9IGZ1bmN0aW9uIChzcGFjZSwgaHRtbENvbnRhaW5lcikge1xuICAvLyBUZXN0IGlmIHZhbGlkIGRvbSBlbGVtZW50XG4gIGlmICghKCd0YWdOYW1lJyBpbiBodG1sQ29udGFpbmVyKSkge1xuICAgIHRocm93ICdDb250YWluZXIgc2hvdWxkIGJlIGEgRE9NIEVsZW1lbnQnO1xuICB9XG5cbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VDb250YWluZXIodGhpcyk7XG4gIFNwYWNlUGxhbmUodGhpcyk7XG4gIFRyYW5zZm9ybWVyKHRoaXMpO1xuICBTcGFjZVJlY3RhbmdsZSh0aGlzKTtcbiAgdmFyIHRoaXMyID0gdGhpcztcblxuICB0aGlzLl9lbCA9IGh0bWxDb250YWluZXI7XG5cbiAgLy8gVHdvIG1hcHBpbmdzIGZyb20gc3BhY2UgdGFhIGlkczpcbiAgLy8gMS4gdG8gSFRNTCBlbGVtZW50cyBvZiB0aGUgc3BhY2UgdGFhcy5cbiAgLy8gMi4gdG8gU3BhY2VUYWEgaW5zdGFuY2VzXG4gIC8vIERldiBkZWNpc2lvbjpcbiAgLy8gICBGb3IgZGF0YSBzdHJ1Y3R1cmUsIGRpY3Qgb3ZlciBsaXN0IGJlY2F1c2Uga2V5IHNlYXJjaCB0aW1lIGNvbXBsZXhpdHkuXG4gIHRoaXMuX2VsZW1lbnRzID0ge307XG4gIHRoaXMuX3NwYWNldGFhcyA9IHt9O1xuXG4gIChmdW5jdGlvbiBpbml0U2l6ZSgpIHtcbiAgICB2YXIgdyA9IHRoaXMyLl9lbC5jbGllbnRXaWR0aDtcbiAgICB2YXIgaCA9IHRoaXMyLl9lbC5jbGllbnRIZWlnaHQ7XG4gICAgdGhpczIucmVzaXplKFt3LCBoXSk7XG4gIH0oKSk7XG5cbiAgdmFyIHRyYW5zZm9ybUltYWdlID0gZnVuY3Rpb24gKGltZywgc3BhY2V0YWEpIHtcbiAgICAvLyBUcmFuc2Zvcm0gaW1hZ2VzIGJlY2F1c2UgdGhlIHZpZXcgb3JpZW50YXRpb24uXG4gICAgLy8gU2VlIDIwMTYtMDMtMDUtMDkuXG4gICAgdmFyIHNwYWNldGFhX2dsb2JhbF9UID0gc3BhY2V0YWEuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gICAgdmFyIFQgPSB0aGlzMi5fVC5pbnZlcnNlKCkubXVsdGlwbHlCeShzcGFjZXRhYV9nbG9iYWxfVCk7XG4gICAgLy8gVE9ETyBXaGF0IGlmIHZpZXcgcGFyZW50IGlzIG5vdCB0aGUgcm9vdD9cbiAgICAvLyAgIFNvbHV0aW9uOiBnZXRUcmFuc2Zvcm1UbyhwbGFuZSlcbiAgICAvLyBUT0RPIEN1cnJlbnQgbW92ZS5qcyBkb2VzIG5vdCBwcmV2ZW50IHNjaWVudGlmaWMgbm90YXRpb24gcmVhY2hpbmcgQ1NTXG4gICAgLy8gd2hpY2ggbGVhZHMgdG8gcHJvYmxlbXMgd2l0aCBTYWZhcmkgYW5kIE9wZXJhLiBUaGVyZWZvcmUgd2UgbXVzdFxuICAgIC8vIHByZXZlbnQgdGhlIG5vdGF0aW9uIGhlcmUuXG4gICAgLy8gT2YgY291cnNlIHRoaXMgd2lsbCBjYXVzZSBlcnJvciBpbiB0aGUgcHJlc2VudGF0aW9uLlxuICAgIC8vIEhvd2V2ZXIgdGhlIGVycm9yIGlzIG9ubHkgaW4gdGhlIHByZXNlbnRhdGlvbiBhbmQgdGh1cyBub3QgYSBwcm9ibGVtLlxuICAgIHZhciBwcmVjID0gODtcbiAgICB2YXIgcyA9IFQucy50b0ZpeGVkKHByZWMpO1xuICAgIHZhciByID0gVC5yLnRvRml4ZWQocHJlYyk7XG4gICAgdmFyIHR4ID0gVC50eC50b0ZpeGVkKHByZWMpO1xuICAgIHZhciB0eSA9IFQudHkudG9GaXhlZChwcmVjKTtcbiAgICBtb3ZlKGltZykubWF0cml4KHMsIHIsLXIsIHMsIHR4LCB0eSkuZW5kKCk7XG4gIH07XG5cbiAgLy8gTGlzdGVuIHRoZSBzcGFjZSBmb3IgbmV3IG9yIHJlbW92ZWQgdGFhcyBvciB0cmFuc2Zvcm1hdGlvbnNcblxuICB2YXIgY29udGVudEFkZGVkSGFuZGxlciA9IGZ1bmN0aW9uIChzcGFjZWNvbnRhaW5lciwgbmV3UGFyZW50LCBvbGRQYXJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9sZFBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgb2xkUGFyZW50ID0gbnVsbDsgfVxuICAgIGlmICh0eXBlb2YgbmV3UGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBuZXdQYXJlbnQgPSBudWxsOyB9XG5cbiAgICAvLyBTcGFjZVZpZXcsIFNwYWNlVGFhIC4uLlxuICAgIHZhciBjb24gPSBzcGFjZWNvbnRhaW5lcjtcblxuICAgIGlmICh0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkoY29uLmlkKSkge1xuICAgICAgLy8gQ29udGVudCBpcyBhbHJlYWR5IGRyYXduLlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29uIGluc3RhbmNlb2YgU3BhY2VUYWEpIHtcbiAgICAgICAgdmFyIHRhYSA9IGNvbi50YWE7XG4gICAgICAgIHZhciBlbCA9IG5ldyBJbWFnZSgyNTYsIDI1Nik7XG4gICAgICAgIGVsLnNyYyA9IHRhYS5pbWFnZS5zcmM7XG4gICAgICAgIGVsLmlkID0gdGhpczIuaWQgKyAnLycgKyBjb24uaWQ7IC8vIFZpZXctc3BlY2lmaWMgdW5pcXVlIGVsZW0gaWRcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gJ3RhYXNwYWNlLXRhYSc7XG4gICAgICAgIC8vIFNob3cgdG8gY2xpZW50XG4gICAgICAgIHRoaXMyLl9lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIC8vIE1ha2UgcmVmZXJlbmNhYmxlXG4gICAgICAgIHRoaXMyLl9lbGVtZW50c1tjb24uaWRdID0gZWw7XG4gICAgICAgIHRoaXMyLl9zcGFjZXRhYXNbY29uLmlkXSA9IGNvbjtcbiAgICAgICAgLy8gTWFrZSB0cmFuc2Zvcm1hdGlvblxuICAgICAgICB0cmFuc2Zvcm1JbWFnZShlbCwgY29uKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uIGluc3RhbmNlb2YgSFRNTFNwYWNlVmlldykge1xuICAgICAgICAvLyBObyByZXByZXNlbnRhdGlvbiBmb3Igdmlld3MuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHNwYWNlIGNvbnRlbnQ7IGNhbm5vdCByZXByZXNlbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbnRlbnRSZW1vdmVkSGFuZGxlciA9IGZ1bmN0aW9uIChzcGFjZWNvbnRlbnQsIG9sZFBhcmVudCwgbmV3UGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbGRQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG9sZFBhcmVudCA9IG51bGw7IH1cbiAgICBpZiAodHlwZW9mIG5ld1BhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgbmV3UGFyZW50ID0gbnVsbDsgfVxuXG4gICAgdmFyIHNhbWVSb290LCBlbCwgY29uO1xuXG4gICAgY29uID0gc3BhY2Vjb250ZW50OyAvLyBBbGlhc1xuXG4gICAgLy8gRGVjaWRlIHNhbWVSb290XG4gICAgaWYgKG9sZFBhcmVudCA9PT0gbnVsbCB8fCBuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHNhbWVSb290ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbWVSb290ID0gb2xkUGFyZW50LmdldFJvb3RQYXJlbnQoKSA9PT0gbmV3UGFyZW50LmdldFJvb3RQYXJlbnQoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtZVJvb3QpIHtcbiAgICAgIC8vIE5vIHJlYXNvbiB0byByZW1vdmUgYW5kIHRoZW4gYWRkIGFnYWluLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgcGFyZW50IGluIGRpZmZlcmVudCBzcGFjZSwgc28gbm90IGRpc3BsYXllZCBpbiB0aGlzIHZpZXcgYW55bW9yZS5cbiAgICAgIGlmICh0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkoY29uLmlkKSkge1xuICAgICAgICAvLyBSZW1vdmUgSFRNTCBlbGVtZW50XG4gICAgICAgIGVsID0gdGhpczIuX2VsZW1lbnRzW2Nvbi5pZF07XG4gICAgICAgIHRoaXMyLl9lbC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIG1lbW9yeS5cbiAgICAgICAgLy8gSlMgZmVhdHVyZTogZG9lcyBub3QgdGhyb3cgaWYgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgZGVsZXRlIHRoaXMyLl9lbGVtZW50c1tjb24uaWRdO1xuICAgICAgICBkZWxldGUgdGhpczIuX3NwYWNldGFhc1tjb24uaWRdO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIHZhciBjb250ZW50VHJhbnNmb3JtZWRIYW5kbGVyID0gZnVuY3Rpb24gKHNwYWNlY29udGVudCkge1xuICAgIC8vIFVwZGF0ZSBjc3MgdHJhbnNmb3JtYXRpb24uXG4gICAgLy8gSWYgYSBjb250YWluZXIgaGFzIGNoaWxkcmVuLCB0aGV5IG11c3QgYWxzbyBiZSB0cmFuc2Zvcm1lZC5cbiAgICB2YXIgY29ucywgaSwgY29uLCBlbDtcbiAgICBjb25zID0gc3BhY2Vjb250ZW50LmdldEFsbENoaWxkcmVuKCk7XG4gICAgY29ucy5wdXNoKHNwYWNlY29udGVudCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uID0gY29uc1tpXTtcbiAgICAgIGlmICh0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkoY29uLmlkKSkge1xuICAgICAgICBpZiAoY29uIGluc3RhbmNlb2YgU3BhY2VUYWEpIHtcbiAgICAgICAgICBlbCA9IHRoaXMyLl9lbGVtZW50c1tjb24uaWRdO1xuICAgICAgICAgIC8vIE1ha2UgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICB0cmFuc2Zvcm1JbWFnZShlbCwgY29uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlOiBubyB0cmFuc2Zvcm1hYmxlIHJlcHJlc2VudGF0aW9uIGZvciBWaWV3cy5cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVmlldyBhZGRlZCB0byBuZXcgcGFyZW50LlxuICB0aGlzLm9uKCdhZGRlZCcsIGZ1bmN0aW9uIChzZWxmLCBuZXdQYXJlbnQpIHtcbiAgICAvLyBUT0RPIGFkZCBjb250ZW50IG9mIHRoZSBuZXcgc3BhY2UuXG4gICAgbmV3UGFyZW50Lm9uKCdjb250ZW50QWRkZWQnLCBjb250ZW50QWRkZWRIYW5kbGVyKTtcbiAgICBuZXdQYXJlbnQub24oJ2NvbnRlbnRSZW1vdmVkJywgY29udGVudFJlbW92ZWRIYW5kbGVyKTtcbiAgICBuZXdQYXJlbnQub24oJ2NvbnRlbnRUcmFuc2Zvcm1lZCcsIGNvbnRlbnRUcmFuc2Zvcm1lZEhhbmRsZXIpO1xuICB9KTtcbiAgLy8gVmlldyByZW1vdmVkIGZyb20gcGFyZW50LlxuICB0aGlzLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24gKHNlbGYsIG9sZFBhcmVudCkge1xuICAgIC8vIFRPRE8gcmVtb3ZlIGNvbnRlbnQgb2YgdGhlIG9sZCBzcGFjZS5cbiAgICBvbGRQYXJlbnQub2ZmKCdjb250ZW50QWRkZWQnLCBjb250ZW50QWRkZWRIYW5kbGVyKTtcbiAgICBvbGRQYXJlbnQub2ZmKCdjb250ZW50UmVtb3ZlZCcsIGNvbnRlbnRSZW1vdmVkSGFuZGxlcik7XG4gICAgb2xkUGFyZW50Lm9mZignY29udGVudFRyYW5zZm9ybWVkJywgY29udGVudFRyYW5zZm9ybWVkSGFuZGxlcik7XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2aWV3IGlzIHRyYW5zZm9ybWVkLCB3ZSBvZiBjb3Vyc2UgbmVlZCB0byByZXRyYW5zZm9ybSBldmVyeXRoaW5nLlxuICB0aGlzLm9uKCd0cmFuc2Zvcm1lZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWQsIGVsZW1lbnQsIHNwYWNldGFhO1xuICAgIGZvciAoaWQgaW4gdGhpczIuX2VsZW1lbnRzKSB7XG4gICAgICBpZiAodGhpczIuX2VsZW1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlbGVtZW50ICA9IHRoaXMyLl9lbGVtZW50c1tpZF07XG4gICAgICAgIHNwYWNldGFhID0gdGhpczIuX3NwYWNldGFhc1tpZF07XG4gICAgICAgIHRyYW5zZm9ybUltYWdlKGVsZW1lbnQsIHNwYWNldGFhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuZ2V0RWxlbWVudEJ5U3BhY2VUYWEgPSBmdW5jdGlvbiAoc3BhY2VUYWEpIHtcbiAgICAvLyBHZXQgSFRNTCBlbGVtZW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGFjZSB0YWEuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnRzLmhhc093blByb3BlcnR5KHNwYWNlVGFhLmlkKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzW3NwYWNlVGFhLmlkXTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5nZXRTcGFjZVRhYUJ5RWxlbWVudElkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gR2V0IHNwYWNlIHRhYSBieSBIVE1MIGVsZW1lbnQgaWRcbiAgICAvLyBSZXR1cm4gbnVsbCBpZiBubyBzcGFjZSB0YWEgZm9yIHN1Y2ggaWQuXG4gICAgdmFyIGkgPSBpZC5zcGxpdCgnLycpO1xuICAgIHZhciBzcGFjZVZpZXdJZCA9IGlbMF07XG4gICAgdmFyIHNwYWNlVGFhSWQgPSBpWzFdO1xuICAgIGlmICh0aGlzLmlkID09PSBzcGFjZVZpZXdJZCkge1xuICAgICAgaWYgKHRoaXMuX3NwYWNldGFhcy5oYXNPd25Qcm9wZXJ0eShzcGFjZVRhYUlkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BhY2V0YWFzW3NwYWNlVGFhSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfTtcblxuICAvLyBWaWV3IHJlYWR5IHRvIGJlIGFkZGVkIHRvIFNwYWNlLlxuICB0aGlzLnNldFBhcmVudChzcGFjZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxTcGFjZVZpZXc7XG4iLCIvKlxuRW1pdHNcbiAgY29udGVudEFkZGVkXG4gIGNvbnRlbnRSZW1vdmVkXG4gICAgbm90IHRocm93biBpZiB0aGUgY29udGVudCB0byByZW1vdmUgZGlkIG5vdCBleGlzdCBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gIGNvbnRlbnRUcmFuc2Zvcm1lZFxuKi9cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBTcGFjZVBsYW5lID0gcmVxdWlyZSgnLi9TcGFjZVBsYW5lJyk7XG52YXIgU3BhY2VDb250YWluZXIgPSByZXF1aXJlKCcuL1NwYWNlQ29udGFpbmVyJyk7XG5cbnZhciBTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgRW1pdHRlcih0aGlzKTtcblxuICBTcGFjZUNvbnRhaW5lcih0aGlzKTtcbiAgLy8gVE9ETyByZW1vdmUgcG9zc2liaWxpdHkgdG8gYWRkIHRvIHBhcmVudC5cblxuICBTcGFjZVBsYW5lKHRoaXMpO1xuICAvLyBTcGFjZSBoYXMgY29uc3RhbnQgaWRlbnRpdHkgdHJhbnNmb3JtYXRpb24gX1Rcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2U7XG4iLCIvKlxuRW1pdHNcbiAgY29udGVudEFkZGVkXG4gIGNvbnRlbnRSZW1vdmVkXG4gICAgbm90IHRocm93biBpZiB0aGUgY29udGVudCB0byByZW1vdmUgZGlkIG5vdCBleGlzdCBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gIGNvbnRlbnRUcmFuc2Zvcm1lZFxuKi9cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLy8gVW5pcXVlIElEIGdlbmVyYXRvci4gVW5pcXVlIG92ZXIgc2Vzc2lvbi5cbi8vIFVzYWdlOiBzZXFpZC5uZXh0KClcbi8vIFJldHVybjogaW50XG52YXIgc2VxaWQgPSByZXF1aXJlKCdzZXFpZCcpKDApO1xuXG52YXIgU3BhY2VDb250YWluZXIgPSBmdW5jdGlvbiAoZW1pdHRlcikge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZW1pdHRlciwgYW4gRW1pdHRlci5cblxuICAvLyBFYWNoIGNvbnRhaW5lciBoYXMgYW4gaWQuIFRoYXQgaXMgdXNlZCBieSB0aGUgcGFyZW50IGNvbnRhaW5lcnMuXG4gIGVtaXR0ZXIuaWQgPSBzZXFpZC5uZXh0KCkudG9TdHJpbmcoKTtcblxuICAvLyBDb250YWluZXJzIHdpdGggbnVsbCBwYXJlbnQgYXJlIHJvb3QgY29udGFpbmVycyBpLmUuIHNwYWNlcy5cbiAgLy8gU3BhY2VDb250YWluZXIjcmVtb3ZlIHNldHMgX3BhcmVudCB0byBudWxsLlxuICBlbWl0dGVyLl9wYXJlbnQgPSBudWxsO1xuXG4gIC8vIERpY3Qgb3ZlciBsaXN0IGJlY2F1c2Uga2V5IHNlYXJjaCB0aW1lIGNvbXBsZXhpdHlcbiAgZW1pdHRlci5fY29udGVudCA9IHt9O1xuXG4gIC8vIFdlIG5lZWQgdG8gc3RvcmUgYnVpbHQgaGFuZGxlcnMgYm91bmQgdG8gY2hpbGRyZW5cbiAgLy8gdG8gYmUgYWJsZSB0byByZW1vdmUgdGhlIGhhbmRsZXJzIHdoZW4gY2hpbGQgaXMgcmVtb3ZlZC5cbiAgZW1pdHRlci5fYWRkZWRIYW5kbGVycyA9IHt9O1xuICBlbWl0dGVyLl9yZW1vdmVkSGFuZGxlcnMgPSB7fTtcbiAgZW1pdHRlci5fdHJhbnNmb3JtZWRIYW5kbGVycyA9IHt9O1xuXG4gIGVtaXR0ZXIuaGFzID0gZnVuY3Rpb24gKHNwYWNlY29udGFpbmVyKSB7XG4gICAgLy8gUmV0dXJuXG4gICAgLy8gICB0cnVlIGlmIHNwYWNldGFhIGluIHNwYWNlXG4gICAgcmV0dXJuIHNwYWNlY29udGFpbmVyLl9wYXJlbnQgPT09IHRoaXM7XG4gIH07XG5cbiAgZW1pdHRlci5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfTtcblxuICBlbWl0dGVyLmdldFJvb3RQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudC5nZXRSb290UGFyZW50KCk7XG4gIH07XG5cbiAgZW1pdHRlci5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJbW1lZGlhdGUgY2hpbGQgU3BhY2VDb250YWluZXJzIGluIGEgbGlzdC5cbiAgICB2YXIgaWQsIGFyciwgb2JqO1xuICAgIGFyciA9IFtdO1xuICAgIG9iaiA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgZm9yIChpZCBpbiBvYmopIHtcbiAgICAgIGFyci5wdXNoKG9ialtpZF0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuXG4gIGVtaXR0ZXIuZ2V0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRGVzY2VuZGFudHMgaW4gYSBsaXN0LlxuICAgIHZhciBpLCBjaGlsZHJlbiwgY2hpbGQsIGFycjtcbiAgICBhcnIgPSBbXTtcbiAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBhcnIgPSBhcnIuY29uY2F0KGNoaWxkLCBjaGlsZC5nZXRBbGxDaGlsZHJlbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBlbWl0dGVyLnNldFBhcmVudCA9IGZ1bmN0aW9uIChuZXdQYXJlbnQpIHtcbiAgICAvLyBBZGQgdG8gbmV3IHBhcmVudCBjb250YWluZXIuXG5cbiAgICB2YXIgb2xkUGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXG4gICAgaWYgKG9sZFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5ld1BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBGcm9tIHJvb3QgdG8gcm9vdC5cbiAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRnJvbSByb290IHRvIGNoaWxkLlxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgIHRoaXMuX3BhcmVudC5fYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdCgnYWRkZWQnLCB0aGlzLCB0aGlzLl9wYXJlbnQsIG51bGwpO1xuICAgICAgICBuZXdQYXJlbnQuZW1pdCgnY29udGVudEFkZGVkJywgdGhpcywgdGhpcy5fcGFyZW50LCBudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5ld1BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBGcm9tIGNoaWxkIHRvIHJvb3QuXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7IC8vIEJlY29tZXMgbmV3IHJvb3QgY29udGFpbmVyLlxuICAgICAgICBvbGRQYXJlbnQuX3JlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG51bGwpO1xuICAgICAgICBvbGRQYXJlbnQuZW1pdCgnY29udGVudFJlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRnJvbSBjaGlsZCB0byBjaGlsZC5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICBvbGRQYXJlbnQuX3JlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBuZXdQYXJlbnQuX2FkZENoaWxkKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG5ld1BhcmVudCk7XG4gICAgICAgIHRoaXMuZW1pdCgnYWRkZWQnLCB0aGlzLCBuZXdQYXJlbnQsIG9sZFBhcmVudCk7XG4gICAgICAgIC8vIFdpdGggYm90aCBvbGRQYXJlbnQgYW5kIG5ld1BhcmVudCwgU3BhY2VWaWV3IGlzIGFibGUgdG9cbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgdG8ga2VlcCBzYW1lIEhUTUxFbGVtZW50IG9yIHJlY3JlYXRlIGl0LlxuICAgICAgICBvbGRQYXJlbnQuZW1pdCgnY29udGVudFJlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG5ld1BhcmVudCk7XG4gICAgICAgIG5ld1BhcmVudC5lbWl0KCdjb250ZW50QWRkZWQnLCB0aGlzLCBuZXdQYXJlbnQsIG9sZFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgZW1pdHRlci5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVtb3ZlIHRoaXMgc3BhY2UgY29udGFpbmVyIGZyb20gcGFyZW50IGNvbnRhaW5lci5cbiAgICAvLyBSZXR1cm46IHNlZSBzZXRQYXJlbnRcbiAgICByZXR1cm4gdGhpcy5zZXRQYXJlbnQobnVsbCk7XG4gIH07XG5cbiAgZW1pdHRlci5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBUbyBiZSBjYWxsZWQgZnJvbSBjaGlsZC5zZXRQYXJlbnQoKS5cbiAgICAvL1xuICAgIC8vIFBhcmFtZXRlcnNcbiAgICAvLyAgIGNoaWxkLCBBIFNwYWNlQ29udGFpbmVyXG4gICAgLy9cbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIHVuZGVmaW5lZFxuICAgIC8vXG4gICAgLy8gRGV2LiBub3RlOlxuICAgIC8vICAgUHJldmlvdXNseSB0aGlzIHdhcyBjYWxsZWQgZnJvbSB0aGUgU3BhY2VDb250YWluZXIgY29uc3RydWN0b3IuXG4gICAgLy8gICBIb3dldmVyLCBiZWNhdXNlIFNwYWNlQ29udGFpbmVyIHVwZ3JhZGUgaXMgZG9uZSBiZWZvcmUgb3RoZXJcbiAgICAvLyAgIHVwZ3JhZGVzLCB0aGUgY2hpbGQgd291bGQgbm90IGJlIHJlYWR5IHRvIGJlIGFkZGVkIHRvIHBhcmVudC5cbiAgICAvLyAgIFRoZXJlZm9yZVxuXG4gICAgdmFyIHNjID0gY2hpbGQ7IC8vIGFsaWFzXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fY29udGVudFtzYy5pZF0gPSBzYztcblxuICAgIC8vIFN0YXJ0IHRvIGxpc3RlbiBpZiBjaGlsZCBoYXMgYmVlZCBhZGRlZCwgcmVtb3ZlZCBvciB0cmFuc2Zvcm1lZFxuICAgIHZhciBhZGRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgc2VsZi5lbWl0KCdjb250ZW50QWRkZWQnLCBhLCBiLCBjKTtcbiAgICB9O1xuICAgIHZhciByZW1vdmVkSGFuZGxlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICBzZWxmLmVtaXQoJ2NvbnRlbnRSZW1vdmVkJywgYSwgYiwgYyk7XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtZWRIYW5kbGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHNlbGYuZW1pdCgnY29udGVudFRyYW5zZm9ybWVkJywgYSwgYiwgYyk7XG4gICAgfTtcbiAgICAvLyBhZGRlZCBhbmQgcmVtb3ZlZCBldmVudHMgYXJlIG5vdCBsaXN0ZW5lZCBiZWNhdXNlXG4gICAgLy8gZm9yIGFmdGVyIHN1Y2Nlc3NmdWxseSBtYWRlIGFkZCBvciByZW1vdmUsXG4gICAgLy8gY29udGVudEFkZGVkIGFuZCBjb250ZW50UmVtb3ZlZCBhcmUgZmlyZWQgaW4gc2V0UGFyZW50LlxuICAgIHNjLm9uKCdjb250ZW50QWRkZWQnLCBhZGRlZEhhbmRsZXIpO1xuICAgIHNjLm9uKCdjb250ZW50UmVtb3ZlZCcsIHJlbW92ZWRIYW5kbGVyKTtcbiAgICBzYy5vbigndHJhbnNmb3JtZWQnLCB0cmFuc2Zvcm1lZEhhbmRsZXIpO1xuICAgIHNjLm9uKCdjb250ZW50VHJhbnNmb3JtZWQnLCB0cmFuc2Zvcm1lZEhhbmRsZXIpO1xuICAgIHRoaXMuX2FkZGVkSGFuZGxlcnNbc2MuaWRdID0gYWRkZWRIYW5kbGVyO1xuICAgIHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF0gPSByZW1vdmVkSGFuZGxlcjtcbiAgICB0aGlzLl90cmFuc2Zvcm1lZEhhbmRsZXJzW3NjLmlkXSA9IHRyYW5zZm9ybWVkSGFuZGxlcjtcbiAgfTtcblxuICBlbWl0dGVyLl9yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChzcGFjZWNvbnRhaW5lcikge1xuICAgIC8vIFRvIGJlIGNhbGxlZCBmcm9tIFNwYWNlQ29udGFpbmVyI3JlbW92ZVxuICAgIC8vIFByZWNvbmRpdGlvbjogc3BhY2Vjb250YWluZXIgaW4gc3BhY2VcbiAgICB2YXIgc2MsIGg7XG5cbiAgICBzYyA9IHNwYWNlY29udGFpbmVyOyAvLyBhbGlhc1xuICAgIGRlbGV0ZSB0aGlzLl9jb250ZW50W3NjLmlkXTtcblxuICAgIC8vIFJlbW92ZSBoYW5kbGVyc1xuICAgIGggPSB0aGlzLl9hZGRlZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fYWRkZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgc2Mub2ZmKCdjb250ZW50QWRkZWQnLCBoKTtcblxuICAgIGggPSB0aGlzLl9yZW1vdmVkSGFuZGxlcnNbc2MuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLl9yZW1vdmVkSGFuZGxlcnNbc2MuaWRdO1xuICAgIHNjLm9mZignY29udGVudFJlbW92ZWQnLCBoKTtcblxuICAgIGggPSB0aGlzLl90cmFuc2Zvcm1lZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fdHJhbnNmb3JtZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgc2Mub2ZmKCd0cmFuc2Zvcm1lZCcsIGgpO1xuICAgIHNjLm9mZignY29udGVudFRyYW5zZm9ybWVkJywgaCk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlQ29udGFpbmVyO1xuIiwiLypcblNwYWNlUGxhbmVcbkFQSSB2MC42LjBcblxuQSBTcGFjZVBsYW5lIHJlcHJlc2VudHMgYSBjb29yZGluYXRlIHN5c3RlbS4gSXQgZG9lcyBub3QgaW5jbHVkZVxubWV0aG9kcyB0byB0cmFuc2Zvcm0gdGhlIHN5c3RlbS4gU3BhY2VQbGFuZSBhbmQgVHJhbnNmb3JtZXIgYXJlIHNlcGFyYXRlZFxuYmVjYXVzZSB3ZSB3YW50IHRvIGhhdmUgcGxhbmVzIHRoYXQgY2Fubm90IGJlIHRyYW5zZm9ybWVkLCBhcyBTcGFjZS5cblxuKi9cblxudmFyIG51ZGdlZCA9IHJlcXVpcmUoJ251ZGdlZCcpO1xudmFyIFNwYWNlUG9pbnQgPSByZXF1aXJlKCcuL1NwYWNlUG9pbnQnKTtcblxudmFyIGF0ID0gZnVuY3Rpb24gKHh5KSB7XG4gIC8vIFJldHVyblxuICAvLyAgIEEgU3BhY2VQb2ludCBhdCAoeCx5KSBvbiB0aGUgcGxhbmUuXG4gIGlmICh4eS5sZW5ndGggIT09IDIpIHsgIC8vIERFQlVHIFRPRE8gcmVtb3ZlIHRoaXNcbiAgICB0aHJvdyAnSW52YWxpZCBwb2ludCwgdXNlIGFycmF5IFt4LCB5XSc7XG4gIH1cbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5LCB0aGlzKTsgIC8vIE5vdGU6IHRoaXMgPT09IGVtaXR0ZXJcbn07XG5cbnZhciBTcGFjZVBsYW5lID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGVtaXR0ZXJcbiAgLy8gICAgIEEgU3BhY2VDb250YWluZXIgdG8gbW9ua2V5IHBhdGNoIHRvIFNwYWNlUGxhbmVcblxuICAvLyBDb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uLlxuICAvLyBUaGUgdHJhbnNmb3JtYXRpb24gZnJvbSB0aGUgcGxhbmUgdG8gdGhlIHBhcmVudCAoc3BhY2UpLlxuICAvLyBTZWUgMjAxNi0wMy0wNS0wOVxuICAvLyBMZXQ6XG4gIC8vICAgeF9zcGFjZSwgYSBwb2ludCBpbiBzcGFjZVxuICAvLyAgIHhfcGxhbmUsIGEgcG9pbnQgb24gdGhlIHBsYW5lLlxuICAvLyAgIFQsIHRoZSBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBwbGFuZVxuICAvLyBUaGVuOlxuICAvLyAgIHhfc3BhY2UgPSBUICogeF9wbGFuZVxuICAvL1xuICAvLyBGb3IgU3BhY2UsIGl0IGlzIG9idmlvdXNseSB0aGUgaWRlbnRpdHkgdHJhbnNmb3JtOlxuICAvLyAgIHhfc3BhY2UgPSBUICogeF9zcGFjZVxuICBlbWl0dGVyLl9UID0gbnVkZ2VkLlRyYW5zZm9ybS5JREVOVElUWTsgLy8gaWRlbnRpdHkgdHJhbnNmb3JtYXRpb25cblxuICBlbWl0dGVyLmF0ID0gYXQ7XG5cbiAgZW1pdHRlci5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gTG9jYWwgdHJhbnNmb3JtIGZyb20gcGxhbmUgdG8gcGFyZW50XG4gICAgLy9cbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIHRyYW5zZm9ybWF0aW9uIGZyb20gcGxhbmUgdG8gcGFyZW50LCBpLmUuXG4gICAgLy8gICAgIHh5X3BhcmVudCA9IFQgKiB4eV9wbGFuZVxuICAgIC8vIE5lZWRlZCB3aGVuIHdlIHdhbnQgdG8gc3RvcmUgdHJhbnNmb3JtZXIncyBwb3NpdGlvbiBmb3IgbGF0ZXIgdXNlLlxuICAgIHJldHVybiB0aGlzLl9UO1xuICB9O1xuXG4gIGVtaXR0ZXIuZ2V0R2xvYmFsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgdHJhbnNmb3JtYXRpb24gZnJvbSB0aGUgcGxhbmUgdG8gcm9vdCBjb250YWluZXIuXG4gICAgLy9cbiAgICAvLyBEZXYgbm90ZTpcbiAgICAvLyAgIExvY2FsIHRyYW5zZm9ybWF0aW9ucyBnbyBsaWtlOlxuICAgIC8vICAgICB4eV9wYXJlbnQgPSBUX3BsYW5lICogeHlfcGxhbmVcbiAgICAvLyAgICAgeHlfcGFyZW50X3BhcmVudCA9IFRfcGFyZW50ICogeHlfcGFyZW50XG4gICAgLy8gICAgIC4uLlxuICAgIC8vICAgICB4eV9yb290ID0gVF9wYXJlbnRfcGFyZW50Li4uX3BhcmVudCAqIHh5X3BhcmVudF9wYXJlbnQuLi5fcGFyZW50XG4gICAgLy8gICBUaGVyZWZvcmUgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uIGlzOlxuICAgIC8vICAgICB4eV9yb290ID0gVF9wYXJlbnRfLi4uX3BhcmVudCAqIC4uLiAqIFRfcGFyZW50ICogVF9wbGFuZSAqIHh5X3BsYW5lXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gVE9ETyBtYXliZSB0b28gZmFyOiB0aGlzLl9wYXJlbnQuX3BhcmVudCBtaWdodCBiZSBzdWZmaWNpZW50LlxuICAgICAgcmV0dXJuIHRoaXMuX1Q7XG4gICAgfSAvLyBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudC5nZXRHbG9iYWxUcmFuc2Zvcm0oKS5tdWx0aXBseUJ5KHRoaXMuX1QpO1xuICB9O1xuXG4gIGVtaXR0ZXIucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQmVjb21lIHNwYWNlLiBDYWxsZWQgZS5nLiB3aGVuIHBsYW5lIGlzIHJlbW92ZWQgZnJvbSBwYXJlbnQuXG4gICAgdGhpcy5fVCA9IG51ZGdlZC5UcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH07XG4gIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZVBsYW5lO1xuIiwiLy8gQVBJIHYwLjMuMFxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxudmFyIFNwYWNlUG9pbnQgPSBmdW5jdGlvbiAoeHksIHJlZmVyZW5jZSkge1xuICAvLyBFeGFtcGxlXG4gIC8vICAgdmFyIHAgPSB0YWFzcGFjZS5Qb2ludChbeCwgeV0sIHRhYSk7XG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHh5XG4gIC8vICAgICAyRCBhcnJheVxuICAvLyAgIHJlZmVyZW5jZVxuICAvLyAgICAgYSBTcGFjZUNvbnRhaW5lciBvciBTcGFjZVBvaW50XG4gIC8vICAgICAgIGFuIGl0ZW0gaW4gc3BhY2UsIGVuYWJsaW5nIGNvb3JkIHByb2plY3Rpb25zLlxuICB0aGlzLnh5ID0geHk7XG5cbiAgLy8gVGhlIFNwYWNlUGxhbmUncyB0cmFuc2Zvcm1hdGlvbiB0aGUgeHkgYXJlIG9uLlxuICAvLyBEZXNpZ24gbm90ZTogYXQgZmlyc3QsIHRoZSByZWZlcmVuY2VzIHdlcmUgU3BhY2VQbGFuZXMgYW5kIG5vdFxuICAvLyB0cmFuc2Zvcm1hdGlvbnMuIEJ1dCBiZWNhdXNlIGEgU3BhY2VQbGFuZSBjYW4gbW92ZSBvciBiZSByZW1vdmVkLFxuICAvLyB3ZSBjaG9zZSBvbmx5IHRoZSB0cmFuc2Zvcm1hdGlvbiB0byBiZSByZW1lbWJlcmVkLlxuICAvLyBEZXNpZ24gbm90ZTogbGF0ZXIgd2UgZm91bmQgaXQgd291bGQgYmUgY29udmVuaWVudCBmb3IgZGVidWdnaW5nXG4gIC8vIHRvIGtub3cgd2hlcmUgdGhlIHBvaW50IGNhbWUgZnJvbSwgd2hpY2ggbGVkIHRvIHRoaXMuX29yaWdpbi5cbiAgLy8gQWZ0ZXIgdGhhdCB3ZSBmb3VuZCB0aGF0IGluIHRvU3BhY2UgbWV0aG9kLCB3ZSB3b3VsZCBuZWVkIHJlZmVyZW5jZVxuICAvLyB0byBzcGFjZSwgYWx0aG91Z2ggd2Ugb25seSBoYXZlIGltcGxpY2l0IHJlZmVyZW5jZSB0byBpdHMgY29vcmRzLlxuICAvLyBUaGVyZWZvcmUgdGhpcy5fb3JpZ2luIHdhcyBkcm9wcGVkLlxuXG4gIGlmIChyZWZlcmVuY2UuaGFzT3duUHJvcGVydHkoJ2dldEdsb2JhbFRyYW5zZm9ybScpKSB7XG4gICAgLy8gSXMgYSBTcGFjZVBsYW5lXG4gICAgdGhpcy5fVCA9IHJlZmVyZW5jZS5nZXRHbG9iYWxUcmFuc2Zvcm0oKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBhIFNwYWNlUG9pbnRcbiAgICB0aGlzLl9UID0gcmVmZXJlbmNlLl9UO1xuICB9XG59O1xuXG52YXIgcHJvdG8gPSBTcGFjZVBvaW50LnByb3RvdHlwZTtcblxuXG5wcm90by5vZmZzZXQgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBwb2ludCBuZWFyYnkuXG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIGR4XG4gIC8vICAgICBNb3ZlbWVudCB0b3dhcmRzIHBvc2l0aXZlIHhcbiAgLy8gICBkeVxuICAvLyAgICAgLi4uXG4gIHZhciB4eSA9IFt0aGlzLnh5WzBdICsgZHgsIHRoaXMueHlbMV0gKyBkeV07XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eSwgdGhpcyk7XG59O1xuXG5wcm90by5wb2xhck9mZnNldCA9IGZ1bmN0aW9uIChyYWRpdXMsIHJhZGlhbnMpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IG1vdmVkIGJ5IHRoZSBwb2xhciBjb29yZGluYXRlc1xuICB2YXIgeCA9IHRoaXMueHlbMF0gKyByYWRpdXMgKiBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgdmFyIHkgPSB0aGlzLnh5WzFdICsgcmFkaXVzICogTWF0aC5zaW4ocmFkaWFucyk7XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludChbeCwgeV0sIHRoaXMpO1xufTtcblxucHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gIHJldHVybiAodGhpcy54eVswXSA9PT0gcG9pbnQueHlbMF0gJiZcbiAgICAgICAgICB0aGlzLnh5WzFdID09PSBwb2ludC54eVsxXSAmJlxuICAgICAgICAgIHRoaXMuX1QuZXF1YWxzKHBvaW50Ll9UKSk7XG59O1xuXG5wcm90by50byA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IFNwYWNlUG9pbnQgYXQgc2FtZSBsb2NhdGlvbiBidXQgb24gYVxuICAvLyBkaWZmZXJlbnQgU3BhY2VQbGFuZS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyXG4gIC8vICAgdGFyZ2V0LCBhIFNwYWNlUGxhbmUgb3IgbnVsbC5cbiAgLy9cbiAgLy8gSW1wbGVtZW50YXRpb24gbm90ZSAoU2VlIDIwMTYtMDMtMDUtMDkpOlxuICAvL1xuICAvLyBGaXJzdCwgY29tcHV0ZSBjb29yZC4gdHJhbnNmLiBCIGZyb20gdGhlIGN1cnJlbnQgcGxhbmVcbiAgLy8gdG8gdGhlIHNwYWNlOlxuICAvLyAgIHhfc3BhY2UgPSBCICogeF9wbGFuZSAgPD0+ICB4X3BsYW5lID0gaW52KEIpICogeF9zcGFjZVxuICAvLyAgIEIgPSBwbGFuZS5fVFxuICAvLyBTZWNvbmQsIGxldCBBIGJlIGNvb3JkLiB0cmFuc2YuIGZyb20gdGhlIHNwYWNlIHRvIHRoZSB0YXJnZXQgcGxhbmU6XG4gIC8vICAgeF90YXJnZXQgPSBBICogeF9zcGFjZVxuICAvLyAgIEEgPSBpbnYodGFyZ2V0Ll9UKVxuICAvLyBUaGVyZWZvcmUgY29tYmluZWQgY29vcmQuIHRyYW5zZi4gQyBmcm9tIHRoZSBjdXJyLiBwbGFuZSB0byB0aGUgdGFyZ2V0OlxuICAvLyAgIHhfdGFyZ2V0ID0gQyAqIHhfcGxhbmVcbiAgLy8gICA8PT4gQSAqIHhfc3BhY2UgPSBDICogaW52KEIpICogeF9zcGFjZVxuICAvLyAgIDw9PiBBID0gQyAqIGludihCKVxuICAvLyAgIDw9PiBDID0gQUJcbiAgLy8gICA8PT4gQyA9IGludih0YXJnZXQuX1QpICogcGxhbmUuX1RcbiAgLy9cblxuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gdGFyZ2V0IGlzIHRoZSByb290IGNvbnRhaW5lciAoc3BhY2UpXG4gICAgcmV0dXJuIHRoaXMudG9TcGFjZSgpO1xuICB9XG5cbiAgLy8gVGFyZ2V0J3MgZ2xvYmFsIHRyYW5zZm9ybWF0aW9uLiBUaGlzLl9UIGlzIGFscmVhZHkgZ2xvYmFsLlxuICB2YXIgdGFyZ2V0X2dUID0gdGFyZ2V0LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuXG4gIGlmICh0YXJnZXRfZ1QuZXF1YWxzKHRoaXMuX1QpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gZWxzZVxuICB2YXIgQyA9IHRhcmdldF9nVC5pbnZlcnNlKCkubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgdmFyIHh5X3RhcmdldCA9IEMudHJhbnNmb3JtKHRoaXMueHkpO1xuICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoeHlfdGFyZ2V0LCB0YXJnZXQpO1xufTtcblxucHJvdG8udG9TcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IFNwYWNlUG9pbnQgYXQgc2FtZSBsb2NhdGlvbiBidXQgcmVwcmVzZW50ZWQgb24gc3BhY2UgY29vcmRzLlxuICAvL1xuICAvLyBJbXBsZW1lbnRhdGlvbiBub3RlOlxuICAvLyAgIFdlIGFscmVhZHkgaGF2ZSBjb29yZC4gdHJhbnNmLiBmcm9tIHRoZSBjdXJyZW50IHBsYW5lIHRvIHRoZSBzcGFjZTpcbiAgLy8gICAgIHBsYW5lLl9UXG4gIHZhciB4eV9zcGFjZSA9IHRoaXMuX1QudHJhbnNmb3JtKHRoaXMueHkpO1xuICB2YXIgc3BhY2VfbW9jayA9IHsnX1QnOiBUcmFuc2Zvcm0uSURFTlRJVFl9O1xuICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoeHlfc3BhY2UsIHNwYWNlX21vY2spO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBwb2ludCBieSB0cmFuc2Zvcm1hdGlvbi5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyXG4gIC8vICAgdHJcbiAgLy8gICAgIGEgVHJhbnNmb3JtXG4gIHZhciB4eV9oYXQgPSB0ci50cmFuc2Zvcm0odGhpcy54eSk7XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eV9oYXQsIHRoaXMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlUG9pbnQ7XG4iLCIvLyBBUEkgdjAuNS4wXG4vL3ZhciBudWRnZWQgPSByZXF1aXJlKCdudWRnZWQnKTtcbnZhciBTcGFjZVBvaW50ID0gcmVxdWlyZSgnLi9TcGFjZVBvaW50Jyk7XG5cbnZhciBTcGFjZVJlY3RhbmdsZSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1lcikge1xuXG4gIHZhciB0ID0gdHJhbnNmb3JtZXI7ICAvLyBBbGlhc1xuXG4gIC8vIFJlY3RhbmdsZXMgaGF2ZSBzaXplLlxuICAvLyBJbiBpdHMgb3duIGNvb3JkaW5hdGVzLCByZWN0YW5nbGUncyByaWdodCBib3R0b20gY29ybmVyXG4gIC8vIGlzIGxvY2F0ZWQgYXQgW3dpZHRoLCBoZWlnaHRdLlxuICAvLyBCeSBkZWZhdWx0IHRyYW5zZm9ybWF0aW9uLCB3aWR0aCAxIGFuZCBoZWlnaHQgMSBlcXVhbCB0byAxIHNwYWNlIHVuaXQuXG4gIHZhciB3aWR0aCA9IDE7XG4gIHZhciBoZWlnaHQgPSAxO1xuXG4gIHQucmVzaXplID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRpbWVuc2lvbnMsIFt3aWR0aCwgaGVpZ2h0XVxuICAgIHdpZHRoID0gZGltZW5zaW9uc1swXTtcbiAgICBoZWlnaHQgPSBkaW1lbnNpb25zWzFdO1xuXG4gICAgdGhpcy5lbWl0KCdyZXNpemVkJywgdCk7XG4gIH07XG5cbiAgdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gIH07XG5cbiAgdC5hdE5vcm0gPSBmdW5jdGlvbiAoeHkpIHtcbiAgICAvLyBSZXR1cm4gYSBTcGFjZVBvaW50IGJ5IGNvb3JkaW5hdGVzIG5vcm1hbGl6ZWQgYWJvdXQgdGhlIHNpemUuXG4gICAgLy8gYXROb3JtKFsxLDBdKSByZXR1cm5zIHRoZSBwb2ludCBhdCB0aGUgcmlnaHQgdXBwZXIgY29ybmVyLlxuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGggKiB4eVswXSwgaGVpZ2h0ICogeHlbMV1dLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGggLyAyLCBoZWlnaHQgLyAyXSwgdCk7XG4gIH07XG5cbiAgdC5hdE1pZE4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCAvIDIsIDBdLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkVyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoWzAsIGhlaWdodCAvIDJdLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkRSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoLCBoZWlnaHQgLyAyXSwgdCk7XG4gIH07XG5cbiAgdC5hdE1pZFMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCAvIDIsIGhlaWdodF0sIHQpO1xuICB9O1xuXG4gIHQuYXROVyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoWzAsIDBdLCB0KTtcbiAgfTtcblxuICB0LmF0TkUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCwgMF0sIHQpO1xuICB9O1xuXG4gIHQuYXRTVyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoWzAsIGhlaWdodF0sIHQpO1xuICB9O1xuXG4gIHQuYXRTRSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoLCBoZWlnaHRdLCB0KTtcbiAgfTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZVJlY3RhbmdsZTtcbiIsIi8vIHYwLjMuMFxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VDb250YWluZXIgPSByZXF1aXJlKCcuL1NwYWNlQ29udGFpbmVyJyk7XG52YXIgU3BhY2VQbGFuZSA9IHJlcXVpcmUoJy4vU3BhY2VQbGFuZScpO1xudmFyIFRyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1lcicpO1xudmFyIFNwYWNlUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9TcGFjZVJlY3RhbmdsZScpO1xuXG52YXIgU3BhY2VUYWEgPSBmdW5jdGlvbiAocGFyZW50LCB0YWEpIHtcbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VDb250YWluZXIodGhpcyk7XG4gIFNwYWNlUGxhbmUodGhpcyk7XG4gIFRyYW5zZm9ybWVyKHRoaXMpO1xuICBTcGFjZVJlY3RhbmdsZSh0aGlzKTtcblxuICB0aGlzLnRhYSA9IHRhYTtcbiAgdGhpcy5yZXNpemUoWzI1NiwgMjU2XSk7IC8vIFNpemUgb2YgdGFhLlxuXG4gIHRoaXMuc2V0UGFyZW50KHBhcmVudCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlVGFhO1xuIiwiLy8gQVBJIHYwLjMuMFxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGxvYWRpbWFnZXMgPSByZXF1aXJlKCdsb2FkaW1hZ2VzJyk7XG5cbnZhciBOT09QID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBUYWEgPSBmdW5jdGlvbiAoaW1nU3JjLCBvbkxvYWRlZCkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgaW1nU3JjXG4gIC8vICAgb25Mb2FkZWQoZXJyLCB0YWEpXG4gIC8vICAgICBvcHRpb25hbCwgZnVuY3Rpb24gKHRhYSlcbiAgRW1pdHRlcih0aGlzKTtcbiAgdmFyIHRoaXMyID0gdGhpcztcblxuICAvLyBvbkxvYWRlZCBpcyBvcHRpb25hbFxuICBpZiAodHlwZW9mIG9uTG9hZGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Mb2FkZWQgPSBOT09QO1xuICB9XG5cbiAgLy8gVGhpcyBvYmplY3Qgd2lsbCBiZSByZXBsYWNlZCBieSBhIHJlYWwgSW1hZ2Ugb2JqZWN0IGJ1dCBiZWZvcmUgdGhhdFxuICAvLyBzcmMgaXMgbmVlZGVkIGluIFNwYWNlVmlldy5cbiAgdGhpcy5pbWFnZSA9IHsgc3JjOiBpbWdTcmMgfTtcblxuICAvLyBJZiB0aGUgaW1hZ2UgaXMgY2FjaGVkLCB0aGUgJ2xvYWQnIGV2ZW50IG9mIEltYWdlIGVsZW1lbnQgaXNcbiAgLy8gZmlyZWQgaW5zdGFudGx5IHdoZW4gY2FsbGluZyBsb2FkaW1hZ2VzLiBJZiB3ZSBkaWQgbm90IGNhcmVcbiAgLy8gYWJvdXQgdGhpcywgdGhlIG9uKCdsb2FkZWQnLCBmbikgbGlzdGVuZXJzIHdvdWxkIGV4cGVyaWVuY2VcbiAgLy8gZGlmZmVyZW50IGV4ZWN1dGlvbiBvcmRlciBkZXBlbmRpbmcgd2hldGhlciB0aGUgaW1hZ2VzIHdhc1xuICAvLyBjYWNoZWQgb3Igbm90LlxuICB2YXIgbm90Q2FjaGVkID0gZmFsc2U7XG5cbiAgbG9hZGltYWdlcyhpbWdTcmMsIGZ1bmN0aW9uIChlcnIsIGltYWdlKSB7XG4gICAgdGhpczIuaW1hZ2UgPSBpbWFnZTtcblxuICAgIGlmIChub3RDYWNoZWQpIHtcbiAgICAgIHRoaXMyLmVtaXQoJ2xvYWRlZCcsIGVyciwgdGhpczIpO1xuICAgICAgb25Mb2FkZWQoZXJyLCB0aGlzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzMi5lbWl0KCdsb2FkZWQnLCBlcnIsIHRoaXMyKTtcbiAgICAgICAgb25Mb2FkZWQoZXJyLCB0aGlzMik7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH0pO1xuICBub3RDYWNoZWQgPSB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWE7XG4iLCIvLyBBUEkgdjAuMi4wXG52YXIgbnVkZ2VkID0gcmVxdWlyZSgnbnVkZ2VkJyk7XG5cbi8vIFRPRE9cbi8vIG1vbmtleXBhdGNoIFwidG8ocGxhbmUpXCJcblxubW9kdWxlLmV4cG9ydHMgPSBudWRnZWQuVHJhbnNmb3JtO1xuIiwiLy8gQVBJIHYwLjIuMFxudmFyIG51ZGdlZCA9IHJlcXVpcmUoJ251ZGdlZCcpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgU3BhY2VQb2ludCA9IHJlcXVpcmUoJy4vU3BhY2VQb2ludCcpO1xuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKHBvaW50cywgcGxhbmUpIHtcbiAgLy8gVHJhbnNmb3JtIGFsbCB0aGUgcG9pbnRzIG9udG8gdGhlIHBhcmVudCBhbmRcbiAgLy8gcmVwcmVzZW50IHRoZW0gaW4gYXJyYXkgW1t4MCx5MF0sIFt4MSx5MV0sIC4uLl0uXG4gIC8vXG4gIC8vIEFyZ3VtZW50c1xuICAvLyAgIHBvaW50cywgYSBzaW5nbGUgc3BhY2Vwb2ludCBvciBhIGxpc3Qgb2Ygc3BhY2Vwb2ludHNcbiAgLy8gICBwbGFuZSwgYSBTcGFjZVBsYW5lIGUuZy4gYSBTcGFjZVRhYSBvbnRvIG5vcm1hbGl6ZS5cbiAgLy8gUmV0dXJuXG4gIC8vICAgYXJyYXkgb2YgeHkgcG9pbnRzIGluIHNwYWNlLlxuICB2YXIgaSwgcCwgbnAsIG5vcm1hbGl6ZWQ7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpIHtcbiAgICAvLyBTaW5nbGUgU3BhY2VQb2ludFxuICAgIHAgPSBwb2ludHM7XG4gICAgbnAgPSBwLnRvKHBsYW5lKS54eTtcbiAgICByZXR1cm4gW25wXTtcbiAgfSAvLyBlbHNlXG4gIG5vcm1hbGl6ZWQgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbnAgPSBwLnRvKHBsYW5lKS54eTtcbiAgICBub3JtYWxpemVkLnB1c2gobnApO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG52YXIgdHJhbnNmb3JtQnlFc3RpbWF0ZSA9IGZ1bmN0aW9uIChwbGFuZSwgdHlwZSwgZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgLy8gVHlwZXM6IFQsUyxSLFRTLFRSLFNSLFRTUiAoc2VlIG51ZGdlZCBmb3IgZnVydGhlciBkZXRhaWxzKVxuXG4gIHZhciBub3JtUGl2b3Q7XG4gIGlmICh0eXBlb2YgcGl2b3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCBwbGFuZS5fcGFyZW50KVswXTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgYWxsIFNwYWNlUG9pbnRzIG9udG8gdGhlIHNwYWNlIGFuZCB0byBhcnJheXNcbiAgdmFyIG5vcm1Eb21haW4gPSBub3JtYWxpemUoZG9tYWluLCBwbGFuZS5fcGFyZW50KTtcbiAgdmFyIG5vcm1SYW5nZSA9IG5vcm1hbGl6ZShyYW5nZSwgcGxhbmUuX3BhcmVudCk7XG5cbiAgLy8gVGhlbiBjb21wdXRlIG9wdGltYWwgdHJhbnNmb3JtYXRpb24gaW4gc3BhY2VcbiAgdmFyIEhfc3BhY2UgPSBudWRnZWQuZXN0aW1hdGUodHlwZSwgbm9ybURvbWFpbiwgbm9ybVJhbmdlLCBub3JtUGl2b3QpO1xuICAvLyBTZWUgMjAxNi0wMy0wNS0xMTpcbiAgLy8gICBUbyBhcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBhIHNwYWNlIG9iamVjdDpcbiAgLy8gICAgIFRfaGF0ID0gdG9QYXJlbnQoSCkgKiBUXG4gIC8vIFRoZXJlZm9yZTpcbiAgcGxhbmUuX1QgPSBIX3NwYWNlLm11bHRpcGx5QnkocGxhbmUuX1QpO1xuXG4gIC8vIE5vdGlmeSBlc3BlY2lhbGx5IHZpZXcgYWJvdXQgdHJhbnNmb3JtYXRpb24uXG4gIHBsYW5lLmVtaXQoJ3RyYW5zZm9ybWVkJywgcGxhbmUpO1xufTtcblxuXG52YXIgVHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAocGxhbmUpIHtcbiAgLy9cbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIHBsYW5lXG4gIC8vICAgICBhIFNwYWNlQ29udGFpbmVyXG5cbiAgcGxhbmUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKFQpIHtcbiAgICAvLyBOZWVkZWQgd2hlbiB3ZSB3aGFuIHRvIHJlc3RvcmUgc3RvcmVkIHBvc2l0aW9uLCBtYXliZSBhZnRlclxuICAgIC8vIG1vZGlmaWNhdGlvbi5cbiAgICBpZiAodGhpcy5fcGFyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBhcmUgcm9vdCwgY2Fubm90IHNldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fVCA9IFQ7XG4gICAgdGhpcy5lbWl0KCd0cmFuc2Zvcm1lZCcsIHRoaXMpO1xuICB9O1xuXG4gIHBsYW5lLnNldEdsb2JhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChUKSB7XG4gICAgLy8gU2V0IGxvY2FsIHRyYW5zZm9ybSBzbyB0aGF0IHRoZSBnbG9iYWwgdHJhbnNmb3JtIGJlY29tZXMgdGhlIGdpdmVuIFQuXG4gICAgLy9cbiAgICAvLyBEZXYgbm90ZTpcbiAgICAvLyAgIEdpdmVuIFQgaXMgY29vcmQuIHRyYW5zZi4gZnJvbSB0aGUgcGxhbmUgdG8gcm9vdCAoc3BhY2UpLlxuICAgIC8vICAgU28gaXMgdGhpcy5fVC5cbiAgICAvLyAgIGN1cnJlbnRfZ2xvYl90cmFucyA9IHBhcmVudF9nbG9iX3RyYW5zICogdGhpc19UXG4gICAgLy8gICBuZXdfZ2xvYl90cmFucyA9IHBhcmVudF9nbG9iX3RyYW5zICogWFxuICAgIC8vICAgPD0+IFggPSBpbnYocGFyZW50X2dsb2JfdHJhbnMpICogbmV3X2dsb2JfdHJhbnNcbiAgICBpZiAodGhpcy5fcGFyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBhcmUgcm9vdCwgY2Fubm90IHNldC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhcmVudF9nbG9iYWwgPSB0aGlzLl9wYXJlbnQuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fVCA9IHBhcmVudF9nbG9iYWwuaW52ZXJzZSgpLm11bHRpcGx5QnkoVCk7XG4gICAgdGhpcy5lbWl0KCd0cmFuc2Zvcm1lZCcsIHRoaXMpO1xuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gTW92ZSBwbGFuZSBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkgYnkgZXhhbXBsZS5cbiAgICAvL1xuICAgIC8vIFRyYW5zbGF0ZSB0aGUgcGxhbmUgc28gdGhhdCBhZnRlciB0aGUgdHJhbnNsYXRpb24sIHRoZSBkb21haW4gcG9pbnRzXG4gICAgLy8gd291bGQgYmUgYXMgY2xvc2UgdG8gZ2l2ZW4gcmFuZ2UgcG9pbnRzIGFzIHBvc3NpYmxlLlxuICAgIC8vXG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUJywgZG9tYWluLCByYW5nZSk7XG4gIH07XG5cbiAgcGxhbmUuc2NhbGUgPSBmdW5jdGlvbiAocGl2b3QsIG11bHRpcGxpZXJPckRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIHBpdm90LCBhIFNwYWNlUG9pbnRcbiAgICAvLyAgIG11bHRpcGxpZXIsIHRoZSBzY2FsZSBmYWN0b3IsID4gMFxuICAgIC8vICBPUlxuICAgIC8vICAgcGl2b3RcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHZhciB1c2VNdWx0aXBsaWVyID0gKHR5cGVvZiByYW5nZSA9PT0gJ3VuZGVmaW5lZCcpO1xuXG4gICAgaWYgKHVzZU11bHRpcGxpZXIpIHtcbiAgICAgIHZhciBub3JtUGl2b3QgPSBub3JtYWxpemUocGl2b3QsIHRoaXMuX3BhcmVudClbMF07XG4gICAgICB2YXIgbXVsdGlwbGllciA9IG11bHRpcGxpZXJPckRvbWFpbjtcbiAgICAgIC8vIE11bHRpcGxpZXIgZG9lcyBub3QgZGVwZW5kIG9uIHBsYW5lLlxuICAgICAgLy8gV2UgY3JlYXRlIGEgcGl2b3RlZCBzY2FsaW5nIHRyYW5zZm9ybSBvbiBwYXJlbnQuXG4gICAgICB2YXIgU19wYXJlbnQgPSBUcmFuc2Zvcm0uSURFTlRJVFkuc2NhbGVCeShtdWx0aXBsaWVyLCBub3JtUGl2b3QpO1xuICAgICAgLy8gU2VlIDIwMTYtMDMtMDUtMTFcbiAgICAgIC8vICAgV2UgdHJhbnNmb3JtIHNwYWNlIG9iamVjdHMgYnk6XG4gICAgICAvLyAgIFRfaGF0ID0gSF9zcGFjZSAqIFRcbiAgICAgIHRoaXMuX1QgPSBTX3BhcmVudC5tdWx0aXBseUJ5KHRoaXMuX1QpO1xuICAgICAgdGhpcy5lbWl0KCd0cmFuc2Zvcm1lZCcsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZG9tYWluID0gbXVsdGlwbGllck9yRG9tYWluO1xuICAgICAgdHJhbnNmb3JtQnlFc3RpbWF0ZSh0aGlzLCAnUycsIGRvbWFpbiwgcmFuZ2UsIHBpdm90KTtcbiAgICB9XG4gIH07XG5cbiAgcGxhbmUucm90YXRlID0gZnVuY3Rpb24gKHBpdm90LCByYWRpYW5zT3JEb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBwaXZvdFxuICAgIC8vICAgcmFkaWFuc1xuICAgIC8vICBPUlxuICAgIC8vICAgcGl2b3RcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHZhciB1c2VSYWRpYW5zID0gKHR5cGVvZiByYW5nZSA9PT0gJ3VuZGVmaW5lZCcpO1xuXG4gICAgaWYgKHVzZVJhZGlhbnMpe1xuICAgICAgdmFyIG5vcm1QaXZvdCA9IG5vcm1hbGl6ZShwaXZvdCwgdGhpcy5fcGFyZW50KVswXTtcbiAgICAgIHZhciByYWRpYW5zID0gcmFkaWFuc09yRG9tYWluO1xuICAgICAgLy8gUmFkaWFucyBkbyBub3QgZGVwZW5kIG9uIHBsYW5lLlxuICAgICAgLy8gV2UgY3JlYXRlIGEgcGl2b3RlZCByb3RhdGlvbiB0cmFuc2Zvcm0gb24gcGFyZW50LlxuICAgICAgdmFyIFJfcGFyZW50ID0gVHJhbnNmb3JtLklERU5USVRZLnJvdGF0ZUJ5KHJhZGlhbnMsIG5vcm1QaXZvdCk7XG4gICAgICAvLyBTZWUgMjAxNi0wMy0wNS0xMVxuICAgICAgLy8gICBXZSB0cmFuc2Zvcm0gc3BhY2Ugb2JqZWN0cyBieTpcbiAgICAgIC8vICAgVF9oYXQgPSBIX3NwYWNlICogVFxuICAgICAgdGhpcy5fVCA9IFJfcGFyZW50Lm11bHRpcGx5QnkodGhpcy5fVCk7XG4gICAgICB0aGlzLmVtaXQoJ3RyYW5zZm9ybWVkJywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb21haW4gPSByYWRpYW5zT3JEb21haW47XG4gICAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdSJywgZG9tYWluLCByYW5nZSwgcGl2b3QpO1xuICAgIH1cbiAgfTtcblxuICBwbGFuZS50cmFuc2xhdGVTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUUycsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZVJvdGF0ZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUUicsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIHBsYW5lLnNjYWxlUm90YXRlID0gZnVuY3Rpb24gKHBpdm90LCBkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdTUicsIGRvbWFpbiwgcmFuZ2UsIHBpdm90KTtcbiAgfTtcblxuICBwbGFuZS50cmFuc2xhdGVTY2FsZVJvdGF0ZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUU1InLCBkb21haW4sIHJhbmdlKTtcbiAgfTtcblxuICAvLyBwbGFuZS50cmFuc2xhdGVBbmRTY2FsZVRvRml0LCBub3Qgc3VyZSBpZiBuZWNlc3NhcnkgZm9yIG5vd1xuXG4gIHBsYW5lLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24gKHNlbGYsIG9sZFBhcmVudCwgbmV3UGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbGRQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG9sZFBhcmVudCA9IG51bGw7IH1cbiAgICBpZiAodHlwZW9mIG5ld1BhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgbmV3UGFyZW50ID0gbnVsbDsgfVxuXG4gICAgdmFyIHNhbWVSb290O1xuICAgIGlmIChuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFJvb3QgY29udGFpbmVycyBjYW5ub3QgbW92ZS5cbiAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9sZFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBSZW1vdmVkIGZyb20gbnVsbCBwYXJlbnQ/XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ0Nhbm5vdCByZW1vdmUgZnJvbSBudWxsIHBhcmVudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW92ZWQgb250byBhbm90aGVyIHBhcmVudC5cbiAgICAgICAgLy8gTGV0IHVzIGtlZXAgdGhlIGxvY2F0aW9uIGluIHNwYWNlIHRoZSBzYW1lIGlmIHBvc3NpYmxlLlxuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSBvbmx5IGlmIHRoZSBwYXJlbnRzIHNoYXJlIHNhbWUgcm9vdCBpLmUuXG4gICAgICAgIC8vIGFyZSBpbiB0aGUgc2FtZSBzcGFjZS5cbiAgICAgICAgc2FtZVJvb3QgPSBvbGRQYXJlbnQuZ2V0Um9vdFBhcmVudCgpID09PSBuZXdQYXJlbnQuZ2V0Um9vdFBhcmVudCgpO1xuICAgICAgICBpZiAoc2FtZVJvb3QpIHtcbiAgICAgICAgICAvLyBLZWVwIHRoZSBsb2NhdGlvbi5cbiAgICAgICAgICAvLyBMZXRcbiAgICAgICAgICAvLyAgIE9UIGJlIHRoZSBvbGQgbG9jYWwgY29vcmQuIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgICAgIC8vICAgTlQgYmUgdGhlIHVua25vd24gbmV3IGxvY2FsIGNvb3JkLiB0cmFuc2YuXG4gICAgICAgICAgLy8gICBPUEdUIGJlIHRoZSBnbG9iYWwgY29vcmQuIHRyYW5zZi4gb2Ygb2xkIHBhcmVudFxuICAgICAgICAgIC8vICAgTlBHVCBiZSB0aGUgZ2xvYmFsIGNvb3JkLiB0cmFuc2YuIG9mIG5ldyBwYXJlbnRcbiAgICAgICAgICAvLyBOb3csIHdlIHdhbnQgdG8ga2VlcCBnbG9iYWwgdHJhbnNmLiB1bmNoYW5nZWQuXG4gICAgICAgICAgLy8gICBPUEdUICogT1QgPSBOUEdUICogTlRcbiAgICAgICAgICAvLyAgIDw9PiBOVCA9IGludihOUEdUKSAqIE9QR1QgKiBPVFxuICAgICAgICAgIHZhciBvcGd0ID0gb2xkUGFyZW50LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgICAgICAgIHZhciBucGd0ID0gbmV3UGFyZW50LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgICAgICAgIHZhciBvdCA9IHRoaXMuX1Q7XG4gICAgICAgICAgdmFyIG50ID0gbnBndC5pbnZlcnNlKCkubXVsdGlwbHlCeShvcGd0KS5tdWx0aXBseUJ5KG90KTtcbiAgICAgICAgICB0aGlzLl9UID0gbnQ7XG4gICAgICAgICAgdGhpcy5lbWl0KCd0cmFuc2Zvcm1lZCcsIHRoaXMpOyAvLyBUT0RPIElzIG5lZWRlZCBiZWNhdXNlIGlucGxhY2U/XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW4gZGlmZmVyZW50IHNwYWNlOiByZXNldFxuICAgICAgICAgIHRoaXMucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiB0aGVyZSBjb3VsZCBiZSBhIG5lZWQgdG8gY2hhbmdlIHBhcmVudCB3aXRoIHRoZSBzYW1lXG4gICAgICAgIC8vIGxvY2FsIHRyYW5zZm9ybWF0aW9uLiBOb3QgbmVlZGVkIGZvciBub3cuXG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1lcjtcbiIsIlxuZXhwb3J0cy5UYWEgPSByZXF1aXJlKCcuL1RhYScpO1xuZXhwb3J0cy5TcGFjZVRhYSA9IHJlcXVpcmUoJy4vU3BhY2VUYWEnKTtcbmV4cG9ydHMuU3BhY2UgPSByZXF1aXJlKCcuL1NwYWNlJyk7XG5leHBvcnRzLkhUTUxTcGFjZVZpZXcgPSByZXF1aXJlKCcuL0hUTUxTcGFjZVZpZXcnKTtcblxuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICczLjAuMCc7XG4iXX0=
