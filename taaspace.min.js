(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.taaspace = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
module.exports = function loadimages(imgSrcs, then) {
  // Parameters
  //   imgSrcs
  //     array of image source paths OR single source path string.
  //   then(err, imgElements)
  //     Will be called after all the images are loaded. If string was given,
  //     imgElements is an Image instead of array of Images.

  var numberOfImages, stringGiven, thereWasSuccess, thereWasError, imgs;
  var onloadsCalled, onload, onerror;

  if (typeof then !== 'function') {
    throw new Error('callback should be a function: ' + then);
  }

  if (typeof imgSrcs === 'string') {
    numberOfImages = 1;
    stringGiven = true;
    imgSrcs = [imgSrcs]; // Normalize
  } else {
    // Array of images
    numberOfImages = imgSrcs.length;
    stringGiven = false;
  }
  thereWasSuccess = false;
  thereWasError = false;

  imgs = [];

  onloadsCalled = 0;
  onload = function () {
    // Note:
    //   this = Image
    if (!thereWasError) {
      onloadsCalled += 1;
      var isFinalImage = (onloadsCalled === numberOfImages);
      if (isFinalImage) {
        thereWasSuccess = true;
        if (stringGiven) {
          then(null, imgs[0]);
        } else {
          then(null, imgs);
        }
      }
    }
  };

  onerror = function (errMsg) {
    // Note:
    //   this = Image

    // No errors after success.
    if (!thereWasSuccess) {
      thereWasError = true;
      then(errMsg, null);
    }

    // Prevent firing the default event handler
    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror#Parameters
    return true;
  };

  for (i = 0; i < imgSrcs.length; i += 1) {
    imgs.push(new Image());
    imgs[i].onload = onload;
    imgs[i].onerror = onerror;
    imgs[i].src = imgSrcs[i];
  }
};

},{}],3:[function(require,module,exports){
/**
 * Module Dependencies.
 */

var Emitter = require('component-emitter');
var query = require('component-query');
var after = require('after-transition');
var has3d = require('has-translate3d');
var ease = require('css-ease');

/**
 * CSS Translate
 */

var translate = has3d
  ? ['translate3d(', ', 0)']
  : ['translate(', ')'];

/**
 * Export `Move`
 */

module.exports = Move;

/**
 * Get computed style.
 */

var style = window.getComputedStyle
  || window.currentStyle;

/**
 * Library version.
 */

Move.version = '0.5.0';

/**
 * Export `ease`
 */

Move.ease = ease;

/**
 * Defaults.
 *
 *   `duration` - default duration of 500ms
 *
 */

Move.defaults = {
  duration: 500
};

/**
 * Default element selection utilized by `move(selector)`.
 *
 * Override to implement your own selection, for example
 * with jQuery one might write:
 *
 *     move.select = function(selector) {
 *       return jQuery(selector).get(0);
 *     };
 *
 * @param {Object|String} selector
 * @return {Element}
 * @api public
 */

Move.select = function(selector){
  if ('string' != typeof selector) return selector;
  return query(selector);
};

/**
 * Initialize a new `Move` with the given `el`.
 *
 * @param {Element} el
 * @api public
 */

function Move(el) {
  if (!(this instanceof Move)) return new Move(el);
  if ('string' == typeof el) el = query(el);
  if (!el) throw new TypeError('Move must be initialized with element or selector');
  this.el = el;
  this._props = {};
  this._rotate = 0;
  this._transitionProps = [];
  this._transforms = [];
  this.duration(Move.defaults.duration)
};


/**
 * Inherit from `EventEmitter.prototype`.
 */

Emitter(Move.prototype);

/**
 * Buffer `transform`.
 *
 * @param {String} transform
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transform = function(transform){
  this._transforms.push(transform);
  return this;
};

/**
 * Skew `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skew = function(x, y){
  return this.transform('skew('
    + x + 'deg, '
    + (y || 0)
    + 'deg)');
};

/**
 * Skew x by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewX = function(n){
  return this.transform('skewX(' + n + 'deg)');
};

/**
 * Skew y by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewY = function(n){
  return this.transform('skewY(' + n + 'deg)');
};

/**
 * Translate `x` and `y` axis.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translate =
Move.prototype.to = function(x, y){
  return this.transform(translate.join(''
    + x +'px, '
    + (y || 0)
    + 'px'));
};

/**
 * Translate on the x axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateX =
Move.prototype.x = function(n){
  return this.transform('translateX(' + n + 'px)');
};

/**
 * Translate on the y axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateY =
Move.prototype.y = function(n){
  return this.transform('translateY(' + n + 'px)');
};

/**
 * Scale the x and y axis by `x`, or
 * individually scale `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scale = function(x, y){
  return this.transform('scale('
    + x + ', '
    + (y || x)
    + ')');
};

/**
 * Scale x axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleX = function(n){
  return this.transform('scaleX(' + n + ')')
};

/**
 * Apply a matrix transformation
 *
 * @param {Number} m11 A matrix coefficient
 * @param {Number} m12 A matrix coefficient
 * @param {Number} m21 A matrix coefficient
 * @param {Number} m22 A matrix coefficient
 * @param {Number} m31 A matrix coefficient
 * @param {Number} m32 A matrix coefficient
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.matrix = function(m11, m12, m21, m22, m31, m32){
  return this.transform('matrix(' + [m11,m12,m21,m22,m31,m32].join(',') + ')');
};

/**
 * Scale y axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleY = function(n){
  return this.transform('scaleY(' + n + ')')
};

/**
 * Rotate `n` degrees.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.rotate = function(n){
  return this.transform('rotate(' + n + 'deg)');
};

/**
 * Set transition easing function to to `fn` string.
 *
 * When:
 *
 *   - null "ease" is used
 *   - "in" "ease-in" is used
 *   - "out" "ease-out" is used
 *   - "in-out" "ease-in-out" is used
 *
 * @param {String} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.ease = function(fn){
  fn = ease[fn] || fn || 'ease';
  return this.setVendorProperty('transition-timing-function', fn);
};

/**
 * Set animation properties
 *
 * @param {String} name
 * @param {Object} props
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.animate = function(name, props){
  for (var i in props){
    if (props.hasOwnProperty(i)){
      this.setVendorProperty('animation-' + i, props[i])
    }
  }
  return this.setVendorProperty('animation-name', name);
}

/**
 * Set duration to `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.duration = function(n){
  n = this._duration = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-duration', n + 'ms');
};

/**
 * Delay the animation by `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.delay = function(n){
  n = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-delay', n + 'ms');
};

/**
 * Set `prop` to `val`, deferred until `.end()` is invoked.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setProperty = function(prop, val){
  this._props[prop] = val;
  return this;
};

/**
 * Set a vendor prefixed `prop` with the given `val`.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setVendorProperty = function(prop, val){
  this.setProperty('-webkit-' + prop, val);
  this.setProperty('-moz-' + prop, val);
  this.setProperty('-ms-' + prop, val);
  this.setProperty('-o-' + prop, val);
  return this;
};

/**
 * Set `prop` to `value`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.set = function(prop, val){
  this.transition(prop);
  this._props[prop] = val;
  return this;
};

/**
 * Increment `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.add = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr + val + 'px');
  });
};

/**
 * Decrement `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.sub = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr - val + 'px');
  });
};

/**
 * Get computed or "current" value of `prop`.
 *
 * @param {String} prop
 * @return {String}
 * @api public
 */

Move.prototype.current = function(prop){
  return style(this.el).getPropertyValue(prop);
};

/**
 * Add `prop` to the list of internal transition properties.
 *
 * @param {String} prop
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transition = function(prop){
  if (!this._transitionProps.indexOf(prop)) return this;
  this._transitionProps.push(prop);
  return this;
};

/**
 * Commit style properties, aka apply them to `el.style`.
 *
 * @return {Move} for chaining
 * @see Move#end()
 * @api private
 */

Move.prototype.applyProperties = function(){
  for (var prop in this._props) {
    this.el.style.setProperty(prop, this._props[prop], '');
  }
  return this;
};

/**
 * Re-select element via `selector`, replacing
 * the current element.
 *
 * @param {String} selector
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.move =
Move.prototype.select = function(selector){
  this.el = Move.select(selector);
  return this;
};

/**
 * Defer the given `fn` until the animation
 * is complete. `fn` may be one of the following:
 *
 *   - a function to invoke
 *   - an instanceof `Move` to call `.end()`
 *   - nothing, to return a clone of this `Move` instance for chaining
 *
 * @param {Function|Move} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.then = function(fn){
  // invoke .end()
  if (fn instanceof Move) {
    this.on('end', function(){
      fn.end();
    });
  // callback
  } else if ('function' == typeof fn) {
    this.on('end', fn);
  // chain
  } else {
    var clone = new Move(this.el);
    clone._transforms = this._transforms.slice(0);
    this.then(clone);
    clone.parent = this;
    return clone;
  }

  return this;
};

/**
 * Pop the move context.
 *
 * @return {Move} parent Move
 * @api public
 */

Move.prototype.pop = function(){
  return this.parent;
};

/**
 * Reset duration.
 *
 * @return {Move}
 * @api public
 */

Move.prototype.reset = function(){
  this.el.style.webkitTransitionDuration =
  this.el.style.mozTransitionDuration =
  this.el.style.msTransitionDuration =
  this.el.style.oTransitionDuration = '';
  return this;
};

/**
 * Start animation, optionally calling `fn` when complete.
 *
 * @param {Function} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.end = function(fn){
  var self = this;

  // emit "start" event
  this.emit('start');

  // transforms
  if (this._transforms.length) {
    this.setVendorProperty('transform', this._transforms.join(' '));
  }

  // transition properties
  this.setVendorProperty('transition-properties', this._transitionProps.join(', '));
  this.applyProperties();

  // callback given
  if (fn) this.then(fn);

  // emit "end" when complete
  after.once(this.el, function(){
    self.reset();
    self.emit('end');
  });

  return this;
};

},{"after-transition":4,"component-emitter":1,"component-query":8,"css-ease":9,"has-translate3d":10}],4:[function(require,module,exports){
var hasTransitions = require('has-transitions');
var emitter = require('css-emitter');

function afterTransition(el, callback) {
  if(hasTransitions(el)) {
    return emitter(el).bind(callback);
  }
  return callback.apply(el);
};

afterTransition.once = function(el, callback) {
  afterTransition(el, function fn(){
    callback.apply(el);
    emitter(el).unbind(fn);
  });
};

module.exports = afterTransition;
},{"css-emitter":5,"has-transitions":7}],5:[function(require,module,exports){
/**
 * Module Dependencies
 */

var events = require('event');

// CSS events

var watch = [
  'transitionend'
, 'webkitTransitionEnd'
, 'oTransitionEnd'
, 'MSTransitionEnd'
, 'animationend'
, 'webkitAnimationEnd'
, 'oAnimationEnd'
, 'MSAnimationEnd'
];

/**
 * Expose `CSSnext`
 */

module.exports = CssEmitter;

/**
 * Initialize a new `CssEmitter`
 *
 */

function CssEmitter(element){
  if (!(this instanceof CssEmitter)) return new CssEmitter(element);
  this.el = element;
}

/**
 * Bind CSS events.
 *
 * @api public
 */

CssEmitter.prototype.bind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.bind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Unbind CSS events
 * 
 * @api public
 */

CssEmitter.prototype.unbind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.unbind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Fire callback only once
 * 
 * @api public
 */

CssEmitter.prototype.once = function(fn){
  var self = this;
  function on(){
    self.unbind(on);
    fn.apply(self.el, arguments);
  }
  self.bind(on);
  return this;
};


},{"event":6}],6:[function(require,module,exports){

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  if (el.addEventListener) {
    el.addEventListener(type, fn, capture);
  } else {
    el.attachEvent('on' + type, fn);
  }
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  if (el.removeEventListener) {
    el.removeEventListener(type, fn, capture);
  } else {
    el.detachEvent('on' + type, fn);
  }
  return fn;
};

},{}],7:[function(require,module,exports){
/**
 * This will store the property that the current
 * browser uses for transitionDuration
 */
var property;

/**
 * The properties we'll check on an element
 * to determine if it actually has transitions
 * We use duration as this is the only property
 * needed to technically have transitions
 * @type {Array}
 */
var types = [
  "transitionDuration",
  "MozTransitionDuration",
  "webkitTransitionDuration"
];

/**
 * Determine the correct property for this browser
 * just once so we done need to check every time
 */
while(types.length) {
  var type = types.shift();
  if(type in document.body.style) {
    property = type;
  }
}

/**
 * Determine if the browser supports transitions or
 * if an element has transitions at all.
 * @param  {Element}  el Optional. Returns browser support if not included
 * @return {Boolean}
 */
function hasTransitions(el){
  if(!property) {
    return false; // No browser support for transitions
  }
  if(!el) {
    return property != null; // We just want to know if browsers support it
  }
  var duration = getComputedStyle(el)[property];
  return duration !== "" && parseFloat(duration) !== 0; // Does this element have transitions?
}

module.exports = hasTransitions;
},{}],8:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],9:[function(require,module,exports){

/**
 * CSS Easing functions
 */

module.exports = {
    'in':                'ease-in'
  , 'out':               'ease-out'
  , 'in-out':            'ease-in-out'
  , 'snap':              'cubic-bezier(0,1,.5,1)'
  , 'linear':            'cubic-bezier(0.250, 0.250, 0.750, 0.750)'
  , 'ease-in-quad':      'cubic-bezier(0.550, 0.085, 0.680, 0.530)'
  , 'ease-in-cubic':     'cubic-bezier(0.550, 0.055, 0.675, 0.190)'
  , 'ease-in-quart':     'cubic-bezier(0.895, 0.030, 0.685, 0.220)'
  , 'ease-in-quint':     'cubic-bezier(0.755, 0.050, 0.855, 0.060)'
  , 'ease-in-sine':      'cubic-bezier(0.470, 0.000, 0.745, 0.715)'
  , 'ease-in-expo':      'cubic-bezier(0.950, 0.050, 0.795, 0.035)'
  , 'ease-in-circ':      'cubic-bezier(0.600, 0.040, 0.980, 0.335)'
  , 'ease-in-back':      'cubic-bezier(0.600, -0.280, 0.735, 0.045)'
  , 'ease-out-quad':     'cubic-bezier(0.250, 0.460, 0.450, 0.940)'
  , 'ease-out-cubic':    'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
  , 'ease-out-quart':    'cubic-bezier(0.165, 0.840, 0.440, 1.000)'
  , 'ease-out-quint':    'cubic-bezier(0.230, 1.000, 0.320, 1.000)'
  , 'ease-out-sine':     'cubic-bezier(0.390, 0.575, 0.565, 1.000)'
  , 'ease-out-expo':     'cubic-bezier(0.190, 1.000, 0.220, 1.000)'
  , 'ease-out-circ':     'cubic-bezier(0.075, 0.820, 0.165, 1.000)'
  , 'ease-out-back':     'cubic-bezier(0.175, 0.885, 0.320, 1.275)'
  , 'ease-out-quad':     'cubic-bezier(0.455, 0.030, 0.515, 0.955)'
  , 'ease-out-cubic':    'cubic-bezier(0.645, 0.045, 0.355, 1.000)'
  , 'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'
  , 'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'
  , 'ease-in-out-sine':  'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
  , 'ease-in-out-expo':  'cubic-bezier(1.000, 0.000, 0.000, 1.000)'
  , 'ease-in-out-circ':  'cubic-bezier(0.785, 0.135, 0.150, 0.860)'
  , 'ease-in-out-back':  'cubic-bezier(0.680, -0.550, 0.265, 1.550)'
};

},{}],10:[function(require,module,exports){

var prop = require('transform-property');

// IE <=8 doesn't have `getComputedStyle`
if (!prop || !window.getComputedStyle) {
  module.exports = false;

} else {
  var map = {
    webkitTransform: '-webkit-transform',
    OTransform: '-o-transform',
    msTransform: '-ms-transform',
    MozTransform: '-moz-transform',
    transform: 'transform'
  };

  // from: https://gist.github.com/lorenzopolidori/3794226
  var el = document.createElement('div');
  el.style[prop] = 'translate3d(1px,1px,1px)';
  document.body.insertBefore(el, null);
  var val = getComputedStyle(el).getPropertyValue(map[prop]);
  document.body.removeChild(el);
  module.exports = null != val && val.length && 'none' != val;
}

},{"transform-property":11}],11:[function(require,module,exports){

var styles = [
  'webkitTransform',
  'MozTransform',
  'msTransform',
  'OTransform',
  'transform'
];

var el = document.createElement('p');
var style;

for (var i = 0; i < styles.length; i++) {
  style = styles[i];
  if (null != el.style[style]) {
    module.exports = style;
    break;
  }
}

},{}],12:[function(require,module,exports){
/*

*/
exports.Transform = require('./lib/Transform');
exports.estimateT = require('./lib/estimateT');
exports.estimateS = require('./lib/estimateS');
exports.estimateR = require('./lib/estimateR');
exports.estimateTS = require('./lib/estimateTS');
exports.estimateTR = require('./lib/estimateTR');
exports.estimateSR = require('./lib/estimateSR');
exports.estimateTSR = require('./lib/estimateTSR');
exports.version = require('./lib/version');

exports.estimate = function (type, domain, range, pivot) {
  // Parameter
  //   type
  //     string. One of the following: 'T', 'S', 'R', 'TS', 'TR', 'SR', 'TSR'
  //   domain
  //     array of 2d arrays
  //   range
  //     array of 2d arrays
  //   pivot
  //     optional 2d array, does nothing for translation estimators
  var name = 'estimate' + type.toUpperCase();
  if (exports.hasOwnProperty(name)) {
    return exports[name](domain, range, pivot);
  } // else
  throw new Error('Unknown estimator type: ' + type);
};

},{"./lib/Transform":13,"./lib/estimateR":14,"./lib/estimateS":15,"./lib/estimateSR":16,"./lib/estimateT":17,"./lib/estimateTR":18,"./lib/estimateTS":19,"./lib/estimateTSR":20,"./lib/version":21}],13:[function(require,module,exports){

var Transform = function (s, r, tx, ty) {

  // Public, to allow user access
  this.s = s;
  this.r = r;
  this.tx = tx;
  this.ty = ty;

  this.equals = function (t) {
    return (s === t.s && r === t.r && tx === t.tx && ty === t.ty);
  };

  this.transform = function (p) {
    // p
    //   point [x, y] or array of points [[x1,y1], [x2, y2], ...]

    if (typeof p[0] === 'number') {
      // Single point
      return [s * p[0] - r * p[1] + tx, r * p[0] + s * p[1] + ty];
    } // else

    var i, c = [];
    for (i = 0; i < p.length; i += 1) {
      c.push([s * p[i][0] - r * p[i][1] + tx, r * p[i][0] + s * p[i][1] + ty]);
    }
    return c;
  };

  this.getMatrix = function () {
    // Get the transformation matrix in the format common to
    // many APIs, including:
    // - kld-affine
    //
    // Return
    //   object o, having properties a, b, c, d, e, f:
    //   [ s  -r  tx ]   [ o.a  o.c  o.e ]
    //   [ r   s  ty ] = [ o.b  o.d  o.f ]
    //   [ 0   0   1 ]   [  -    -    -  ]
    return { a: s, b: r, c: -r, d: s, e: tx, f: ty };
  };

  this.getRotation = function () {
    // in rads
    return Math.atan2(r, s);
  };

  this.getScale = function () {
    // scale multiplier
    return Math.sqrt(r * r + s * s);
  };

  this.getTranslation = function () {
    return [tx, ty];
  };

  this.inverse = function () {
    // Return inversed transform instance
    // See note 2015-10-26-16-30
    var det = s * s + r * r;
    // Test if singular transformation. These might occur when all the range
    // points are the same, forcing the scale to drop to zero.
    var eps = 0.00000001;
    if (Math.abs(det) < eps) {
      throw new Error('Singular transformations cannot be inversed.');
    }
    var shat = s / det;
    var rhat = -r / det;
    var txhat = (-s * tx - r * ty) / det;
    var tyhat = ( r * tx - s * ty) / det;
    return new Transform(shat, rhat, txhat, tyhat);
  };

  this.translateBy = function (dx, dy) {
    return new Transform(s, r, tx + dx, ty + dy);
  };

  this.scaleBy = function (multiplier, pivot) {
    // Parameter
    //   multiplier
    //   pivot
    //     optional, a [x, y] point
    var m, x, y;
    m = multiplier; // alias
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    return new Transform(m * s, m * r, m * tx + (1-m) * x, m * ty + (1-m) * y);
  };

  this.rotateBy = function (radians, pivot) {
    // Parameter
    //   radians
    //     from positive x to positive y axis
    //   pivot
    //     optional, a [x, y] point
    var co, si, x, y, shat, rhat, txhat, tyhat;
    co = Math.cos(radians);
    si = Math.sin(radians);
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    shat = s * co - r * si;
    rhat = s * si + r * co;
    txhat = (tx - x) * co - (ty - y) * si + x;
    tyhat = (tx - x) * si + (ty - y) * co + y;
    return new Transform(shat, rhat, txhat, tyhat);
  };


  this.multiplyBy = function (transform) {
    // Multiply this transformation matrix A
    // from the right with the given transformation matrix B
    // and return the result AB

    // For reading aid:
    // s -r tx  t.s -r tx
    // r  s ty *  r  s ty
    // 0  0  1    0  0  1
    var t = transform; // alias
    var shat = s * t.s - r * t.r;
    var rhat = s * t.r + r * t.s;
    var txhat = s * t.tx - r * t.ty + tx;
    var tyhat = r * t.tx + s * t.ty + ty;
    return new Transform(shat, rhat, txhat, tyhat);
  };
};

Transform.IDENTITY = new Transform(1, 0, 0, 0);

module.exports = Transform;

},{}],14:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, ad, bc, bd, shat, rhat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = ad = bc = bd = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  p = ac + bd;
  q = ad - bc;

  D = Math.sqrt(p * p + q * q);

  if (D === 0) {
    // D === 0
    // <=> q === 0 and p === 0.
    // <=> ad === bc and ac === -bd
    // <=> domain in pivot OR range in pivot OR yet unknown cases
    //     where the angle cannot be determined.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  shat = p / D;
  rhat = q / D;
  tx = a0 - a0 * shat + b0 * rhat;
  ty = b0 - a0 * rhat - b0 * shat;

  return new Transform(shat, rhat, tx, ty);
};

},{"./Transform":13}],15:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, bd, aa, bb, shat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = bd = aa = bb = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    bd += b * d;
    aa += a * a;
    bb += b * b;
  }

  D = aa + bb;

  if (D === 0) {
    // All domain points equal the pivot.
    // Identity transform is then only solution.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  // Prevent negative scaling because it would be same as positive scaling
  // and rotation => limit to zero
  shat = Math.max(0, (ac + bd) / D);
  tx = (1 - shat) * a0;
  ty = (1 - shat) * b0;

  return new Transform(shat, 0, tx, ty);
};

},{"./Transform":13}],16:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  // Estimate optimal transformation given the domain and the range
  // so that the pivot point remains the same.
  //
  // Use cases
  //   - transform an image that has one corner fixed with a pin.
  //   - allow only scale and rotation by fixing the middle of the object
  //     to transform.
  //
  // Parameters
  //   domain, an array of [x, y] points
  //   range, an array of [x, y] points
  //   pivot, optional
  //     the point [x, y] that must remain constant in the tranformation.
  //     Defaults to origo [0, 0]
  //
  //
  var X, Y, N, s, r, tx, ty;

  // Optional pivot
  if (typeof pivot === 'undefined') {
    pivot = [0, 0];
  }

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  var v = pivot[0];
  var w = pivot[1];

  var i, a, b, c, d;
  var a2, b2;
  a2 = b2 = 0;
  var ac, bd, bc, ad;
  ac = bd = bc = ad = 0;

  for (i = 0; i < N; i += 1) {
    a = X[i][0] - v;
    b = X[i][1] - w;
    c = Y[i][0] - v;
    d = Y[i][1] - w;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
    bc += b * c;
    ad += a * d;
  }

  // Denominator = determinant.
  // It becomes zero iff N = 0 or X[i] = [v, w] for every i in [0, n).
  // In other words, iff all the domain points are under the fixed point or
  // there is no domain points.
  var den = a2 + b2;

  var eps = 0.00000001;
  if (Math.abs(den) < eps) {
    // The domain points are under the pivot or there is no domain points.
    // We assume identity transform be the simplest guess. It keeps
    // the domain points under the pivot if there is some.
    return new Transform(1, 0, 0, 0);
  }

  // Estimators
  s = (ac + bd) / den;
  r = (-bc + ad) / den;
  tx =  w * r - v * s + v;
  ty = -v * r - w * s + w;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],17:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  var i, N, a1, b1, c1, d1, txhat, tyhat;

  N = Math.min(domain.length, range.length);
  a1 = b1 = c1 = d1 = 0;

  if (N < 1) {
    // Assume identity transform be the best guess
    return Transform.IDENTITY;
  }

  for (i = 0; i < N; i += 1) {
    a1 += domain[i][0];
    b1 += domain[i][1];
    c1 += range[i][0];
    d1 += range[i][1];
  }

  txhat = (c1 - a1) / N;
  tyhat = (d1 - b1) / N;

  return new Transform(1, 0, txhat, tyhat);
};

},{"./Transform":13}],18:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, ac, ad, bc, bd;
  a1 = b1 = c1 = d1 = ac = ad = bc = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  // Denominator.
  var v = N * (ad - bc) - a1 * d1 + b1 * c1;
  var w = N * (ac + bd) - a1 * c1 - b1 * d1;
  var D = Math.sqrt(v * v + w * w);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> undecidable
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 - a1) / N, (d1 - b1) / N);
  }

  // Estimators
  var shat = w / D;
  var rhat = v / D;
  var txhat = (-a1 * shat + b1 * rhat + c1) / N;
  var tyhat = (-a1 * rhat - b1 * shat + d1) / N;

  return new Transform(shat, rhat, txhat, tyhat);
};

},{"./Transform":13}],19:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, a2, b2, ac, bd;
  a1 = b1 = c1 = d1 = a2 = b2 = ac = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  var N2 = N * N;
  var a12 = a1 * a1;
  var b12 = b1 * b1;
  var p = a2 + b2;
  var q = ac + bd;
  var D = N2 * p - N * (a12 + b12);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> all the domain points are the same
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  var shat = (N2 * q - N * (a1 * c1 + b1 * d1)) / D;
  var txhat = (-N * a1 * q + N * c1 * p - b12 * c1 + a1 * b1 * d1) / D;
  var tyhat = (-N * b1 * q + N * d1 * p - a12 * d1 + a1 * b1 * c1) / D;

  return new Transform(shat, 0, txhat, tyhat);
};

},{"./Transform":13}],20:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays
  var X, Y, N, s, r, tx, ty;

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  // If length is zero, no estimation can be done. We choose the indentity
  // transformation be the best quess.
  if (N === 0) {
    return new Transform(1, 0, 0, 0);
  } // else

  var i, a, b, c, d;
  var a1 = 0;
  var b1 = 0;
  var c1 = 0;
  var d1 = 0;
  var a2 = 0;
  var b2 = 0;
  var ad = 0;
  var bc = 0;
  var ac = 0;
  var bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ad += a * d;
    bc += b * c;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  // It is zero iff X[i] = X[j] for every i and j in [0, n).
  // In other words, iff all the domain points are the same or there is only one domain point.
  var den = N * a2 + N * b2 - a1 * a1 - b1 * b1;

  var eps = 0.00000001;
  if (-eps < den && den < eps) {
    // The domain points are the same.
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  s = (N * (ac + bd) - a1 * c1 - b1 * d1) / den;
  r = (N * (ad - bc) + b1 * c1 - a1 * d1) / den;
  tx = (-a1 * (ac + bd) + b1 * (ad - bc) + a2 * c1 + b2 * c1) / den;
  ty = (-b1 * (ac + bd) - a1 * (ad - bc) + a2 * d1 + b2 * d1) / den;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],21:[function(require,module,exports){
module.exports = '1.0.1';

},{}],22:[function(require,module,exports){
"use strict";

module.exports = SeqId

function SeqId(initial) {
  if (!(this instanceof SeqId)) {
    return new SeqId(initial)
  }
  if (initial == null) {
    initial = (Math.random() - 0.5) * Math.pow(2, 32)
  }
  this._id = initial | 0
}
SeqId.prototype.next = function () {
  this._id = (this._id + 1) | 0
  return this._id
}

},{}],23:[function(require,module,exports){
/*

View

*/
var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');
var SpaceTaa = require('./SpaceTaa');
var SpaceHTML = require('./SpaceHTML');
var move = require('movejs');

// Disable animations by default.
move.defaults = { duration: 0 };

var HTMLSpaceView = function (space, htmlContainer) {
  // Test if valid dom element
  if (!('tagName' in htmlContainer)) {
    throw 'Container should be a DOM Element';
  }

  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);
  var this2 = this;

  this._el = htmlContainer;

  // Two mappings from space taa ids:
  // 1. to HTML elements of the space nodes.
  // 2. to SpaceNode instances
  // Dev decision:
  //   For data structure, dict over list because key search time complexity.
  this._elements = {};
  this._nodes = {};

  (function initSize() {
    var w = this2._el.clientWidth;
    var h = this2._el.clientHeight;
    this2.resize([w, h]);
  }());

  var transformNode = function (htmlElement, spaceNode) {
    // Transform elements because the view orientation.
    // See 2016-03-05-09 for math.
    var node_global_T = spaceNode.getGlobalTransform();
    var T = this2._T.inverse().multiplyBy(node_global_T);
    // TODO What if view parent is not the root?
    //   Solution: getTransformTo(plane)
    // TODO Current move.js does not prevent scientific notation reaching CSS
    // which leads to problems with Safari and Opera. Therefore we must
    // prevent the notation here.
    // Of course this will cause error in the presentation.
    // However the error is only in the presentation and thus not a problem.
    var prec = 8;
    var s = T.s.toFixed(prec);
    var r = T.r.toFixed(prec);
    var tx = T.tx.toFixed(prec);
    var ty = T.ty.toFixed(prec);
    move(htmlElement).matrix(s, r,-r, s, tx, ty).end();
  };

  var getViewSpecificId = function (spaceNodeId) {
    // Each rendered element has own ID. The ID differs from
    // the id of space nodes because a space node can become
    // visualized through multiple views.
    return this2.id + '/' + spaceNodeId;
  };

  // Listen the space for new or removed taas or transformations

  var contentAddedHandler = function (spaceNode, newParent, oldParent) {
    // Parameters:
    //   spaceNode: a SpaceNode i.e. the content unit that was added.
    //   newParent: optional. The new parent of the SpaceNode
    //     Not used for anything for now but probably in the future.
    //   oldParent: optional. The old parent of the SpaceNode.
    //     Not used for anything for now but probably in the future.
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var node, el, wh;

    // SpaceView, SpaceTaa ...
    node = spaceNode;

    if (this2._elements.hasOwnProperty(node.id)) {
      // Content is already drawn.
    } else {
      if (node instanceof SpaceTaa) {
        el = new Image(256, 256);
        el.src = node.taa.image.src;
        el.id = getViewSpecificId(node.id);
        el.className = 'taaspace-taa';
        // Show to client
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[node.id] = el;
        this2._nodes[node.id] = node;
        // Make transformation
        transformNode(el, node);
      } else if (node instanceof SpaceHTML) {
        // Create container div.
        el = document.createElement('div');
        el.innerHTML = node.html;
        el.id = getViewSpecificId(node.id);
        el.className = 'taaspace-html';
        // Resize, and let taaspace styles do the rest.
        wh = node.getSize();
        el.style.width = wh[0] + 'px';
        el.style.height = wh[1] + 'px';
        // TODO react to size change
        // on resize reset the style.width and style.height
        node.on('resized', function () {
          // TODO remove listener
          var wh = node.getSize();
          el.style.width = wh[0] + 'px';
          el.style.height = wh[1] + 'px';
        });
        // Render
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[node.id] = el;
        this2._nodes[node.id] = node;
        // Make transformation
        transformNode(el, node);
      } else if (node instanceof HTMLSpaceView) {
        // No representation for views.
      } else {
        throw new Exception('Unknown SpaceNode subtype; cannot represent');
      }
    }
  };

  var contentRemovedHandler = function (spaceNode, oldParent, newParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot, el, node;

    node = spaceNode; // Alias

    // Decide sameRoot
    if (oldParent === null || newParent === null) {
      sameRoot = false;
    } else {
      sameRoot = oldParent.getRootParent() === newParent.getRootParent();
    }

    if (sameRoot) {
      // No reason to remove and then add again.
    } else {
      // New parent in different space, so not displayed in this view anymore.
      if (this2._elements.hasOwnProperty(node.id)) {
        // Remove HTML element
        el = this2._elements[node.id];
        this2._el.removeChild(el);
        // Remove from memory.
        // JS feature of delete: does not throw if key does not exist
        delete this2._elements[node.id];
        delete this2._nodes[node.id];
      }
    }

  };

  var contentTransformedHandler = function (spaceNode) {
    // Update css transformation.
    // If the node has children, they must also be transformed.
    var nodes, i, node, el;
    nodes = spaceNode.getAllChildren();
    nodes.push(spaceNode);

    for (i = 0; i < nodes.length; i += 1) {
      node = nodes[i];
      if (this2._elements.hasOwnProperty(node.id)) {
        if (node instanceof SpaceTaa) {
          el = this2._elements[node.id];
          // Make transformation
          transformNode(el, node);
        } else if (node instanceof SpaceHTML) {
          el = this2._elements[node.id];
          transformNode(el, node);
        }
        // Else: no transformable representation for Views.
      }
    }
  };

  // View added to new parent.
  this.on('added', function (self, newParent) {
    // TODO add content of the new space if the space contains
    // nodes.
    newParent.on('contentAdded', contentAddedHandler);
    newParent.on('contentRemoved', contentRemovedHandler);
    newParent.on('contentTransformed', contentTransformedHandler);
  });
  // View removed from parent.
  this.on('removed', function (self, oldParent) {
    // TODO remove content of the old space.
    oldParent.off('contentAdded', contentAddedHandler);
    oldParent.off('contentRemoved', contentRemovedHandler);
    oldParent.off('contentTransformed', contentTransformedHandler);
  });

  // If the view is transformed, we of course need to retransform everything.
  this.on('transformed', function () {
    var id, element, node;
    for (id in this2._elements) {
      if (this2._elements.hasOwnProperty(id)) {
        element  = this2._elements[id];
        node = this2._nodes[id];
        transformNode(element, node);
      }
    }
  });

  this.getElementBySpaceNode = function (spaceNode) {
    // Get HTML element representation of the space taa.
    if (this._elements.hasOwnProperty(spaceNode.id)) {
      return this._elements[spaceNode.id];
    }
  };

  this.getSpaceNodeByElementId = function (id) {
    // Get space taa by HTML element id
    // Return null if no space taa for such id.
    var i = id.split('/');
    var spaceViewId = i[0];
    var spaceNodeId = i[1];
    if (this.id === spaceViewId) {
      if (this._nodes.hasOwnProperty(spaceNodeId)) {
        return this._nodes[spaceNodeId];
      }
    }
    return null;
  };

  this.getRootElement = function () {
    return this._el;
  };

  // View ready to be added to Space.
  this.setParent(space);
};

module.exports = HTMLSpaceView;

},{"./SpaceHTML":25,"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./SpaceTaa":30,"./Transformer":33,"component-emitter":1,"movejs":3}],24:[function(require,module,exports){
/*
Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
  contentTransformed
*/
var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');

var Space = function () {
  Emitter(this);

  SpaceNode(this);
  // TODO remove possibility to add to parent.

  SpacePlane(this);
  // Space has constant identity transformation _T
};

module.exports = Space;

},{"./SpaceNode":26,"./SpacePlane":27,"component-emitter":1}],25:[function(require,module,exports){
/*
# SpaceElement

A HTMLElement [1] in the space.

[1] https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
*/

var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceHTML = function (parent, html) {
  // Parameters:
  //   parent:
  //     a SpaceNode
  //   html:
  //     a string, containing html
  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);

  this.html = html;
  this.resize([256, 256]);  // Initial element size.

  this.setParent(parent);
};

module.exports = SpaceHTML;

},{"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./Transformer":33,"component-emitter":1}],26:[function(require,module,exports){
/*
Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
  contentTransformed
*/
var Emitter = require('component-emitter');

// Unique ID generator. Unique over session.
// Usage: seqid.next()
// Return: int
var seqid = require('seqid')(0);

var SpaceNode = function (emitter) {
  // Parameters
  //   emitter, an Emitter.

  // Each node has an id. That is used by the parent nodes and in views.
  emitter.id = seqid.next().toString();

  // Nodes with null parent are root nodes i.e. spaces.
  // SpaceNode#remove sets _parent to null.
  emitter._parent = null;

  // Dict over list because key search time complexity
  emitter._children = {};

  // We need to store built handlers bound to children
  // to be able to remove the handlers when child is removed.
  emitter._addedHandlers = {};
  emitter._removedHandlers = {};
  emitter._transformedHandlers = {};

  emitter.has = function (spaceNode) {
    // Return
    //   true if spacetaa in space
    return spaceNode._parent === this;
  };

  emitter.getParent = function () {
    return this._parent;
  };

  emitter.getRootParent = function () {
    if (this._parent === null) {
      return this;
    } // else
    return this._parent.getRootParent();
  };

  emitter.getChildren = function () {
    // Return child SpaceNodes in a list.
    // Does not include the children of the children.
    var id, arr, obj;
    arr = [];
    obj = this._children;
    for (id in obj) {
      arr.push(obj[id]);
    }
    return arr;
  };

  emitter.getAllChildren = function () {
    // All descendants in a list, including the children.
    var i, children, child, arr;
    arr = [];
    children = this.getChildren();
    for (i = 0; i < children.length; i += 1) {
      child = children[i];
      arr = arr.concat(child, child.getAllChildren());
    }
    return arr;
  };

  emitter.setParent = function (newParent) {
    // Add to new parent.

    var oldParent = this._parent;

    if (oldParent === null) {
      if (newParent === null) {
        // From root to root.
        // Do nothing
      } else {
        // From root to child.
        this._parent = newParent;
        this._parent._addChild(this);
        this.emit('added', this, this._parent, null);
        newParent.emit('contentAdded', this, this._parent, null);
      }
    } else {
      if (newParent === null) {
        // From child to root.
        this._parent = null; // Becomes new root node.
        oldParent._removeChild(this);
        this.emit('removed', this, oldParent, null);
        oldParent.emit('contentRemoved', this, oldParent, null);
      } else {
        // From child to child.
        this._parent = newParent;
        oldParent._removeChild(this);
        newParent._addChild(this);
        this.emit('removed', this, oldParent, newParent);
        this.emit('added', this, newParent, oldParent);
        // With both oldParent and newParent, SpaceView is able to
        // decide whether to keep same HTMLElement or recreate it.
        oldParent.emit('contentRemoved', this, oldParent, newParent);
        newParent.emit('contentAdded', this, newParent, oldParent);
      }
    }

  };

  emitter.remove = function () {
    // Remove this space node from its parent.
    // Return: see setParent
    return this.setParent(null);
  };

  emitter._addChild = function (child) {
    // To be called from child.setParent().
    //
    // Parameters
    //   child, A SpaceNode
    //
    // Return
    //   undefined
    //
    // Dev. note:
    //   Previously this was called from the SpaceNode constructor.
    //   However, because SpaceNode upgrade is done before other
    //   upgrades, the child would not be ready to be added to parent.

    var sc = child; // alias
    var self = this;

    this._children[sc.id] = sc;

    // Start to listen if child has beed added, removed or transformed
    var addedHandler = function (a, b, c) {
      self.emit('contentAdded', a, b, c);
    };
    var removedHandler = function (a, b, c) {
      self.emit('contentRemoved', a, b, c);
    };
    var transformedHandler = function (a, b, c) {
      self.emit('contentTransformed', a, b, c);
    };
    // added and removed events are not listened because
    // for after successfully made add or remove,
    // contentAdded and contentRemoved are fired in setParent.
    sc.on('contentAdded', addedHandler);
    sc.on('contentRemoved', removedHandler);
    sc.on('transformed', transformedHandler);
    sc.on('contentTransformed', transformedHandler);
    this._addedHandlers[sc.id] = addedHandler;
    this._removedHandlers[sc.id] = removedHandler;
    this._transformedHandlers[sc.id] = transformedHandler;
  };

  emitter._removeChild = function (child) {
    // To be called from SpaceNode#remove
    // Precondition: child in space
    var sc, h;

    sc = child; // alias
    delete this._children[sc.id];

    // Remove handlers
    h = this._addedHandlers[sc.id];
    delete this._addedHandlers[sc.id];
    sc.off('contentAdded', h);

    h = this._removedHandlers[sc.id];
    delete this._removedHandlers[sc.id];
    sc.off('contentRemoved', h);

    h = this._transformedHandlers[sc.id];
    delete this._transformedHandlers[sc.id];
    sc.off('transformed', h);
    sc.off('contentTransformed', h);
  };
};

module.exports = SpaceNode;

},{"component-emitter":1,"seqid":22}],27:[function(require,module,exports){
/*
SpacePlane
API v0.6.0

A SpacePlane represents a coordinate system. It does not include
methods to transform the system. SpacePlane and Transformer are separated
because we want to have planes that cannot be transformed, as the Space.

*/

var nudged = require('nudged');
var SpacePoint = require('./SpacePoint');

var at = function (xy) {
  // Return
  //   A SpacePoint at (x,y) on the plane.
  if (xy.length !== 2) {  // DEBUG TODO remove this
    throw 'Invalid point, use array [x, y]';
  }
  return new SpacePoint(xy, this);  // Note: this === spaceNode
};

var SpacePlane = function (spaceNode) {
  // Parameters
  //   spaceNode
  //     A SpaceNode to monkey patch to SpacePlane

  // Coordinate transformation.
  // The transformation from the plane to the parent (space).
  // See 2016-03-05-09
  // Let:
  //   x_space, a point in space
  //   x_plane, a point on the plane.
  //   T, the coordinate transformation of the plane
  // Then:
  //   x_space = T * x_plane
  //
  // For Space, it is obviously the identity transform:
  //   x_space = T * x_space
  spaceNode._T = nudged.Transform.IDENTITY; // identity transformation

  spaceNode.at = at;

  spaceNode.getTransform = function () {
    // Local transform from plane to parent
    //
    // Return
    //   transformation from plane to parent, i.e.
    //     xy_parent = T * xy_plane
    // Needed when we want to store transformer's position for later use.
    return this._T;
  };

  spaceNode.getGlobalTransform = function () {
    // Return
    //   transformation from the plane to root container.
    //
    // Dev note:
    //   Local transformations go like:
    //     xy_parent = T_plane * xy_plane
    //     xy_parent_parent = T_parent * xy_parent
    //     ...
    //     xy_root = T_parent_parent..._parent * xy_parent_parent..._parent
    //   Therefore global transformation is:
    //     xy_root = T_parent_..._parent * ... * T_parent * T_plane * xy_plane
    if (this._parent === null) {
      // TODO maybe too far: this._parent._parent might be sufficient.
      return this._T;
    } // else
    return this._parent.getGlobalTransform().multiplyBy(this._T);
  };

  spaceNode.resetTransform = function () {
    // Become space. Called e.g. when plane is removed from parent.
    this._T = nudged.Transform.IDENTITY;
  };

};

module.exports = SpacePlane;

},{"./SpacePoint":28,"nudged":12}],28:[function(require,module,exports){
// API v0.6.0

var Transform = require('./Transform');

var SpacePoint = function (xy, reference) {
  // Example
  //   var p = taaspace.SpacePoint([x, y], taa);
  //
  // Parameter
  //   xy
  //     2D array
  //   reference
  //     a SpaceNode or SpacePoint
  //       an item in space, enabling coord projections.
  this.xy = xy;

  // The SpacePlane's transformation the xy are on.
  // Design note: at first, the references were SpacePlanes and not
  // transformations. But because a SpacePlane can move or be removed,
  // we chose only the transformation to be remembered.
  // Design note: later we found it would be convenient for debugging
  // to know where the point came from, which led to this._origin.
  // After that we found that in toSpace method, we would need reference
  // to space, although we only have implicit reference to its coords.
  // Therefore this._origin was dropped.

  if (reference.hasOwnProperty('getGlobalTransform')) {
    // Is a SpacePlane
    this._T = reference.getGlobalTransform();
  } else {
    // Is a SpacePoint
    this._T = reference._T;
  }
};

var proto = SpacePoint.prototype;


proto.offset = function (dx, dy) {
  // Create a new point nearby.
  //
  // Parameter
  //   dx
  //     Movement towards positive x
  //   dy
  //     ...
  var xy = [this.xy[0] + dx, this.xy[1] + dy];
  return new SpacePoint(xy, this);
};

proto.polarOffset = function (radius, radians) {
  // Create a new point moved by the polar coordinates
  var x = this.xy[0] + radius * Math.cos(radians);
  var y = this.xy[1] + radius * Math.sin(radians);
  return new SpacePoint([x, y], this);
};

proto.equals = function (point) {
  return (this.xy[0] === point.xy[0] &&
          this.xy[1] === point.xy[1] &&
          this._T.equals(point._T));
};

proto.to = function (target) {
  // Create a new SpacePoint at same location but on a
  // different SpacePlane.
  //
  // Parameter
  //   target, a SpacePlane or null.
  //
  // Implementation note (See 2016-03-05-09):
  //
  // First, compute coord. transf. B from the current plane
  // to the space:
  //   x_space = B * x_plane  <=>  x_plane = inv(B) * x_space
  //   B = plane._T
  // Second, let A be coord. transf. from the space to the target plane:
  //   x_target = A * x_space
  //   A = inv(target._T)
  // Therefore combined coord. transf. C from the curr. plane to the target:
  //   x_target = C * x_plane
  //   <=> A * x_space = C * inv(B) * x_space
  //   <=> A = C * inv(B)
  //   <=> C = AB
  //   <=> C = inv(target._T) * plane._T
  //

  if (target === null) {
    // target is the root node (space)
    return this.toSpace();
  }

  // Target's global transformation. This._T is already global.
  var target_gT = target.getGlobalTransform();

  if (target_gT.equals(this._T)) {
    return this;
  } // else
  var C = target_gT.inverse().multiplyBy(this._T);
  var xy_target = C.transform(this.xy);
  return new SpacePoint(xy_target, target);
};

proto.toSpace = function () {
  // Create a new SpacePoint at same location but represented on space coords.
  //
  // Implementation note:
  //   We already have coord. transf. from the current plane to the space:
  //     plane._T
  var xy_space = this._T.transform(this.xy);
  var space_mock = {'_T': Transform.IDENTITY};
  return new SpacePoint(xy_space, space_mock);
};

proto.transform = function (tr) {
  // Create a new point by transformation.
  //
  // Parameter
  //   tr
  //     a Transform
  var xy_hat = tr.transform(this.xy);
  return new SpacePoint(xy_hat, this);
};


module.exports = SpacePoint;

},{"./Transform":32}],29:[function(require,module,exports){
// API v0.6.0

var SpacePoint = require('./SpacePoint');

var SpaceRectangle = function (transformer) {

  var t = transformer;  // Alias

  // Rectangles have size.
  // In its own coordinates, rectangle's right bottom corner
  // is located at [width, height].
  // By default transformation, width 1 and height 1 equal to 1 space unit.
  var width = 1;
  var height = 1;

  t.resize = function (dimensions) {
    // Parameter
    //   dimensions, [width, height]
    width = dimensions[0];
    height = dimensions[1];

    this.emit('resized', t);
  };

  t.getSize = function () {
    return [width, height];
  };

  t.atNorm = function (xy) {
    // Return a SpacePoint by coordinates normalized about the size.
    // atNorm([1,0]) returns the point at the right upper corner.
    return new SpacePoint([width * xy[0], height * xy[1]], t);
  };

  t.atMid = function () {
    return new SpacePoint([width / 2, height / 2], t);
  };

  t.atMidN = function () {
    return new SpacePoint([width / 2, 0], t);
  };

  t.atMidW = function () {
    return new SpacePoint([0, height / 2], t);
  };

  t.atMidE = function () {
    return new SpacePoint([width, height / 2], t);
  };

  t.atMidS = function () {
    return new SpacePoint([width / 2, height], t);
  };

  t.atNW = function () {
    return new SpacePoint([0, 0], t);
  };

  t.atNE = function () {
    return new SpacePoint([width, 0], t);
  };

  t.atSW = function () {
    return new SpacePoint([0, height], t);
  };

  t.atSE = function () {
    return new SpacePoint([width, height], t);
  };

};

module.exports = SpaceRectangle;

},{"./SpacePoint":28}],30:[function(require,module,exports){
// API v0.6.0

var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var Transformer = require('./Transformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceTaa = function (parent, taa) {
  // Parameters:
  //   parent
  //     a SpaceNode
  //   taa
  //     a Taa
  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  Transformer(this);
  SpaceRectangle(this);

  this.taa = taa;
  this.resize([256, 256]);  // Size of taa.

  this.setParent(parent);
};

module.exports = SpaceTaa;

},{"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./Transformer":33,"component-emitter":1}],31:[function(require,module,exports){
// API v0.6.0
var Emitter = require('component-emitter');
var loadimages = require('loadimages');

var NOOP = function () {};

var Taa = function (imgSrc, onLoaded) {
  // Parameters
  //   imgSrc
  //   onLoaded(err, taa)
  //     optional, function (taa)
  Emitter(this);
  var this2 = this;

  // onLoaded is optional
  if (typeof onLoaded !== 'function') {
    onLoaded = NOOP;
  }

  // This object will be replaced by a real Image object but before that
  // src is needed in SpaceView.
  this.image = { src: imgSrc };

  // If the image is cached, the 'load' event of Image element is
  // fired instantly when calling loadimages. If we did not care
  // about this, the on('loaded', fn) listeners would experience
  // different execution order depending whether the images was
  // cached or not.
  var notCached = false;

  loadimages(imgSrc, function (err, image) {
    var emiterr, emittaa;
    if (err) {
      emiterr = err;
      emittaa = null;
    } else {
      this2.image = image;
      emiterr = null;
      emittaa = this2;
    }

    if (notCached) {
      this2.emit('loaded', emiterr, emittaa);
      onLoaded(emiterr, emittaa);
    } else {
      // Postpone emitting of the loaded event
      setTimeout(function () {
        this2.emit('loaded', emiterr, emittaa);
        onLoaded(emiterr, emittaa);
      }, 0);
    }
  });

  notCached = true;
};

module.exports = Taa;

},{"component-emitter":1,"loadimages":2}],32:[function(require,module,exports){
// API v0.6.0
var nudged = require('nudged');

// TODO
// monkeypatch "to(plane)"

module.exports = nudged.Transform;

},{"nudged":12}],33:[function(require,module,exports){
// API v0.6.0
var nudged = require('nudged');
var Transform = require('./Transform');
var SpacePoint = require('./SpacePoint');

var normalize = function (points, plane) {
  // Transform all the points onto the parent and
  // represent them in array [[x0,y0], [x1,y1], ...].
  //
  // Arguments:
  //   points, a single spacepoint or a list of spacepoints
  //   plane, a SpacePlane e.g. a SpaceTaa onto normalize.
  // Return:
  //   array of xy points in space.
  var i, p, np, normalized;

  if (!Array.isArray(points)) {
    // Single SpacePoint
    p = points;
    np = p.to(plane).xy;
    return [np];
  } // else
  normalized = [];
  for (i = 0; i < points.length; i += 1) {
    p = points[i];
    np = p.to(plane).xy;
    normalized.push(np);
  }
  return normalized;
};


var transformByEstimate = function (plane, type, domain, range, pivot) {
  // Types: T,S,R,TS,TR,SR,TSR (see nudged for further details)

  var normPivot;
  if (typeof pivot !== 'undefined') {
    normPivot = normalize(pivot, plane._parent)[0];
  }

  // Convert all SpacePoints onto the space and to arrays
  var normDomain = normalize(domain, plane._parent);
  var normRange = normalize(range, plane._parent);

  // Then compute optimal transformation in space
  var H_space = nudged.estimate(type, normDomain, normRange, normPivot);
  // See 2016-03-05-11:
  //   To apply transformation to a space object:
  //     T_hat = toParent(H) * T
  // Therefore:
  plane._T = H_space.multiplyBy(plane._T);

  // Notify especially view about transformation.
  plane.emit('transformed', plane);
};


var Transformer = function (plane) {
  //
  // Parameters
  //   plane
  //     a SpacePlane

  plane.setTransform = function (T) {
    // Needed when we whan to restore stored position, maybe after
    // modification.
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    this._T = T;
    this.emit('transformed', this);
  };

  plane.setGlobalTransform = function (T) {
    // Set local transform so that the global transform becomes the given T.
    //
    // Dev note:
    //   Given T is coord. transf. from the plane to root (space).
    //   So is this._T.
    //   current_glob_trans = parent_glob_trans * this_T
    //   new_glob_trans = parent_glob_trans * X
    //   <=> X = inv(parent_glob_trans) * new_glob_trans
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    var parent_global = this._parent.getGlobalTransform();
    this._T = parent_global.inverse().multiplyBy(T);
    this.emit('transformed', this);
  };

  plane.translate = function (domain, range) {
    // Move plane horizontally and vertically by example.
    //
    // Translate the plane so that after the translation, the domain points
    // would be as close to given range points as possible.
    //
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'T', domain, range);
  };

  plane.scale = function (pivot, multiplierOrDomain, range) {
    // Parameter
    //   pivot, a SpacePoint
    //   multiplier, the scale factor, > 0
    //  OR
    //   pivot
    //   domain
    //   range

    var useMultiplier = (typeof range === 'undefined');

    if (useMultiplier) {
      var normPivot = normalize(pivot, this._parent)[0];
      var multiplier = multiplierOrDomain;
      // Multiplier does not depend on plane.
      // We create a pivoted scaling transform on parent.
      var S_parent = Transform.IDENTITY.scaleBy(multiplier, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = S_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = multiplierOrDomain;
      transformByEstimate(this, 'S', domain, range, pivot);
    }
  };

  plane.rotate = function (pivot, radiansOrDomain, range) {
    // Parameter
    //   pivot
    //   radians
    //  OR
    //   pivot
    //   domain
    //   range

    var useRadians = (typeof range === 'undefined');

    if (useRadians) {
      var normPivot = normalize(pivot, this._parent)[0];
      var radians = radiansOrDomain;
      // Radians do not depend on plane.
      // We create a pivoted rotation transform on parent.
      var R_parent = Transform.IDENTITY.rotateBy(radians, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = R_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = radiansOrDomain;
      transformByEstimate(this, 'R', domain, range, pivot);
    }
  };

  plane.translateScale = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TS', domain, range);
  };

  plane.translateRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TR', domain, range);
  };

  plane.scaleRotate = function (pivot, domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'SR', domain, range, pivot);
  };

  plane.translateScaleRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TSR', domain, range);
  };

  // plane.translateAndScaleToFit, not sure if necessary for now

  plane.on('removed', function (self, oldParent, newParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot;
    if (newParent === null) {
      // Root nodes cannot move.
      this.resetTransform();
    } else {
      if (oldParent === null) {
        // Removed from null parent?
        throw new Exception('Cannot remove from null parent');
      } else {
        // Moved onto another parent.
        // Let us keep the location in space the same if possible.
        // It is possible only if the parents share same root i.e.
        // are in the same space.
        sameRoot = oldParent.getRootParent() === newParent.getRootParent();
        if (sameRoot) {
          // Keep the location.
          // Let
          //   OT be the old local coord. transformation.
          //   NT be the unknown new local coord. transf.
          //   OPGT be the global coord. transf. of old parent
          //   NPGT be the global coord. transf. of new parent
          // Now, we want to keep global transf. unchanged.
          //   OPGT * OT = NPGT * NT
          //   <=> NT = inv(NPGT) * OPGT * OT
          var opgt = oldParent.getGlobalTransform();
          var npgt = newParent.getGlobalTransform();
          var ot = this._T;
          var nt = npgt.inverse().multiplyBy(opgt).multiplyBy(ot);
          this._T = nt;
          this.emit('transformed', this); // TODO Is needed because inplace?
        } else {
          // In different space: reset
          this.resetTransform();
        }
        // Note: there could be a need to change parent with the same
        // local transformation. Not needed for now.
      }

    }
  });
};

module.exports = Transformer;

},{"./SpacePoint":28,"./Transform":32,"nudged":12}],34:[function(require,module,exports){

exports.Taa = require('./Taa');
exports.SpaceTaa = require('./SpaceTaa');
exports.SpaceHTML = require('./SpaceHTML');
exports.Space = require('./Space');
exports.HTMLSpaceView = require('./HTMLSpaceView');

exports.version = require('./version');

},{"./HTMLSpaceView":23,"./Space":24,"./SpaceHTML":25,"./SpaceTaa":30,"./Taa":31,"./version":35}],35:[function(require,module,exports){
module.exports = '3.0.0';

},{}]},{},[34])(34)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9hZGltYWdlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L25vZGVfbW9kdWxlcy9ldmVudC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL25vZGVfbW9kdWxlcy9oYXMtdHJhbnNpdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jb21wb25lbnQtcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jc3MtZWFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9ub2RlX21vZHVsZXMvdHJhbnNmb3JtLXByb3BlcnR5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL1RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUi5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlU1IuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVQuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVRSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvZXN0aW1hdGVUUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlVFNSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZXFpZC9zZXFpZC5qcyIsInNyYy9IVE1MU3BhY2VWaWV3LmpzIiwic3JjL1NwYWNlLmpzIiwic3JjL1NwYWNlSFRNTC5qcyIsInNyYy9TcGFjZU5vZGUuanMiLCJzcmMvU3BhY2VQbGFuZS5qcyIsInNyYy9TcGFjZVBvaW50LmpzIiwic3JjL1NwYWNlUmVjdGFuZ2xlLmpzIiwic3JjL1NwYWNlVGFhLmpzIiwic3JjL1RhYS5qcyIsInNyYy9UcmFuc2Zvcm0uanMiLCJzcmMvVHJhbnNmb3JtZXIuanMiLCJzcmMvaW5kZXguanMiLCJzcmMvdmVyc2lvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWRpbWFnZXMoaW1nU3JjcywgdGhlbikge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgaW1nU3Jjc1xuICAvLyAgICAgYXJyYXkgb2YgaW1hZ2Ugc291cmNlIHBhdGhzIE9SIHNpbmdsZSBzb3VyY2UgcGF0aCBzdHJpbmcuXG4gIC8vICAgdGhlbihlcnIsIGltZ0VsZW1lbnRzKVxuICAvLyAgICAgV2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHRoZSBpbWFnZXMgYXJlIGxvYWRlZC4gSWYgc3RyaW5nIHdhcyBnaXZlbixcbiAgLy8gICAgIGltZ0VsZW1lbnRzIGlzIGFuIEltYWdlIGluc3RlYWQgb2YgYXJyYXkgb2YgSW1hZ2VzLlxuXG4gIHZhciBudW1iZXJPZkltYWdlcywgc3RyaW5nR2l2ZW4sIHRoZXJlV2FzU3VjY2VzcywgdGhlcmVXYXNFcnJvciwgaW1ncztcbiAgdmFyIG9ubG9hZHNDYWxsZWQsIG9ubG9hZCwgb25lcnJvcjtcblxuICBpZiAodHlwZW9mIHRoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIHNob3VsZCBiZSBhIGZ1bmN0aW9uOiAnICsgdGhlbik7XG4gIH1cblxuICBpZiAodHlwZW9mIGltZ1NyY3MgPT09ICdzdHJpbmcnKSB7XG4gICAgbnVtYmVyT2ZJbWFnZXMgPSAxO1xuICAgIHN0cmluZ0dpdmVuID0gdHJ1ZTtcbiAgICBpbWdTcmNzID0gW2ltZ1NyY3NdOyAvLyBOb3JtYWxpemVcbiAgfSBlbHNlIHtcbiAgICAvLyBBcnJheSBvZiBpbWFnZXNcbiAgICBudW1iZXJPZkltYWdlcyA9IGltZ1NyY3MubGVuZ3RoO1xuICAgIHN0cmluZ0dpdmVuID0gZmFsc2U7XG4gIH1cbiAgdGhlcmVXYXNTdWNjZXNzID0gZmFsc2U7XG4gIHRoZXJlV2FzRXJyb3IgPSBmYWxzZTtcblxuICBpbWdzID0gW107XG5cbiAgb25sb2Fkc0NhbGxlZCA9IDA7XG4gIG9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBOb3RlOlxuICAgIC8vICAgdGhpcyA9IEltYWdlXG4gICAgaWYgKCF0aGVyZVdhc0Vycm9yKSB7XG4gICAgICBvbmxvYWRzQ2FsbGVkICs9IDE7XG4gICAgICB2YXIgaXNGaW5hbEltYWdlID0gKG9ubG9hZHNDYWxsZWQgPT09IG51bWJlck9mSW1hZ2VzKTtcbiAgICAgIGlmIChpc0ZpbmFsSW1hZ2UpIHtcbiAgICAgICAgdGhlcmVXYXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmluZ0dpdmVuKSB7XG4gICAgICAgICAgdGhlbihudWxsLCBpbWdzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGVuKG51bGwsIGltZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyTXNnKSB7XG4gICAgLy8gTm90ZTpcbiAgICAvLyAgIHRoaXMgPSBJbWFnZVxuXG4gICAgLy8gTm8gZXJyb3JzIGFmdGVyIHN1Y2Nlc3MuXG4gICAgaWYgKCF0aGVyZVdhc1N1Y2Nlc3MpIHtcbiAgICAgIHRoZXJlV2FzRXJyb3IgPSB0cnVlO1xuICAgICAgdGhlbihlcnJNc2csIG51bGwpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZmlyaW5nIHRoZSBkZWZhdWx0IGV2ZW50IGhhbmRsZXJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2xvYmFsRXZlbnRIYW5kbGVycy5vbmVycm9yI1BhcmFtZXRlcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaW1nU3Jjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGltZ3MucHVzaChuZXcgSW1hZ2UoKSk7XG4gICAgaW1nc1tpXS5vbmxvYWQgPSBvbmxvYWQ7XG4gICAgaW1nc1tpXS5vbmVycm9yID0gb25lcnJvcjtcbiAgICBpbWdzW2ldLnNyYyA9IGltZ1NyY3NbaV07XG4gIH1cbn07XG4iLCIvKipcbiAqIE1vZHVsZSBEZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHF1ZXJ5ID0gcmVxdWlyZSgnY29tcG9uZW50LXF1ZXJ5Jyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlci10cmFuc2l0aW9uJyk7XG52YXIgaGFzM2QgPSByZXF1aXJlKCdoYXMtdHJhbnNsYXRlM2QnKTtcbnZhciBlYXNlID0gcmVxdWlyZSgnY3NzLWVhc2UnKTtcblxuLyoqXG4gKiBDU1MgVHJhbnNsYXRlXG4gKi9cblxudmFyIHRyYW5zbGF0ZSA9IGhhczNkXG4gID8gWyd0cmFuc2xhdGUzZCgnLCAnLCAwKSddXG4gIDogWyd0cmFuc2xhdGUoJywgJyknXTtcblxuLyoqXG4gKiBFeHBvcnQgYE1vdmVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNb3ZlO1xuXG4vKipcbiAqIEdldCBjb21wdXRlZCBzdHlsZS5cbiAqL1xuXG52YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZVxuICB8fCB3aW5kb3cuY3VycmVudFN0eWxlO1xuXG4vKipcbiAqIExpYnJhcnkgdmVyc2lvbi5cbiAqL1xuXG5Nb3ZlLnZlcnNpb24gPSAnMC41LjAnO1xuXG4vKipcbiAqIEV4cG9ydCBgZWFzZWBcbiAqL1xuXG5Nb3ZlLmVhc2UgPSBlYXNlO1xuXG4vKipcbiAqIERlZmF1bHRzLlxuICpcbiAqICAgYGR1cmF0aW9uYCAtIGRlZmF1bHQgZHVyYXRpb24gb2YgNTAwbXNcbiAqXG4gKi9cblxuTW92ZS5kZWZhdWx0cyA9IHtcbiAgZHVyYXRpb246IDUwMFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGVsZW1lbnQgc2VsZWN0aW9uIHV0aWxpemVkIGJ5IGBtb3ZlKHNlbGVjdG9yKWAuXG4gKlxuICogT3ZlcnJpZGUgdG8gaW1wbGVtZW50IHlvdXIgb3duIHNlbGVjdGlvbiwgZm9yIGV4YW1wbGVcbiAqIHdpdGggalF1ZXJ5IG9uZSBtaWdodCB3cml0ZTpcbiAqXG4gKiAgICAgbW92ZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICogICAgICAgcmV0dXJuIGpRdWVyeShzZWxlY3RvcikuZ2V0KDApO1xuICogICAgIH07XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7RWxlbWVudH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2Ygc2VsZWN0b3IpIHJldHVybiBzZWxlY3RvcjtcbiAgcmV0dXJuIHF1ZXJ5KHNlbGVjdG9yKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTW92ZWAgd2l0aCB0aGUgZ2l2ZW4gYGVsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1vdmUoZWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdmUpKSByZXR1cm4gbmV3IE1vdmUoZWwpO1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGVsKSBlbCA9IHF1ZXJ5KGVsKTtcbiAgaWYgKCFlbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTW92ZSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZWxlbWVudCBvciBzZWxlY3RvcicpO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMuX3Byb3BzID0ge307XG4gIHRoaXMuX3JvdGF0ZSA9IDA7XG4gIHRoaXMuX3RyYW5zaXRpb25Qcm9wcyA9IFtdO1xuICB0aGlzLl90cmFuc2Zvcm1zID0gW107XG4gIHRoaXMuZHVyYXRpb24oTW92ZS5kZWZhdWx0cy5kdXJhdGlvbilcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxuICovXG5cbkVtaXR0ZXIoTW92ZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEJ1ZmZlciBgdHJhbnNmb3JtYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSl7XG4gIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tldyBgeGAgYW5kIGB5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3ID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2tldygnXG4gICAgKyB4ICsgJ2RlZywgJ1xuICAgICsgKHkgfHwgMClcbiAgICArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNrZXcgeCBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3WCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXdYKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogU2tldyB5IGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNrZXdZID0gZnVuY3Rpb24obil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2tld1koJyArIG4gKyAnZGVnKScpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYHhgIGFuZCBgeWAgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGUgPVxuTW92ZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHRyYW5zbGF0ZS5qb2luKCcnXG4gICAgKyB4ICsncHgsICdcbiAgICArICh5IHx8IDApXG4gICAgKyAncHgnKSk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBvbiB0aGUgeCBheGlzIHRvIGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zbGF0ZVggPVxuTW92ZS5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZVgoJyArIG4gKyAncHgpJyk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBvbiB0aGUgeSBheGlzIHRvIGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zbGF0ZVkgPVxuTW92ZS5wcm90b3R5cGUueSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZVkoJyArIG4gKyAncHgpJyk7XG59O1xuXG4vKipcbiAqIFNjYWxlIHRoZSB4IGFuZCB5IGF4aXMgYnkgYHhgLCBvclxuICogaW5kaXZpZHVhbGx5IHNjYWxlIGB4YCBhbmQgYHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2NhbGUoJ1xuICAgICsgeCArICcsICdcbiAgICArICh5IHx8IHgpXG4gICAgKyAnKScpO1xufTtcblxuLyoqXG4gKiBTY2FsZSB4IGF4aXMgYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2NhbGVYID0gZnVuY3Rpb24obil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2NhbGVYKCcgKyBuICsgJyknKVxufTtcblxuLyoqXG4gKiBBcHBseSBhIG1hdHJpeCB0cmFuc2Zvcm1hdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5tYXRyaXggPSBmdW5jdGlvbihtMTEsIG0xMiwgbTIxLCBtMjIsIG0zMSwgbTMyKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdtYXRyaXgoJyArIFttMTEsbTEyLG0yMSxtMjIsbTMxLG0zMl0uam9pbignLCcpICsgJyknKTtcbn07XG5cbi8qKlxuICogU2NhbGUgeSBheGlzIGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlWSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlWSgnICsgbiArICcpJylcbn07XG5cbi8qKlxuICogUm90YXRlIGBuYCBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24obil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgncm90YXRlKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogU2V0IHRyYW5zaXRpb24gZWFzaW5nIGZ1bmN0aW9uIHRvIHRvIGBmbmAgc3RyaW5nLlxuICpcbiAqIFdoZW46XG4gKlxuICogICAtIG51bGwgXCJlYXNlXCIgaXMgdXNlZFxuICogICAtIFwiaW5cIiBcImVhc2UtaW5cIiBpcyB1c2VkXG4gKiAgIC0gXCJvdXRcIiBcImVhc2Utb3V0XCIgaXMgdXNlZFxuICogICAtIFwiaW4tb3V0XCIgXCJlYXNlLWluLW91dFwiIGlzIHVzZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24oZm4pe1xuICBmbiA9IGVhc2VbZm5dIHx8IGZuIHx8ICdlYXNlJztcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgZm4pO1xufTtcblxuLyoqXG4gKiBTZXQgYW5pbWF0aW9uIHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHByb3BzKXtcbiAgZm9yICh2YXIgaSBpbiBwcm9wcyl7XG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ2FuaW1hdGlvbi0nICsgaSwgcHJvcHNbaV0pXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCdhbmltYXRpb24tbmFtZScsIG5hbWUpO1xufVxuXG4vKipcbiAqIFNldCBkdXJhdGlvbiB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihuKXtcbiAgbiA9IHRoaXMuX2R1cmF0aW9uID0gJ3N0cmluZycgPT0gdHlwZW9mIG5cbiAgICA/IHBhcnNlRmxvYXQobikgKiAxMDAwXG4gICAgOiBuO1xuICByZXR1cm4gdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNpdGlvbi1kdXJhdGlvbicsIG4gKyAnbXMnKTtcbn07XG5cbi8qKlxuICogRGVsYXkgdGhlIGFuaW1hdGlvbiBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbihuKXtcbiAgbiA9ICdzdHJpbmcnID09IHR5cGVvZiBuXG4gICAgPyBwYXJzZUZsb2F0KG4pICogMTAwMFxuICAgIDogbjtcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tZGVsYXknLCBuICsgJ21zJyk7XG59O1xuXG4vKipcbiAqIFNldCBgcHJvcGAgdG8gYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIHRoaXMuX3Byb3BzW3Byb3BdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGEgdmVuZG9yIHByZWZpeGVkIGBwcm9wYCB3aXRoIHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNldFZlbmRvclByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLXdlYmtpdC0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW1vei0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW1zLScgKyBwcm9wLCB2YWwpO1xuICB0aGlzLnNldFByb3BlcnR5KCctby0nICsgcHJvcCwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBgcHJvcGAgdG8gYHZhbHVlYCwgZGVmZXJyZWQgdW50aWwgYC5lbmQoKWAgaXMgaW52b2tlZFxuICogYW5kIGFkZHMgdGhlIHByb3BlcnR5IHRvIHRoZSBsaXN0IG9mIHRyYW5zaXRpb24gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICB0aGlzLnRyYW5zaXRpb24ocHJvcCk7XG4gIHRoaXMuX3Byb3BzW3Byb3BdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5jcmVtZW50IGBwcm9wYCBieSBgdmFsYCwgZGVmZXJyZWQgdW50aWwgYC5lbmQoKWAgaXMgaW52b2tlZFxuICogYW5kIGFkZHMgdGhlIHByb3BlcnR5IHRvIHRoZSBsaXN0IG9mIHRyYW5zaXRpb24gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICBpZiAoIXN0eWxlKSByZXR1cm47XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMub24oJ3N0YXJ0JywgZnVuY3Rpb24oKXtcbiAgICB2YXIgY3VyciA9IHBhcnNlSW50KHNlbGYuY3VycmVudChwcm9wKSwgMTApO1xuICAgIHNlbGYuc2V0KHByb3AsIGN1cnIgKyB2YWwgKyAncHgnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlY3JlbWVudCBgcHJvcGAgYnkgYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgaWYgKCFzdHlsZSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1cnIgPSBwYXJzZUludChzZWxmLmN1cnJlbnQocHJvcCksIDEwKTtcbiAgICBzZWxmLnNldChwcm9wLCBjdXJyIC0gdmFsICsgJ3B4Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgY29tcHV0ZWQgb3IgXCJjdXJyZW50XCIgdmFsdWUgb2YgYHByb3BgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbihwcm9wKXtcbiAgcmV0dXJuIHN0eWxlKHRoaXMuZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG59O1xuXG4vKipcbiAqIEFkZCBgcHJvcGAgdG8gdGhlIGxpc3Qgb2YgaW50ZXJuYWwgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbihwcm9wKXtcbiAgaWYgKCF0aGlzLl90cmFuc2l0aW9uUHJvcHMuaW5kZXhPZihwcm9wKSkgcmV0dXJuIHRoaXM7XG4gIHRoaXMuX3RyYW5zaXRpb25Qcm9wcy5wdXNoKHByb3ApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tbWl0IHN0eWxlIHByb3BlcnRpZXMsIGFrYSBhcHBseSB0aGVtIHRvIGBlbC5zdHlsZWAuXG4gKlxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAc2VlIE1vdmUjZW5kKClcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vdmUucHJvdG90eXBlLmFwcGx5UHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIHByb3AgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHRoaXMuX3Byb3BzW3Byb3BdLCAnJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlLXNlbGVjdCBlbGVtZW50IHZpYSBgc2VsZWN0b3JgLCByZXBsYWNpbmdcbiAqIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUubW92ZSA9XG5Nb3ZlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gIHRoaXMuZWwgPSBNb3ZlLnNlbGVjdChzZWxlY3Rvcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgZ2l2ZW4gYGZuYCB1bnRpbCB0aGUgYW5pbWF0aW9uXG4gKiBpcyBjb21wbGV0ZS4gYGZuYCBtYXkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogICAtIGEgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIC0gYW4gaW5zdGFuY2VvZiBgTW92ZWAgdG8gY2FsbCBgLmVuZCgpYFxuICogICAtIG5vdGhpbmcsIHRvIHJldHVybiBhIGNsb25lIG9mIHRoaXMgYE1vdmVgIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258TW92ZX0gZm5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oZm4pe1xuICAvLyBpbnZva2UgLmVuZCgpXG4gIGlmIChmbiBpbnN0YW5jZW9mIE1vdmUpIHtcbiAgICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgICAgZm4uZW5kKCk7XG4gICAgfSk7XG4gIC8vIGNhbGxiYWNrXG4gIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZm4pIHtcbiAgICB0aGlzLm9uKCdlbmQnLCBmbik7XG4gIC8vIGNoYWluXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNsb25lID0gbmV3IE1vdmUodGhpcy5lbCk7XG4gICAgY2xvbmUuX3RyYW5zZm9ybXMgPSB0aGlzLl90cmFuc2Zvcm1zLnNsaWNlKDApO1xuICAgIHRoaXMudGhlbihjbG9uZSk7XG4gICAgY2xvbmUucGFyZW50ID0gdGhpcztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUG9wIHRoZSBtb3ZlIGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7TW92ZX0gcGFyZW50IE1vdmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuLyoqXG4gKiBSZXNldCBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtNb3ZlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZWwuc3R5bGUud2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5tb3pUcmFuc2l0aW9uRHVyYXRpb24gPVxuICB0aGlzLmVsLnN0eWxlLm1zVHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5vVHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydCBhbmltYXRpb24sIG9wdGlvbmFsbHkgY2FsbGluZyBgZm5gIHdoZW4gY29tcGxldGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBlbWl0IFwic3RhcnRcIiBldmVudFxuICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XG5cbiAgLy8gdHJhbnNmb3Jtc1xuICBpZiAodGhpcy5fdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2Zvcm0nLCB0aGlzLl90cmFuc2Zvcm1zLmpvaW4oJyAnKSk7XG4gIH1cblxuICAvLyB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNpdGlvbi1wcm9wZXJ0aWVzJywgdGhpcy5fdHJhbnNpdGlvblByb3BzLmpvaW4oJywgJykpO1xuICB0aGlzLmFwcGx5UHJvcGVydGllcygpO1xuXG4gIC8vIGNhbGxiYWNrIGdpdmVuXG4gIGlmIChmbikgdGhpcy50aGVuKGZuKTtcblxuICAvLyBlbWl0IFwiZW5kXCIgd2hlbiBjb21wbGV0ZVxuICBhZnRlci5vbmNlKHRoaXMuZWwsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5yZXNldCgpO1xuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbiIsInZhciBoYXNUcmFuc2l0aW9ucyA9IHJlcXVpcmUoJ2hhcy10cmFuc2l0aW9ucycpO1xudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCdjc3MtZW1pdHRlcicpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zaXRpb24oZWwsIGNhbGxiYWNrKSB7XG4gIGlmKGhhc1RyYW5zaXRpb25zKGVsKSkge1xuICAgIHJldHVybiBlbWl0dGVyKGVsKS5iaW5kKGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2suYXBwbHkoZWwpO1xufTtcblxuYWZ0ZXJUcmFuc2l0aW9uLm9uY2UgPSBmdW5jdGlvbihlbCwgY2FsbGJhY2spIHtcbiAgYWZ0ZXJUcmFuc2l0aW9uKGVsLCBmdW5jdGlvbiBmbigpe1xuICAgIGNhbGxiYWNrLmFwcGx5KGVsKTtcbiAgICBlbWl0dGVyKGVsKS51bmJpbmQoZm4pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJUcmFuc2l0aW9uOyIsIi8qKlxuICogTW9kdWxlIERlcGVuZGVuY2llc1xuICovXG5cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudCcpO1xuXG4vLyBDU1MgZXZlbnRzXG5cbnZhciB3YXRjaCA9IFtcbiAgJ3RyYW5zaXRpb25lbmQnXG4sICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuLCAnb1RyYW5zaXRpb25FbmQnXG4sICdNU1RyYW5zaXRpb25FbmQnXG4sICdhbmltYXRpb25lbmQnXG4sICd3ZWJraXRBbmltYXRpb25FbmQnXG4sICdvQW5pbWF0aW9uRW5kJ1xuLCAnTVNBbmltYXRpb25FbmQnXG5dO1xuXG4vKipcbiAqIEV4cG9zZSBgQ1NTbmV4dGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENzc0VtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ3NzRW1pdHRlcmBcbiAqXG4gKi9cblxuZnVuY3Rpb24gQ3NzRW1pdHRlcihlbGVtZW50KXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENzc0VtaXR0ZXIpKSByZXR1cm4gbmV3IENzc0VtaXR0ZXIoZWxlbWVudCk7XG4gIHRoaXMuZWwgPSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEJpbmQgQ1NTIGV2ZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNzc0VtaXR0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihmbil7XG4gIGZvciAodmFyIGk9MDsgaSA8IHdhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgZXZlbnRzLmJpbmQodGhpcy5lbCwgd2F0Y2hbaV0sIGZuKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kIENTUyBldmVudHNcbiAqIFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Dc3NFbWl0dGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihmbil7XG4gIGZvciAodmFyIGk9MDsgaSA8IHdhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgZXZlbnRzLnVuYmluZCh0aGlzLmVsLCB3YXRjaFtpXSwgZm4pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaXJlIGNhbGxiYWNrIG9ubHkgb25jZVxuICogXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNzc0VtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gb24oKXtcbiAgICBzZWxmLnVuYmluZChvbik7XG4gICAgZm4uYXBwbHkoc2VsZi5lbCwgYXJndW1lbnRzKTtcbiAgfVxuICBzZWxmLmJpbmQob24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbiIsIlxuLyoqXG4gKiBCaW5kIGBlbGAgZXZlbnQgYHR5cGVgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgYGVsYCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51bmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcbiIsIi8qKlxuICogVGhpcyB3aWxsIHN0b3JlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZSBjdXJyZW50XG4gKiBicm93c2VyIHVzZXMgZm9yIHRyYW5zaXRpb25EdXJhdGlvblxuICovXG52YXIgcHJvcGVydHk7XG5cbi8qKlxuICogVGhlIHByb3BlcnRpZXMgd2UnbGwgY2hlY2sgb24gYW4gZWxlbWVudFxuICogdG8gZGV0ZXJtaW5lIGlmIGl0IGFjdHVhbGx5IGhhcyB0cmFuc2l0aW9uc1xuICogV2UgdXNlIGR1cmF0aW9uIGFzIHRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHlcbiAqIG5lZWRlZCB0byB0ZWNobmljYWxseSBoYXZlIHRyYW5zaXRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciB0eXBlcyA9IFtcbiAgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIixcbiAgXCJNb3pUcmFuc2l0aW9uRHVyYXRpb25cIixcbiAgXCJ3ZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cIlxuXTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvcnJlY3QgcHJvcGVydHkgZm9yIHRoaXMgYnJvd3NlclxuICoganVzdCBvbmNlIHNvIHdlIGRvbmUgbmVlZCB0byBjaGVjayBldmVyeSB0aW1lXG4gKi9cbndoaWxlKHR5cGVzLmxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVzLnNoaWZ0KCk7XG4gIGlmKHR5cGUgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSkge1xuICAgIHByb3BlcnR5ID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0cmFuc2l0aW9ucyBvclxuICogaWYgYW4gZWxlbWVudCBoYXMgdHJhbnNpdGlvbnMgYXQgYWxsLlxuICogQHBhcmFtICB7RWxlbWVudH0gIGVsIE9wdGlvbmFsLiBSZXR1cm5zIGJyb3dzZXIgc3VwcG9ydCBpZiBub3QgaW5jbHVkZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1RyYW5zaXRpb25zKGVsKXtcbiAgaWYoIXByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBObyBicm93c2VyIHN1cHBvcnQgZm9yIHRyYW5zaXRpb25zXG4gIH1cbiAgaWYoIWVsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5ICE9IG51bGw7IC8vIFdlIGp1c3Qgd2FudCB0byBrbm93IGlmIGJyb3dzZXJzIHN1cHBvcnQgaXRcbiAgfVxuICB2YXIgZHVyYXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsKVtwcm9wZXJ0eV07XG4gIHJldHVybiBkdXJhdGlvbiAhPT0gXCJcIiAmJiBwYXJzZUZsb2F0KGR1cmF0aW9uKSAhPT0gMDsgLy8gRG9lcyB0aGlzIGVsZW1lbnQgaGF2ZSB0cmFuc2l0aW9ucz9cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNUcmFuc2l0aW9uczsiLCJmdW5jdGlvbiBvbmUoc2VsZWN0b3IsIGVsKSB7XG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIG9uZShzZWxlY3RvciwgZWwpO1xufTtcblxuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbihzZWxlY3RvciwgZWwpe1xuICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59O1xuXG5leHBvcnRzLmVuZ2luZSA9IGZ1bmN0aW9uKG9iail7XG4gIGlmICghb2JqLm9uZSkgdGhyb3cgbmV3IEVycm9yKCcub25lIGNhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIGlmICghb2JqLmFsbCkgdGhyb3cgbmV3IEVycm9yKCcuYWxsIGNhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIG9uZSA9IG9iai5vbmU7XG4gIGV4cG9ydHMuYWxsID0gb2JqLmFsbDtcbiAgcmV0dXJuIGV4cG9ydHM7XG59O1xuIiwiXG4vKipcbiAqIENTUyBFYXNpbmcgZnVuY3Rpb25zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2luJzogICAgICAgICAgICAgICAgJ2Vhc2UtaW4nXG4gICwgJ291dCc6ICAgICAgICAgICAgICAgJ2Vhc2Utb3V0J1xuICAsICdpbi1vdXQnOiAgICAgICAgICAgICdlYXNlLWluLW91dCdcbiAgLCAnc25hcCc6ICAgICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAsMSwuNSwxKSdcbiAgLCAnbGluZWFyJzogICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjI1MCwgMC43NTAsIDAuNzUwKSdcbiAgLCAnZWFzZS1pbi1xdWFkJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA4NSwgMC42ODAsIDAuNTMwKSdcbiAgLCAnZWFzZS1pbi1jdWJpYyc6ICAgICAnY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA1NSwgMC42NzUsIDAuMTkwKSdcbiAgLCAnZWFzZS1pbi1xdWFydCc6ICAgICAnY3ViaWMtYmV6aWVyKDAuODk1LCAwLjAzMCwgMC42ODUsIDAuMjIwKSdcbiAgLCAnZWFzZS1pbi1xdWludCc6ICAgICAnY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1MCwgMC44NTUsIDAuMDYwKSdcbiAgLCAnZWFzZS1pbi1zaW5lJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNDcwLCAwLjAwMCwgMC43NDUsIDAuNzE1KSdcbiAgLCAnZWFzZS1pbi1leHBvJzogICAgICAnY3ViaWMtYmV6aWVyKDAuOTUwLCAwLjA1MCwgMC43OTUsIDAuMDM1KSdcbiAgLCAnZWFzZS1pbi1jaXJjJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNjAwLCAwLjA0MCwgMC45ODAsIDAuMzM1KSdcbiAgLCAnZWFzZS1pbi1iYWNrJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNjAwLCAtMC4yODAsIDAuNzM1LCAwLjA0NSknXG4gICwgJ2Vhc2Utb3V0LXF1YWQnOiAgICAgJ2N1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCknXG4gICwgJ2Vhc2Utb3V0LWN1YmljJzogICAgJ2N1YmljLWJlemllcigwLjIxNSwgMC42MTAsIDAuMzU1LCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LXF1YXJ0JzogICAgJ2N1YmljLWJlemllcigwLjE2NSwgMC44NDAsIDAuNDQwLCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LXF1aW50JzogICAgJ2N1YmljLWJlemllcigwLjIzMCwgMS4wMDAsIDAuMzIwLCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LXNpbmUnOiAgICAgJ2N1YmljLWJlemllcigwLjM5MCwgMC41NzUsIDAuNTY1LCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LWV4cG8nOiAgICAgJ2N1YmljLWJlemllcigwLjE5MCwgMS4wMDAsIDAuMjIwLCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LWNpcmMnOiAgICAgJ2N1YmljLWJlemllcigwLjA3NSwgMC44MjAsIDAuMTY1LCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LWJhY2snOiAgICAgJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIwLCAxLjI3NSknXG4gICwgJ2Vhc2Utb3V0LXF1YWQnOiAgICAgJ2N1YmljLWJlemllcigwLjQ1NSwgMC4wMzAsIDAuNTE1LCAwLjk1NSknXG4gICwgJ2Vhc2Utb3V0LWN1YmljJzogICAgJ2N1YmljLWJlemllcigwLjY0NSwgMC4wNDUsIDAuMzU1LCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LXF1YXJ0JzogJ2N1YmljLWJlemllcigwLjc3MCwgMC4wMDAsIDAuMTc1LCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LXF1aW50JzogJ2N1YmljLWJlemllcigwLjg2MCwgMC4wMDAsIDAuMDcwLCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LXNpbmUnOiAgJ2N1YmljLWJlemllcigwLjQ0NSwgMC4wNTAsIDAuNTUwLCAwLjk1MCknXG4gICwgJ2Vhc2UtaW4tb3V0LWV4cG8nOiAgJ2N1YmljLWJlemllcigxLjAwMCwgMC4wMDAsIDAuMDAwLCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LWNpcmMnOiAgJ2N1YmljLWJlemllcigwLjc4NSwgMC4xMzUsIDAuMTUwLCAwLjg2MCknXG4gICwgJ2Vhc2UtaW4tb3V0LWJhY2snOiAgJ2N1YmljLWJlemllcigwLjY4MCwgLTAuNTUwLCAwLjI2NSwgMS41NTApJ1xufTtcbiIsIlxudmFyIHByb3AgPSByZXF1aXJlKCd0cmFuc2Zvcm0tcHJvcGVydHknKTtcblxuLy8gSUUgPD04IGRvZXNuJ3QgaGF2ZSBgZ2V0Q29tcHV0ZWRTdHlsZWBcbmlmICghcHJvcCB8fCAhd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxufSBlbHNlIHtcbiAgdmFyIG1hcCA9IHtcbiAgICB3ZWJraXRUcmFuc2Zvcm06ICctd2Via2l0LXRyYW5zZm9ybScsXG4gICAgT1RyYW5zZm9ybTogJy1vLXRyYW5zZm9ybScsXG4gICAgbXNUcmFuc2Zvcm06ICctbXMtdHJhbnNmb3JtJyxcbiAgICBNb3pUcmFuc2Zvcm06ICctbW96LXRyYW5zZm9ybScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJ1xuICB9O1xuXG4gIC8vIGZyb206IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2xvcmVuem9wb2xpZG9yaS8zNzk0MjI2XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5zdHlsZVtwcm9wXSA9ICd0cmFuc2xhdGUzZCgxcHgsMXB4LDFweCknO1xuICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gIHZhciB2YWwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKG1hcFtwcm9wXSk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICBtb2R1bGUuZXhwb3J0cyA9IG51bGwgIT0gdmFsICYmIHZhbC5sZW5ndGggJiYgJ25vbmUnICE9IHZhbDtcbn1cbiIsIlxudmFyIHN0eWxlcyA9IFtcbiAgJ3dlYmtpdFRyYW5zZm9ybScsXG4gICdNb3pUcmFuc2Zvcm0nLFxuICAnbXNUcmFuc2Zvcm0nLFxuICAnT1RyYW5zZm9ybScsXG4gICd0cmFuc2Zvcm0nXG5dO1xuXG52YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG52YXIgc3R5bGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gIHN0eWxlID0gc3R5bGVzW2ldO1xuICBpZiAobnVsbCAhPSBlbC5zdHlsZVtzdHlsZV0pIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlO1xuICAgIGJyZWFrO1xuICB9XG59XG4iLCIvKlxuXG4qL1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9UcmFuc2Zvcm0nKTtcbmV4cG9ydHMuZXN0aW1hdGVUID0gcmVxdWlyZSgnLi9saWIvZXN0aW1hdGVUJyk7XG5leHBvcnRzLmVzdGltYXRlUyA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlUycpO1xuZXhwb3J0cy5lc3RpbWF0ZVIgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVInKTtcbmV4cG9ydHMuZXN0aW1hdGVUUyA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlVFMnKTtcbmV4cG9ydHMuZXN0aW1hdGVUUiA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlVFInKTtcbmV4cG9ydHMuZXN0aW1hdGVTUiA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlU1InKTtcbmV4cG9ydHMuZXN0aW1hdGVUU1IgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVRTUicpO1xuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9saWIvdmVyc2lvbicpO1xuXG5leHBvcnRzLmVzdGltYXRlID0gZnVuY3Rpb24gKHR5cGUsIGRvbWFpbiwgcmFuZ2UsIHBpdm90KSB7XG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHR5cGVcbiAgLy8gICAgIHN0cmluZy4gT25lIG9mIHRoZSBmb2xsb3dpbmc6ICdUJywgJ1MnLCAnUicsICdUUycsICdUUicsICdTUicsICdUU1InXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiAyZCBhcnJheXNcbiAgLy8gICByYW5nZVxuICAvLyAgICAgYXJyYXkgb2YgMmQgYXJyYXlzXG4gIC8vICAgcGl2b3RcbiAgLy8gICAgIG9wdGlvbmFsIDJkIGFycmF5LCBkb2VzIG5vdGhpbmcgZm9yIHRyYW5zbGF0aW9uIGVzdGltYXRvcnNcbiAgdmFyIG5hbWUgPSAnZXN0aW1hdGUnICsgdHlwZS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBleHBvcnRzW25hbWVdKGRvbWFpbiwgcmFuZ2UsIHBpdm90KTtcbiAgfSAvLyBlbHNlXG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlc3RpbWF0b3IgdHlwZTogJyArIHR5cGUpO1xufTtcbiIsIlxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzLCByLCB0eCwgdHkpIHtcblxuICAvLyBQdWJsaWMsIHRvIGFsbG93IHVzZXIgYWNjZXNzXG4gIHRoaXMucyA9IHM7XG4gIHRoaXMuciA9IHI7XG4gIHRoaXMudHggPSB0eDtcbiAgdGhpcy50eSA9IHR5O1xuXG4gIHRoaXMuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gKHMgPT09IHQucyAmJiByID09PSB0LnIgJiYgdHggPT09IHQudHggJiYgdHkgPT09IHQudHkpO1xuICB9O1xuXG4gIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHApIHtcbiAgICAvLyBwXG4gICAgLy8gICBwb2ludCBbeCwgeV0gb3IgYXJyYXkgb2YgcG9pbnRzIFtbeDEseTFdLCBbeDIsIHkyXSwgLi4uXVxuXG4gICAgaWYgKHR5cGVvZiBwWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gU2luZ2xlIHBvaW50XG4gICAgICByZXR1cm4gW3MgKiBwWzBdIC0gciAqIHBbMV0gKyB0eCwgciAqIHBbMF0gKyBzICogcFsxXSArIHR5XTtcbiAgICB9IC8vIGVsc2VcblxuICAgIHZhciBpLCBjID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGMucHVzaChbcyAqIHBbaV1bMF0gLSByICogcFtpXVsxXSArIHR4LCByICogcFtpXVswXSArIHMgKiBwW2ldWzFdICsgdHldKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgdGhpcy5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gR2V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gdGhlIGZvcm1hdCBjb21tb24gdG9cbiAgICAvLyBtYW55IEFQSXMsIGluY2x1ZGluZzpcbiAgICAvLyAtIGtsZC1hZmZpbmVcbiAgICAvL1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgb2JqZWN0IG8sIGhhdmluZyBwcm9wZXJ0aWVzIGEsIGIsIGMsIGQsIGUsIGY6XG4gICAgLy8gICBbIHMgIC1yICB0eCBdICAgWyBvLmEgIG8uYyAgby5lIF1cbiAgICAvLyAgIFsgciAgIHMgIHR5IF0gPSBbIG8uYiAgby5kICBvLmYgXVxuICAgIC8vICAgWyAwICAgMCAgIDEgXSAgIFsgIC0gICAgLSAgICAtICBdXG4gICAgcmV0dXJuIHsgYTogcywgYjogciwgYzogLXIsIGQ6IHMsIGU6IHR4LCBmOiB0eSB9O1xuICB9O1xuXG4gIHRoaXMuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaW4gcmFkc1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHIsIHMpO1xuICB9O1xuXG4gIHRoaXMuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2NhbGUgbXVsdGlwbGllclxuICAgIHJldHVybiBNYXRoLnNxcnQociAqIHIgKyBzICogcyk7XG4gIH07XG5cbiAgdGhpcy5nZXRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3R4LCB0eV07XG4gIH07XG5cbiAgdGhpcy5pbnZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBpbnZlcnNlZCB0cmFuc2Zvcm0gaW5zdGFuY2VcbiAgICAvLyBTZWUgbm90ZSAyMDE1LTEwLTI2LTE2LTMwXG4gICAgdmFyIGRldCA9IHMgKiBzICsgciAqIHI7XG4gICAgLy8gVGVzdCBpZiBzaW5ndWxhciB0cmFuc2Zvcm1hdGlvbi4gVGhlc2UgbWlnaHQgb2NjdXIgd2hlbiBhbGwgdGhlIHJhbmdlXG4gICAgLy8gcG9pbnRzIGFyZSB0aGUgc2FtZSwgZm9yY2luZyB0aGUgc2NhbGUgdG8gZHJvcCB0byB6ZXJvLlxuICAgIHZhciBlcHMgPSAwLjAwMDAwMDAxO1xuICAgIGlmIChNYXRoLmFicyhkZXQpIDwgZXBzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Npbmd1bGFyIHRyYW5zZm9ybWF0aW9ucyBjYW5ub3QgYmUgaW52ZXJzZWQuJyk7XG4gICAgfVxuICAgIHZhciBzaGF0ID0gcyAvIGRldDtcbiAgICB2YXIgcmhhdCA9IC1yIC8gZGV0O1xuICAgIHZhciB0eGhhdCA9ICgtcyAqIHR4IC0gciAqIHR5KSAvIGRldDtcbiAgICB2YXIgdHloYXQgPSAoIHIgKiB0eCAtIHMgKiB0eSkgLyBkZXQ7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbiAgfTtcblxuICB0aGlzLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHMsIHIsIHR4ICsgZHgsIHR5ICsgZHkpO1xuICB9O1xuXG4gIHRoaXMuc2NhbGVCeSA9IGZ1bmN0aW9uIChtdWx0aXBsaWVyLCBwaXZvdCkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgbXVsdGlwbGllclxuICAgIC8vICAgcGl2b3RcbiAgICAvLyAgICAgb3B0aW9uYWwsIGEgW3gsIHldIHBvaW50XG4gICAgdmFyIG0sIHgsIHk7XG4gICAgbSA9IG11bHRpcGxpZXI7IC8vIGFsaWFzXG4gICAgaWYgKHR5cGVvZiBwaXZvdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBpdm90WzBdO1xuICAgICAgeSA9IHBpdm90WzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShtICogcywgbSAqIHIsIG0gKiB0eCArICgxLW0pICogeCwgbSAqIHR5ICsgKDEtbSkgKiB5KTtcbiAgfTtcblxuICB0aGlzLnJvdGF0ZUJ5ID0gZnVuY3Rpb24gKHJhZGlhbnMsIHBpdm90KSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICByYWRpYW5zXG4gICAgLy8gICAgIGZyb20gcG9zaXRpdmUgeCB0byBwb3NpdGl2ZSB5IGF4aXNcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICAgIG9wdGlvbmFsLCBhIFt4LCB5XSBwb2ludFxuICAgIHZhciBjbywgc2ksIHgsIHksIHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdDtcbiAgICBjbyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgIHNpID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgaWYgKHR5cGVvZiBwaXZvdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBpdm90WzBdO1xuICAgICAgeSA9IHBpdm90WzFdO1xuICAgIH1cbiAgICBzaGF0ID0gcyAqIGNvIC0gciAqIHNpO1xuICAgIHJoYXQgPSBzICogc2kgKyByICogY287XG4gICAgdHhoYXQgPSAodHggLSB4KSAqIGNvIC0gKHR5IC0geSkgKiBzaSArIHg7XG4gICAgdHloYXQgPSAodHggLSB4KSAqIHNpICsgKHR5IC0geSkgKiBjbyArIHk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbiAgfTtcblxuXG4gIHRoaXMubXVsdGlwbHlCeSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAvLyBNdWx0aXBseSB0aGlzIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBBXG4gICAgLy8gZnJvbSB0aGUgcmlnaHQgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtYXRpb24gbWF0cml4IEJcbiAgICAvLyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgQUJcblxuICAgIC8vIEZvciByZWFkaW5nIGFpZDpcbiAgICAvLyBzIC1yIHR4ICB0LnMgLXIgdHhcbiAgICAvLyByICBzIHR5ICogIHIgIHMgdHlcbiAgICAvLyAwICAwICAxICAgIDAgIDAgIDFcbiAgICB2YXIgdCA9IHRyYW5zZm9ybTsgLy8gYWxpYXNcbiAgICB2YXIgc2hhdCA9IHMgKiB0LnMgLSByICogdC5yO1xuICAgIHZhciByaGF0ID0gcyAqIHQuciArIHIgKiB0LnM7XG4gICAgdmFyIHR4aGF0ID0gcyAqIHQudHggLSByICogdC50eSArIHR4O1xuICAgIHZhciB0eWhhdCA9IHIgKiB0LnR4ICsgcyAqIHQudHkgKyB0eTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShzaGF0LCByaGF0LCB0eGhhdCwgdHloYXQpO1xuICB9O1xufTtcblxuVHJhbnNmb3JtLklERU5USVRZID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgdmFyIGksIE4sIEQsIGEwLCBiMCwgYSwgYiwgYywgZCwgYWMsIGFkLCBiYywgYmQsIHNoYXQsIHJoYXQsIHR4LCB0eTtcblxuICBOID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKTtcbiAgYWMgPSBhZCA9IGJjID0gYmQgPSAwO1xuXG4gIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYTAgPSBiMCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYTAgPSBwaXZvdFswXTtcbiAgICBiMCA9IHBpdm90WzFdO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBkb21haW5baV1bMF0gLSBhMDtcbiAgICBiID0gZG9tYWluW2ldWzFdIC0gYjA7XG4gICAgYyA9IHJhbmdlW2ldWzBdIC0gYTA7XG4gICAgZCA9IHJhbmdlW2ldWzFdIC0gYjA7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYWQgKz0gYSAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICBwID0gYWMgKyBiZDtcbiAgcSA9IGFkIC0gYmM7XG5cbiAgRCA9IE1hdGguc3FydChwICogcCArIHEgKiBxKTtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIEQgPT09IDBcbiAgICAvLyA8PT4gcSA9PT0gMCBhbmQgcCA9PT0gMC5cbiAgICAvLyA8PT4gYWQgPT09IGJjIGFuZCBhYyA9PT0gLWJkXG4gICAgLy8gPD0+IGRvbWFpbiBpbiBwaXZvdCBPUiByYW5nZSBpbiBwaXZvdCBPUiB5ZXQgdW5rbm93biBjYXNlc1xuICAgIC8vICAgICB3aGVyZSB0aGUgYW5nbGUgY2Fubm90IGJlIGRldGVybWluZWQuXG4gICAgLy8gRCA9PT0gMCBhbHNvIGlmIE4gPT09IDAuXG4gICAgLy8gQXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybSB0byBiZSB0aGUgYmVzdCBndWVzc1xuICAgIHJldHVybiBUcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH1cblxuICBzaGF0ID0gcCAvIEQ7XG4gIHJoYXQgPSBxIC8gRDtcbiAgdHggPSBhMCAtIGEwICogc2hhdCArIGIwICogcmhhdDtcbiAgdHkgPSBiMCAtIGEwICogcmhhdCAtIGIwICogc2hhdDtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybShzaGF0LCByaGF0LCB0eCwgdHkpO1xufTtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlLCBwaXZvdCkge1xuICB2YXIgaSwgTiwgRCwgYTAsIGIwLCBhLCBiLCBjLCBkLCBhYywgYmQsIGFhLCBiYiwgc2hhdCwgdHgsIHR5O1xuXG4gIE4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICBhYyA9IGJkID0gYWEgPSBiYiA9IDA7XG5cbiAgaWYgKHR5cGVvZiBwaXZvdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhMCA9IGIwID0gMDtcbiAgfSBlbHNlIHtcbiAgICBhMCA9IHBpdm90WzBdO1xuICAgIGIwID0gcGl2b3RbMV07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSAxKSB7XG4gICAgYSA9IGRvbWFpbltpXVswXSAtIGEwO1xuICAgIGIgPSBkb21haW5baV1bMV0gLSBiMDtcbiAgICBjID0gcmFuZ2VbaV1bMF0gLSBhMDtcbiAgICBkID0gcmFuZ2VbaV1bMV0gLSBiMDtcbiAgICBhYyArPSBhICogYztcbiAgICBiZCArPSBiICogZDtcbiAgICBhYSArPSBhICogYTtcbiAgICBiYiArPSBiICogYjtcbiAgfVxuXG4gIEQgPSBhYSArIGJiO1xuXG4gIGlmIChEID09PSAwKSB7XG4gICAgLy8gQWxsIGRvbWFpbiBwb2ludHMgZXF1YWwgdGhlIHBpdm90LlxuICAgIC8vIElkZW50aXR5IHRyYW5zZm9ybSBpcyB0aGVuIG9ubHkgc29sdXRpb24uXG4gICAgLy8gRCA9PT0gMCBhbHNvIGlmIE4gPT09IDAuXG4gICAgLy8gQXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybSB0byBiZSB0aGUgYmVzdCBndWVzc1xuICAgIHJldHVybiBUcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH1cblxuICAvLyBQcmV2ZW50IG5lZ2F0aXZlIHNjYWxpbmcgYmVjYXVzZSBpdCB3b3VsZCBiZSBzYW1lIGFzIHBvc2l0aXZlIHNjYWxpbmdcbiAgLy8gYW5kIHJvdGF0aW9uID0+IGxpbWl0IHRvIHplcm9cbiAgc2hhdCA9IE1hdGgubWF4KDAsIChhYyArIGJkKSAvIEQpO1xuICB0eCA9ICgxIC0gc2hhdCkgKiBhMDtcbiAgdHkgPSAoMSAtIHNoYXQpICogYjA7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgMCwgdHgsIHR5KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgLy8gRXN0aW1hdGUgb3B0aW1hbCB0cmFuc2Zvcm1hdGlvbiBnaXZlbiB0aGUgZG9tYWluIGFuZCB0aGUgcmFuZ2VcbiAgLy8gc28gdGhhdCB0aGUgcGl2b3QgcG9pbnQgcmVtYWlucyB0aGUgc2FtZS5cbiAgLy9cbiAgLy8gVXNlIGNhc2VzXG4gIC8vICAgLSB0cmFuc2Zvcm0gYW4gaW1hZ2UgdGhhdCBoYXMgb25lIGNvcm5lciBmaXhlZCB3aXRoIGEgcGluLlxuICAvLyAgIC0gYWxsb3cgb25seSBzY2FsZSBhbmQgcm90YXRpb24gYnkgZml4aW5nIHRoZSBtaWRkbGUgb2YgdGhlIG9iamVjdFxuICAvLyAgICAgdG8gdHJhbnNmb3JtLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluLCBhbiBhcnJheSBvZiBbeCwgeV0gcG9pbnRzXG4gIC8vICAgcmFuZ2UsIGFuIGFycmF5IG9mIFt4LCB5XSBwb2ludHNcbiAgLy8gICBwaXZvdCwgb3B0aW9uYWxcbiAgLy8gICAgIHRoZSBwb2ludCBbeCwgeV0gdGhhdCBtdXN0IHJlbWFpbiBjb25zdGFudCBpbiB0aGUgdHJhbmZvcm1hdGlvbi5cbiAgLy8gICAgIERlZmF1bHRzIHRvIG9yaWdvIFswLCAwXVxuICAvL1xuICAvL1xuICB2YXIgWCwgWSwgTiwgcywgciwgdHgsIHR5O1xuXG4gIC8vIE9wdGlvbmFsIHBpdm90XG4gIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcGl2b3QgPSBbMCwgMF07XG4gIH1cblxuICAvLyBBbGlhc1xuICBYID0gZG9tYWluO1xuICBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICB2YXIgdiA9IHBpdm90WzBdO1xuICB2YXIgdyA9IHBpdm90WzFdO1xuXG4gIHZhciBpLCBhLCBiLCBjLCBkO1xuICB2YXIgYTIsIGIyO1xuICBhMiA9IGIyID0gMDtcbiAgdmFyIGFjLCBiZCwgYmMsIGFkO1xuICBhYyA9IGJkID0gYmMgPSBhZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdIC0gdjtcbiAgICBiID0gWFtpXVsxXSAtIHc7XG4gICAgYyA9IFlbaV1bMF0gLSB2O1xuICAgIGQgPSBZW2ldWzFdIC0gdztcbiAgICBhMiArPSBhICogYTtcbiAgICBiMiArPSBiICogYjtcbiAgICBhYyArPSBhICogYztcbiAgICBiZCArPSBiICogZDtcbiAgICBiYyArPSBiICogYztcbiAgICBhZCArPSBhICogZDtcbiAgfVxuXG4gIC8vIERlbm9taW5hdG9yID0gZGV0ZXJtaW5hbnQuXG4gIC8vIEl0IGJlY29tZXMgemVybyBpZmYgTiA9IDAgb3IgWFtpXSA9IFt2LCB3XSBmb3IgZXZlcnkgaSBpbiBbMCwgbikuXG4gIC8vIEluIG90aGVyIHdvcmRzLCBpZmYgYWxsIHRoZSBkb21haW4gcG9pbnRzIGFyZSB1bmRlciB0aGUgZml4ZWQgcG9pbnQgb3JcbiAgLy8gdGhlcmUgaXMgbm8gZG9tYWluIHBvaW50cy5cbiAgdmFyIGRlbiA9IGEyICsgYjI7XG5cbiAgdmFyIGVwcyA9IDAuMDAwMDAwMDE7XG4gIGlmIChNYXRoLmFicyhkZW4pIDwgZXBzKSB7XG4gICAgLy8gVGhlIGRvbWFpbiBwb2ludHMgYXJlIHVuZGVyIHRoZSBwaXZvdCBvciB0aGVyZSBpcyBubyBkb21haW4gcG9pbnRzLlxuICAgIC8vIFdlIGFzc3VtZSBpZGVudGl0eSB0cmFuc2Zvcm0gYmUgdGhlIHNpbXBsZXN0IGd1ZXNzLiBJdCBrZWVwc1xuICAgIC8vIHRoZSBkb21haW4gcG9pbnRzIHVuZGVyIHRoZSBwaXZvdCBpZiB0aGVyZSBpcyBzb21lLlxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIDAsIDApO1xuICB9XG5cbiAgLy8gRXN0aW1hdG9yc1xuICBzID0gKGFjICsgYmQpIC8gZGVuO1xuICByID0gKC1iYyArIGFkKSAvIGRlbjtcbiAgdHggPSAgdyAqIHIgLSB2ICogcyArIHY7XG4gIHR5ID0gLXYgKiByIC0gdyAqIHMgKyB3O1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHMsIHIsIHR4LCB0eSk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgdmFyIGksIE4sIGExLCBiMSwgYzEsIGQxLCB0eGhhdCwgdHloYXQ7XG5cbiAgTiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCk7XG4gIGExID0gYjEgPSBjMSA9IGQxID0gMDtcblxuICBpZiAoTiA8IDEpIHtcbiAgICAvLyBBc3N1bWUgaWRlbnRpdHkgdHJhbnNmb3JtIGJlIHRoZSBiZXN0IGd1ZXNzXG4gICAgcmV0dXJuIFRyYW5zZm9ybS5JREVOVElUWTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhMSArPSBkb21haW5baV1bMF07XG4gICAgYjEgKz0gZG9tYWluW2ldWzFdO1xuICAgIGMxICs9IHJhbmdlW2ldWzBdO1xuICAgIGQxICs9IHJhbmdlW2ldWzFdO1xuICB9XG5cbiAgdHhoYXQgPSAoYzEgLSBhMSkgLyBOO1xuICB0eWhhdCA9IChkMSAtIGIxKSAvIE47XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgdHhoYXQsIHR5aGF0KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIFt4LCB5XSAyRCBhcnJheXNcblxuICAvLyBBbGlhc1xuICB2YXIgWCA9IGRvbWFpbjtcbiAgdmFyIFkgPSByYW5nZTtcblxuICAvLyBBbGxvdyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aCBidXRcbiAgLy8gaWdub3JlIHRoZSBleHRyYSBwb2ludHMuXG4gIHZhciBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICB2YXIgaSwgYSwgYiwgYywgZCwgYTEsIGIxLCBjMSwgZDEsIGFjLCBhZCwgYmMsIGJkO1xuICBhMSA9IGIxID0gYzEgPSBkMSA9IGFjID0gYWQgPSBiYyA9IGJkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdO1xuICAgIGIgPSBYW2ldWzFdO1xuICAgIGMgPSBZW2ldWzBdO1xuICAgIGQgPSBZW2ldWzFdO1xuICAgIGExICs9IGE7XG4gICAgYjEgKz0gYjtcbiAgICBjMSArPSBjO1xuICAgIGQxICs9IGQ7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYWQgKz0gYSAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvci5cbiAgdmFyIHYgPSBOICogKGFkIC0gYmMpIC0gYTEgKiBkMSArIGIxICogYzE7XG4gIHZhciB3ID0gTiAqIChhYyArIGJkKSAtIGExICogYzEgLSBiMSAqIGQxO1xuICB2YXIgRCA9IE1hdGguc3FydCh2ICogdiArIHcgKiB3KTtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIE4gPT09IDAgPT4gRCA9PT0gMFxuICAgIGlmIChOID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcbiAgICB9IC8vIGVsc2VcbiAgICAvLyBEID09PSAwIDw9PiB1bmRlY2lkYWJsZVxuICAgIC8vIFdlIGd1ZXNzIHRoZSB0cmFuc2xhdGlvbiB0byB0aGUgbWVhbiBvZiB0aGUgcmFuZ2UgdG8gYmUgdGhlIGJlc3QgZ3Vlc3MuXG4gICAgLy8gSGVyZSBhLCBiIHJlcHJlc2VudHMgdGhlIG1lYW4gb2YgZG9tYWluIHBvaW50cy5cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAoYzEgLSBhMSkgLyBOLCAoZDEgLSBiMSkgLyBOKTtcbiAgfVxuXG4gIC8vIEVzdGltYXRvcnNcbiAgdmFyIHNoYXQgPSB3IC8gRDtcbiAgdmFyIHJoYXQgPSB2IC8gRDtcbiAgdmFyIHR4aGF0ID0gKC1hMSAqIHNoYXQgKyBiMSAqIHJoYXQgKyBjMSkgLyBOO1xuICB2YXIgdHloYXQgPSAoLWExICogcmhhdCAtIGIxICogc2hhdCArIGQxKSAvIE47XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIFt4LCB5XSAyRCBhcnJheXNcblxuICAvLyBBbGlhc1xuICB2YXIgWCA9IGRvbWFpbjtcbiAgdmFyIFkgPSByYW5nZTtcblxuICAvLyBBbGxvdyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aCBidXRcbiAgLy8gaWdub3JlIHRoZSBleHRyYSBwb2ludHMuXG4gIHZhciBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICB2YXIgaSwgYSwgYiwgYywgZCwgYTEsIGIxLCBjMSwgZDEsIGEyLCBiMiwgYWMsIGJkO1xuICBhMSA9IGIxID0gYzEgPSBkMSA9IGEyID0gYjIgPSBhYyA9IGJkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdO1xuICAgIGIgPSBYW2ldWzFdO1xuICAgIGMgPSBZW2ldWzBdO1xuICAgIGQgPSBZW2ldWzFdO1xuICAgIGExICs9IGE7XG4gICAgYjEgKz0gYjtcbiAgICBjMSArPSBjO1xuICAgIGQxICs9IGQ7XG4gICAgYTIgKz0gYSAqIGE7XG4gICAgYjIgKz0gYiAqIGI7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvci5cbiAgdmFyIE4yID0gTiAqIE47XG4gIHZhciBhMTIgPSBhMSAqIGExO1xuICB2YXIgYjEyID0gYjEgKiBiMTtcbiAgdmFyIHAgPSBhMiArIGIyO1xuICB2YXIgcSA9IGFjICsgYmQ7XG4gIHZhciBEID0gTjIgKiBwIC0gTiAqIChhMTIgKyBiMTIpO1xuXG4gIGlmIChEID09PSAwKSB7XG4gICAgLy8gTiA9PT0gMCA9PiBEID09PSAwXG4gICAgaWYgKE4gPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIDAsIDApO1xuICAgIH0gLy8gZWxzZVxuICAgIC8vIEQgPT09IDAgPD0+IGFsbCB0aGUgZG9tYWluIHBvaW50cyBhcmUgdGhlIHNhbWVcbiAgICAvLyBXZSBndWVzcyB0aGUgdHJhbnNsYXRpb24gdG8gdGhlIG1lYW4gb2YgdGhlIHJhbmdlIHRvIGJlIHRoZSBiZXN0IGd1ZXNzLlxuICAgIC8vIEhlcmUgYSwgYiByZXByZXNlbnRzIHRoZSBtZWFuIG9mIGRvbWFpbiBwb2ludHMuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgKGMxIC8gTikgLSBhLCAoZDEgLyBOKSAtIGIpO1xuICB9XG5cbiAgLy8gRXN0aW1hdG9yc1xuICB2YXIgc2hhdCA9IChOMiAqIHEgLSBOICogKGExICogYzEgKyBiMSAqIGQxKSkgLyBEO1xuICB2YXIgdHhoYXQgPSAoLU4gKiBhMSAqIHEgKyBOICogYzEgKiBwIC0gYjEyICogYzEgKyBhMSAqIGIxICogZDEpIC8gRDtcbiAgdmFyIHR5aGF0ID0gKC1OICogYjEgKiBxICsgTiAqIGQxICogcCAtIGExMiAqIGQxICsgYTEgKiBiMSAqIGMxKSAvIEQ7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgMCwgdHhoYXQsIHR5aGF0KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIFt4LCB5XSAyRCBhcnJheXNcbiAgdmFyIFgsIFksIE4sIHMsIHIsIHR4LCB0eTtcblxuICAvLyBBbGlhc1xuICBYID0gZG9tYWluO1xuICBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICAvLyBJZiBsZW5ndGggaXMgemVybywgbm8gZXN0aW1hdGlvbiBjYW4gYmUgZG9uZS4gV2UgY2hvb3NlIHRoZSBpbmRlbnRpdHlcbiAgLy8gdHJhbnNmb3JtYXRpb24gYmUgdGhlIGJlc3QgcXVlc3MuXG4gIGlmIChOID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCwgMCk7XG4gIH0gLy8gZWxzZVxuXG4gIHZhciBpLCBhLCBiLCBjLCBkO1xuICB2YXIgYTEgPSAwO1xuICB2YXIgYjEgPSAwO1xuICB2YXIgYzEgPSAwO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgYTIgPSAwO1xuICB2YXIgYjIgPSAwO1xuICB2YXIgYWQgPSAwO1xuICB2YXIgYmMgPSAwO1xuICB2YXIgYWMgPSAwO1xuICB2YXIgYmQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSAxKSB7XG4gICAgYSA9IFhbaV1bMF07XG4gICAgYiA9IFhbaV1bMV07XG4gICAgYyA9IFlbaV1bMF07XG4gICAgZCA9IFlbaV1bMV07XG4gICAgYTEgKz0gYTtcbiAgICBiMSArPSBiO1xuICAgIGMxICs9IGM7XG4gICAgZDEgKz0gZDtcbiAgICBhMiArPSBhICogYTtcbiAgICBiMiArPSBiICogYjtcbiAgICBhZCArPSBhICogZDtcbiAgICBiYyArPSBiICogYztcbiAgICBhYyArPSBhICogYztcbiAgICBiZCArPSBiICogZDtcbiAgfVxuXG4gIC8vIERlbm9taW5hdG9yLlxuICAvLyBJdCBpcyB6ZXJvIGlmZiBYW2ldID0gWFtqXSBmb3IgZXZlcnkgaSBhbmQgaiBpbiBbMCwgbikuXG4gIC8vIEluIG90aGVyIHdvcmRzLCBpZmYgYWxsIHRoZSBkb21haW4gcG9pbnRzIGFyZSB0aGUgc2FtZSBvciB0aGVyZSBpcyBvbmx5IG9uZSBkb21haW4gcG9pbnQuXG4gIHZhciBkZW4gPSBOICogYTIgKyBOICogYjIgLSBhMSAqIGExIC0gYjEgKiBiMTtcblxuICB2YXIgZXBzID0gMC4wMDAwMDAwMTtcbiAgaWYgKC1lcHMgPCBkZW4gJiYgZGVuIDwgZXBzKSB7XG4gICAgLy8gVGhlIGRvbWFpbiBwb2ludHMgYXJlIHRoZSBzYW1lLlxuICAgIC8vIFdlIGd1ZXNzIHRoZSB0cmFuc2xhdGlvbiB0byB0aGUgbWVhbiBvZiB0aGUgcmFuZ2UgdG8gYmUgdGhlIGJlc3QgZ3Vlc3MuXG4gICAgLy8gSGVyZSBhLCBiIHJlcHJlc2VudHMgdGhlIG1lYW4gb2YgZG9tYWluIHBvaW50cy5cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAoYzEgLyBOKSAtIGEsIChkMSAvIE4pIC0gYik7XG4gIH1cblxuICAvLyBFc3RpbWF0b3JzXG4gIHMgPSAoTiAqIChhYyArIGJkKSAtIGExICogYzEgLSBiMSAqIGQxKSAvIGRlbjtcbiAgciA9IChOICogKGFkIC0gYmMpICsgYjEgKiBjMSAtIGExICogZDEpIC8gZGVuO1xuICB0eCA9ICgtYTEgKiAoYWMgKyBiZCkgKyBiMSAqIChhZCAtIGJjKSArIGEyICogYzEgKyBiMiAqIGMxKSAvIGRlbjtcbiAgdHkgPSAoLWIxICogKGFjICsgYmQpIC0gYTEgKiAoYWQgLSBiYykgKyBhMiAqIGQxICsgYjIgKiBkMSkgLyBkZW47XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ocywgciwgdHgsIHR5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICcxLjAuMSc7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXFJZFxuXG5mdW5jdGlvbiBTZXFJZChpbml0aWFsKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXFJZCkpIHtcbiAgICByZXR1cm4gbmV3IFNlcUlkKGluaXRpYWwpXG4gIH1cbiAgaWYgKGluaXRpYWwgPT0gbnVsbCkge1xuICAgIGluaXRpYWwgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBNYXRoLnBvdygyLCAzMilcbiAgfVxuICB0aGlzLl9pZCA9IGluaXRpYWwgfCAwXG59XG5TZXFJZC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faWQgPSAodGhpcy5faWQgKyAxKSB8IDBcbiAgcmV0dXJuIHRoaXMuX2lkXG59XG4iLCIvKlxuXG5WaWV3XG5cbiovXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VOb2RlID0gcmVxdWlyZSgnLi9TcGFjZU5vZGUnKTtcbnZhciBTcGFjZVBsYW5lID0gcmVxdWlyZSgnLi9TcGFjZVBsYW5lJyk7XG52YXIgVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL1RyYW5zZm9ybWVyJyk7XG52YXIgU3BhY2VSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1NwYWNlUmVjdGFuZ2xlJyk7XG52YXIgU3BhY2VUYWEgPSByZXF1aXJlKCcuL1NwYWNlVGFhJyk7XG52YXIgU3BhY2VIVE1MID0gcmVxdWlyZSgnLi9TcGFjZUhUTUwnKTtcbnZhciBtb3ZlID0gcmVxdWlyZSgnbW92ZWpzJyk7XG5cbi8vIERpc2FibGUgYW5pbWF0aW9ucyBieSBkZWZhdWx0LlxubW92ZS5kZWZhdWx0cyA9IHsgZHVyYXRpb246IDAgfTtcblxudmFyIEhUTUxTcGFjZVZpZXcgPSBmdW5jdGlvbiAoc3BhY2UsIGh0bWxDb250YWluZXIpIHtcbiAgLy8gVGVzdCBpZiB2YWxpZCBkb20gZWxlbWVudFxuICBpZiAoISgndGFnTmFtZScgaW4gaHRtbENvbnRhaW5lcikpIHtcbiAgICB0aHJvdyAnQ29udGFpbmVyIHNob3VsZCBiZSBhIERPTSBFbGVtZW50JztcbiAgfVxuXG4gIEVtaXR0ZXIodGhpcyk7XG4gIFNwYWNlTm9kZSh0aGlzKTtcbiAgU3BhY2VQbGFuZSh0aGlzKTtcbiAgVHJhbnNmb3JtZXIodGhpcyk7XG4gIFNwYWNlUmVjdGFuZ2xlKHRoaXMpO1xuICB2YXIgdGhpczIgPSB0aGlzO1xuXG4gIHRoaXMuX2VsID0gaHRtbENvbnRhaW5lcjtcblxuICAvLyBUd28gbWFwcGluZ3MgZnJvbSBzcGFjZSB0YWEgaWRzOlxuICAvLyAxLiB0byBIVE1MIGVsZW1lbnRzIG9mIHRoZSBzcGFjZSBub2Rlcy5cbiAgLy8gMi4gdG8gU3BhY2VOb2RlIGluc3RhbmNlc1xuICAvLyBEZXYgZGVjaXNpb246XG4gIC8vICAgRm9yIGRhdGEgc3RydWN0dXJlLCBkaWN0IG92ZXIgbGlzdCBiZWNhdXNlIGtleSBzZWFyY2ggdGltZSBjb21wbGV4aXR5LlxuICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuICB0aGlzLl9ub2RlcyA9IHt9O1xuXG4gIChmdW5jdGlvbiBpbml0U2l6ZSgpIHtcbiAgICB2YXIgdyA9IHRoaXMyLl9lbC5jbGllbnRXaWR0aDtcbiAgICB2YXIgaCA9IHRoaXMyLl9lbC5jbGllbnRIZWlnaHQ7XG4gICAgdGhpczIucmVzaXplKFt3LCBoXSk7XG4gIH0oKSk7XG5cbiAgdmFyIHRyYW5zZm9ybU5vZGUgPSBmdW5jdGlvbiAoaHRtbEVsZW1lbnQsIHNwYWNlTm9kZSkge1xuICAgIC8vIFRyYW5zZm9ybSBlbGVtZW50cyBiZWNhdXNlIHRoZSB2aWV3IG9yaWVudGF0aW9uLlxuICAgIC8vIFNlZSAyMDE2LTAzLTA1LTA5IGZvciBtYXRoLlxuICAgIHZhciBub2RlX2dsb2JhbF9UID0gc3BhY2VOb2RlLmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgIHZhciBUID0gdGhpczIuX1QuaW52ZXJzZSgpLm11bHRpcGx5Qnkobm9kZV9nbG9iYWxfVCk7XG4gICAgLy8gVE9ETyBXaGF0IGlmIHZpZXcgcGFyZW50IGlzIG5vdCB0aGUgcm9vdD9cbiAgICAvLyAgIFNvbHV0aW9uOiBnZXRUcmFuc2Zvcm1UbyhwbGFuZSlcbiAgICAvLyBUT0RPIEN1cnJlbnQgbW92ZS5qcyBkb2VzIG5vdCBwcmV2ZW50IHNjaWVudGlmaWMgbm90YXRpb24gcmVhY2hpbmcgQ1NTXG4gICAgLy8gd2hpY2ggbGVhZHMgdG8gcHJvYmxlbXMgd2l0aCBTYWZhcmkgYW5kIE9wZXJhLiBUaGVyZWZvcmUgd2UgbXVzdFxuICAgIC8vIHByZXZlbnQgdGhlIG5vdGF0aW9uIGhlcmUuXG4gICAgLy8gT2YgY291cnNlIHRoaXMgd2lsbCBjYXVzZSBlcnJvciBpbiB0aGUgcHJlc2VudGF0aW9uLlxuICAgIC8vIEhvd2V2ZXIgdGhlIGVycm9yIGlzIG9ubHkgaW4gdGhlIHByZXNlbnRhdGlvbiBhbmQgdGh1cyBub3QgYSBwcm9ibGVtLlxuICAgIHZhciBwcmVjID0gODtcbiAgICB2YXIgcyA9IFQucy50b0ZpeGVkKHByZWMpO1xuICAgIHZhciByID0gVC5yLnRvRml4ZWQocHJlYyk7XG4gICAgdmFyIHR4ID0gVC50eC50b0ZpeGVkKHByZWMpO1xuICAgIHZhciB0eSA9IFQudHkudG9GaXhlZChwcmVjKTtcbiAgICBtb3ZlKGh0bWxFbGVtZW50KS5tYXRyaXgocywgciwtciwgcywgdHgsIHR5KS5lbmQoKTtcbiAgfTtcblxuICB2YXIgZ2V0Vmlld1NwZWNpZmljSWQgPSBmdW5jdGlvbiAoc3BhY2VOb2RlSWQpIHtcbiAgICAvLyBFYWNoIHJlbmRlcmVkIGVsZW1lbnQgaGFzIG93biBJRC4gVGhlIElEIGRpZmZlcnMgZnJvbVxuICAgIC8vIHRoZSBpZCBvZiBzcGFjZSBub2RlcyBiZWNhdXNlIGEgc3BhY2Ugbm9kZSBjYW4gYmVjb21lXG4gICAgLy8gdmlzdWFsaXplZCB0aHJvdWdoIG11bHRpcGxlIHZpZXdzLlxuICAgIHJldHVybiB0aGlzMi5pZCArICcvJyArIHNwYWNlTm9kZUlkO1xuICB9O1xuXG4gIC8vIExpc3RlbiB0aGUgc3BhY2UgZm9yIG5ldyBvciByZW1vdmVkIHRhYXMgb3IgdHJhbnNmb3JtYXRpb25zXG5cbiAgdmFyIGNvbnRlbnRBZGRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoc3BhY2VOb2RlLCBuZXdQYXJlbnQsIG9sZFBhcmVudCkge1xuICAgIC8vIFBhcmFtZXRlcnM6XG4gICAgLy8gICBzcGFjZU5vZGU6IGEgU3BhY2VOb2RlIGkuZS4gdGhlIGNvbnRlbnQgdW5pdCB0aGF0IHdhcyBhZGRlZC5cbiAgICAvLyAgIG5ld1BhcmVudDogb3B0aW9uYWwuIFRoZSBuZXcgcGFyZW50IG9mIHRoZSBTcGFjZU5vZGVcbiAgICAvLyAgICAgTm90IHVzZWQgZm9yIGFueXRoaW5nIGZvciBub3cgYnV0IHByb2JhYmx5IGluIHRoZSBmdXR1cmUuXG4gICAgLy8gICBvbGRQYXJlbnQ6IG9wdGlvbmFsLiBUaGUgb2xkIHBhcmVudCBvZiB0aGUgU3BhY2VOb2RlLlxuICAgIC8vICAgICBOb3QgdXNlZCBmb3IgYW55dGhpbmcgZm9yIG5vdyBidXQgcHJvYmFibHkgaW4gdGhlIGZ1dHVyZS5cbiAgICBpZiAodHlwZW9mIG9sZFBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgb2xkUGFyZW50ID0gbnVsbDsgfVxuICAgIGlmICh0eXBlb2YgbmV3UGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBuZXdQYXJlbnQgPSBudWxsOyB9XG5cbiAgICB2YXIgbm9kZSwgZWwsIHdoO1xuXG4gICAgLy8gU3BhY2VWaWV3LCBTcGFjZVRhYSAuLi5cbiAgICBub2RlID0gc3BhY2VOb2RlO1xuXG4gICAgaWYgKHRoaXMyLl9lbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShub2RlLmlkKSkge1xuICAgICAgLy8gQ29udGVudCBpcyBhbHJlYWR5IGRyYXduLlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNwYWNlVGFhKSB7XG4gICAgICAgIGVsID0gbmV3IEltYWdlKDI1NiwgMjU2KTtcbiAgICAgICAgZWwuc3JjID0gbm9kZS50YWEuaW1hZ2Uuc3JjO1xuICAgICAgICBlbC5pZCA9IGdldFZpZXdTcGVjaWZpY0lkKG5vZGUuaWQpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSAndGFhc3BhY2UtdGFhJztcbiAgICAgICAgLy8gU2hvdyB0byBjbGllbnRcbiAgICAgICAgdGhpczIuX2VsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgLy8gTWFrZSByZWZlcmVuY2FibGVcbiAgICAgICAgdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdID0gZWw7XG4gICAgICAgIHRoaXMyLl9ub2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIC8vIE1ha2UgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgdHJhbnNmb3JtTm9kZShlbCwgbm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGFjZUhUTUwpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRhaW5lciBkaXYuXG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IG5vZGUuaHRtbDtcbiAgICAgICAgZWwuaWQgPSBnZXRWaWV3U3BlY2lmaWNJZChub2RlLmlkKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gJ3RhYXNwYWNlLWh0bWwnO1xuICAgICAgICAvLyBSZXNpemUsIGFuZCBsZXQgdGFhc3BhY2Ugc3R5bGVzIGRvIHRoZSByZXN0LlxuICAgICAgICB3aCA9IG5vZGUuZ2V0U2l6ZSgpO1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHdoWzBdICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gd2hbMV0gKyAncHgnO1xuICAgICAgICAvLyBUT0RPIHJlYWN0IHRvIHNpemUgY2hhbmdlXG4gICAgICAgIC8vIG9uIHJlc2l6ZSByZXNldCB0aGUgc3R5bGUud2lkdGggYW5kIHN0eWxlLmhlaWdodFxuICAgICAgICBub2RlLm9uKCdyZXNpemVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgICAgdmFyIHdoID0gbm9kZS5nZXRTaXplKCk7XG4gICAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3aFswXSArICdweCc7XG4gICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gd2hbMV0gKyAncHgnO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIHRoaXMyLl9lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIC8vIE1ha2UgcmVmZXJlbmNhYmxlXG4gICAgICAgIHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXSA9IGVsO1xuICAgICAgICB0aGlzMi5fbm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAvLyBNYWtlIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgIHRyYW5zZm9ybU5vZGUoZWwsIG5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTFNwYWNlVmlldykge1xuICAgICAgICAvLyBObyByZXByZXNlbnRhdGlvbiBmb3Igdmlld3MuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIFNwYWNlTm9kZSBzdWJ0eXBlOyBjYW5ub3QgcmVwcmVzZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBjb250ZW50UmVtb3ZlZEhhbmRsZXIgPSBmdW5jdGlvbiAoc3BhY2VOb2RlLCBvbGRQYXJlbnQsIG5ld1BhcmVudCkge1xuICAgIGlmICh0eXBlb2Ygb2xkUGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBvbGRQYXJlbnQgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVvZiBuZXdQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG5ld1BhcmVudCA9IG51bGw7IH1cblxuICAgIHZhciBzYW1lUm9vdCwgZWwsIG5vZGU7XG5cbiAgICBub2RlID0gc3BhY2VOb2RlOyAvLyBBbGlhc1xuXG4gICAgLy8gRGVjaWRlIHNhbWVSb290XG4gICAgaWYgKG9sZFBhcmVudCA9PT0gbnVsbCB8fCBuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHNhbWVSb290ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbWVSb290ID0gb2xkUGFyZW50LmdldFJvb3RQYXJlbnQoKSA9PT0gbmV3UGFyZW50LmdldFJvb3RQYXJlbnQoKTtcbiAgICB9XG5cbiAgICBpZiAoc2FtZVJvb3QpIHtcbiAgICAgIC8vIE5vIHJlYXNvbiB0byByZW1vdmUgYW5kIHRoZW4gYWRkIGFnYWluLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgcGFyZW50IGluIGRpZmZlcmVudCBzcGFjZSwgc28gbm90IGRpc3BsYXllZCBpbiB0aGlzIHZpZXcgYW55bW9yZS5cbiAgICAgIGlmICh0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkobm9kZS5pZCkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIEhUTUwgZWxlbWVudFxuICAgICAgICBlbCA9IHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXTtcbiAgICAgICAgdGhpczIuX2VsLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gbWVtb3J5LlxuICAgICAgICAvLyBKUyBmZWF0dXJlIG9mIGRlbGV0ZTogZG9lcyBub3QgdGhyb3cgaWYga2V5IGRvZXMgbm90IGV4aXN0XG4gICAgICAgIGRlbGV0ZSB0aGlzMi5fZWxlbWVudHNbbm9kZS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzMi5fbm9kZXNbbm9kZS5pZF07XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgdmFyIGNvbnRlbnRUcmFuc2Zvcm1lZEhhbmRsZXIgPSBmdW5jdGlvbiAoc3BhY2VOb2RlKSB7XG4gICAgLy8gVXBkYXRlIGNzcyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIHRoZXkgbXVzdCBhbHNvIGJlIHRyYW5zZm9ybWVkLlxuICAgIHZhciBub2RlcywgaSwgbm9kZSwgZWw7XG4gICAgbm9kZXMgPSBzcGFjZU5vZGUuZ2V0QWxsQ2hpbGRyZW4oKTtcbiAgICBub2Rlcy5wdXNoKHNwYWNlTm9kZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICh0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkobm9kZS5pZCkpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGFjZVRhYSkge1xuICAgICAgICAgIGVsID0gdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdO1xuICAgICAgICAgIC8vIE1ha2UgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICB0cmFuc2Zvcm1Ob2RlKGVsLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU3BhY2VIVE1MKSB7XG4gICAgICAgICAgZWwgPSB0aGlzMi5fZWxlbWVudHNbbm9kZS5pZF07XG4gICAgICAgICAgdHJhbnNmb3JtTm9kZShlbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZTogbm8gdHJhbnNmb3JtYWJsZSByZXByZXNlbnRhdGlvbiBmb3IgVmlld3MuXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFZpZXcgYWRkZWQgdG8gbmV3IHBhcmVudC5cbiAgdGhpcy5vbignYWRkZWQnLCBmdW5jdGlvbiAoc2VsZiwgbmV3UGFyZW50KSB7XG4gICAgLy8gVE9ETyBhZGQgY29udGVudCBvZiB0aGUgbmV3IHNwYWNlIGlmIHRoZSBzcGFjZSBjb250YWluc1xuICAgIC8vIG5vZGVzLlxuICAgIG5ld1BhcmVudC5vbignY29udGVudEFkZGVkJywgY29udGVudEFkZGVkSGFuZGxlcik7XG4gICAgbmV3UGFyZW50Lm9uKCdjb250ZW50UmVtb3ZlZCcsIGNvbnRlbnRSZW1vdmVkSGFuZGxlcik7XG4gICAgbmV3UGFyZW50Lm9uKCdjb250ZW50VHJhbnNmb3JtZWQnLCBjb250ZW50VHJhbnNmb3JtZWRIYW5kbGVyKTtcbiAgfSk7XG4gIC8vIFZpZXcgcmVtb3ZlZCBmcm9tIHBhcmVudC5cbiAgdGhpcy5vbigncmVtb3ZlZCcsIGZ1bmN0aW9uIChzZWxmLCBvbGRQYXJlbnQpIHtcbiAgICAvLyBUT0RPIHJlbW92ZSBjb250ZW50IG9mIHRoZSBvbGQgc3BhY2UuXG4gICAgb2xkUGFyZW50Lm9mZignY29udGVudEFkZGVkJywgY29udGVudEFkZGVkSGFuZGxlcik7XG4gICAgb2xkUGFyZW50Lm9mZignY29udGVudFJlbW92ZWQnLCBjb250ZW50UmVtb3ZlZEhhbmRsZXIpO1xuICAgIG9sZFBhcmVudC5vZmYoJ2NvbnRlbnRUcmFuc2Zvcm1lZCcsIGNvbnRlbnRUcmFuc2Zvcm1lZEhhbmRsZXIpO1xuICB9KTtcblxuICAvLyBJZiB0aGUgdmlldyBpcyB0cmFuc2Zvcm1lZCwgd2Ugb2YgY291cnNlIG5lZWQgdG8gcmV0cmFuc2Zvcm0gZXZlcnl0aGluZy5cbiAgdGhpcy5vbigndHJhbnNmb3JtZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkLCBlbGVtZW50LCBub2RlO1xuICAgIGZvciAoaWQgaW4gdGhpczIuX2VsZW1lbnRzKSB7XG4gICAgICBpZiAodGhpczIuX2VsZW1lbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICBlbGVtZW50ICA9IHRoaXMyLl9lbGVtZW50c1tpZF07XG4gICAgICAgIG5vZGUgPSB0aGlzMi5fbm9kZXNbaWRdO1xuICAgICAgICB0cmFuc2Zvcm1Ob2RlKGVsZW1lbnQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5nZXRFbGVtZW50QnlTcGFjZU5vZGUgPSBmdW5jdGlvbiAoc3BhY2VOb2RlKSB7XG4gICAgLy8gR2V0IEhUTUwgZWxlbWVudCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3BhY2UgdGFhLlxuICAgIGlmICh0aGlzLl9lbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShzcGFjZU5vZGUuaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHNbc3BhY2VOb2RlLmlkXTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5nZXRTcGFjZU5vZGVCeUVsZW1lbnRJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIC8vIEdldCBzcGFjZSB0YWEgYnkgSFRNTCBlbGVtZW50IGlkXG4gICAgLy8gUmV0dXJuIG51bGwgaWYgbm8gc3BhY2UgdGFhIGZvciBzdWNoIGlkLlxuICAgIHZhciBpID0gaWQuc3BsaXQoJy8nKTtcbiAgICB2YXIgc3BhY2VWaWV3SWQgPSBpWzBdO1xuICAgIHZhciBzcGFjZU5vZGVJZCA9IGlbMV07XG4gICAgaWYgKHRoaXMuaWQgPT09IHNwYWNlVmlld0lkKSB7XG4gICAgICBpZiAodGhpcy5fbm9kZXMuaGFzT3duUHJvcGVydHkoc3BhY2VOb2RlSWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1tzcGFjZU5vZGVJZF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHRoaXMuZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9O1xuXG4gIC8vIFZpZXcgcmVhZHkgdG8gYmUgYWRkZWQgdG8gU3BhY2UuXG4gIHRoaXMuc2V0UGFyZW50KHNwYWNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTFNwYWNlVmlldztcbiIsIi8qXG5FbWl0c1xuICBjb250ZW50QWRkZWRcbiAgY29udGVudFJlbW92ZWRcbiAgICBub3QgdGhyb3duIGlmIHRoZSBjb250ZW50IHRvIHJlbW92ZSBkaWQgbm90IGV4aXN0IGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgY29udGVudFRyYW5zZm9ybWVkXG4qL1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFNwYWNlTm9kZSA9IHJlcXVpcmUoJy4vU3BhY2VOb2RlJyk7XG52YXIgU3BhY2VQbGFuZSA9IHJlcXVpcmUoJy4vU3BhY2VQbGFuZScpO1xuXG52YXIgU3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gIEVtaXR0ZXIodGhpcyk7XG5cbiAgU3BhY2VOb2RlKHRoaXMpO1xuICAvLyBUT0RPIHJlbW92ZSBwb3NzaWJpbGl0eSB0byBhZGQgdG8gcGFyZW50LlxuXG4gIFNwYWNlUGxhbmUodGhpcyk7XG4gIC8vIFNwYWNlIGhhcyBjb25zdGFudCBpZGVudGl0eSB0cmFuc2Zvcm1hdGlvbiBfVFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZTtcbiIsIi8qXG4jIFNwYWNlRWxlbWVudFxuXG5BIEhUTUxFbGVtZW50IFsxXSBpbiB0aGUgc3BhY2UuXG5cblsxXSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnRcbiovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBTcGFjZU5vZGUgPSByZXF1aXJlKCcuL1NwYWNlTm9kZScpO1xudmFyIFNwYWNlUGxhbmUgPSByZXF1aXJlKCcuL1NwYWNlUGxhbmUnKTtcbnZhciBUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtZXInKTtcbnZhciBTcGFjZVJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vU3BhY2VSZWN0YW5nbGUnKTtcblxudmFyIFNwYWNlSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgLy8gUGFyYW1ldGVyczpcbiAgLy8gICBwYXJlbnQ6XG4gIC8vICAgICBhIFNwYWNlTm9kZVxuICAvLyAgIGh0bWw6XG4gIC8vICAgICBhIHN0cmluZywgY29udGFpbmluZyBodG1sXG4gIEVtaXR0ZXIodGhpcyk7XG4gIFNwYWNlTm9kZSh0aGlzKTtcbiAgU3BhY2VQbGFuZSh0aGlzKTtcbiAgVHJhbnNmb3JtZXIodGhpcyk7XG4gIFNwYWNlUmVjdGFuZ2xlKHRoaXMpO1xuXG4gIHRoaXMuaHRtbCA9IGh0bWw7XG4gIHRoaXMucmVzaXplKFsyNTYsIDI1Nl0pOyAgLy8gSW5pdGlhbCBlbGVtZW50IHNpemUuXG5cbiAgdGhpcy5zZXRQYXJlbnQocGFyZW50KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VIVE1MO1xuIiwiLypcbkVtaXRzXG4gIGNvbnRlbnRBZGRlZFxuICBjb250ZW50UmVtb3ZlZFxuICAgIG5vdCB0aHJvd24gaWYgdGhlIGNvbnRlbnQgdG8gcmVtb3ZlIGRpZCBub3QgZXhpc3QgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICBjb250ZW50VHJhbnNmb3JtZWRcbiovXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8vIFVuaXF1ZSBJRCBnZW5lcmF0b3IuIFVuaXF1ZSBvdmVyIHNlc3Npb24uXG4vLyBVc2FnZTogc2VxaWQubmV4dCgpXG4vLyBSZXR1cm46IGludFxudmFyIHNlcWlkID0gcmVxdWlyZSgnc2VxaWQnKSgwKTtcblxudmFyIFNwYWNlTm9kZSA9IGZ1bmN0aW9uIChlbWl0dGVyKSB7XG4gIC8vIFBhcmFtZXRlcnNcbiAgLy8gICBlbWl0dGVyLCBhbiBFbWl0dGVyLlxuXG4gIC8vIEVhY2ggbm9kZSBoYXMgYW4gaWQuIFRoYXQgaXMgdXNlZCBieSB0aGUgcGFyZW50IG5vZGVzIGFuZCBpbiB2aWV3cy5cbiAgZW1pdHRlci5pZCA9IHNlcWlkLm5leHQoKS50b1N0cmluZygpO1xuXG4gIC8vIE5vZGVzIHdpdGggbnVsbCBwYXJlbnQgYXJlIHJvb3Qgbm9kZXMgaS5lLiBzcGFjZXMuXG4gIC8vIFNwYWNlTm9kZSNyZW1vdmUgc2V0cyBfcGFyZW50IHRvIG51bGwuXG4gIGVtaXR0ZXIuX3BhcmVudCA9IG51bGw7XG5cbiAgLy8gRGljdCBvdmVyIGxpc3QgYmVjYXVzZSBrZXkgc2VhcmNoIHRpbWUgY29tcGxleGl0eVxuICBlbWl0dGVyLl9jaGlsZHJlbiA9IHt9O1xuXG4gIC8vIFdlIG5lZWQgdG8gc3RvcmUgYnVpbHQgaGFuZGxlcnMgYm91bmQgdG8gY2hpbGRyZW5cbiAgLy8gdG8gYmUgYWJsZSB0byByZW1vdmUgdGhlIGhhbmRsZXJzIHdoZW4gY2hpbGQgaXMgcmVtb3ZlZC5cbiAgZW1pdHRlci5fYWRkZWRIYW5kbGVycyA9IHt9O1xuICBlbWl0dGVyLl9yZW1vdmVkSGFuZGxlcnMgPSB7fTtcbiAgZW1pdHRlci5fdHJhbnNmb3JtZWRIYW5kbGVycyA9IHt9O1xuXG4gIGVtaXR0ZXIuaGFzID0gZnVuY3Rpb24gKHNwYWNlTm9kZSkge1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgdHJ1ZSBpZiBzcGFjZXRhYSBpbiBzcGFjZVxuICAgIHJldHVybiBzcGFjZU5vZGUuX3BhcmVudCA9PT0gdGhpcztcbiAgfTtcblxuICBlbWl0dGVyLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICB9O1xuXG4gIGVtaXR0ZXIuZ2V0Um9vdFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50LmdldFJvb3RQYXJlbnQoKTtcbiAgfTtcblxuICBlbWl0dGVyLmdldENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBjaGlsZCBTcGFjZU5vZGVzIGluIGEgbGlzdC5cbiAgICAvLyBEb2VzIG5vdCBpbmNsdWRlIHRoZSBjaGlsZHJlbiBvZiB0aGUgY2hpbGRyZW4uXG4gICAgdmFyIGlkLCBhcnIsIG9iajtcbiAgICBhcnIgPSBbXTtcbiAgICBvYmogPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBmb3IgKGlkIGluIG9iaikge1xuICAgICAgYXJyLnB1c2gob2JqW2lkXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH07XG5cbiAgZW1pdHRlci5nZXRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBbGwgZGVzY2VuZGFudHMgaW4gYSBsaXN0LCBpbmNsdWRpbmcgdGhlIGNoaWxkcmVuLlxuICAgIHZhciBpLCBjaGlsZHJlbiwgY2hpbGQsIGFycjtcbiAgICBhcnIgPSBbXTtcbiAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBhcnIgPSBhcnIuY29uY2F0KGNoaWxkLCBjaGlsZC5nZXRBbGxDaGlsZHJlbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBlbWl0dGVyLnNldFBhcmVudCA9IGZ1bmN0aW9uIChuZXdQYXJlbnQpIHtcbiAgICAvLyBBZGQgdG8gbmV3IHBhcmVudC5cblxuICAgIHZhciBvbGRQYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cbiAgICBpZiAob2xkUGFyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAobmV3UGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIEZyb20gcm9vdCB0byByb290LlxuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGcm9tIHJvb3QgdG8gY2hpbGQuXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9hZGRDaGlsZCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbWl0KCdhZGRlZCcsIHRoaXMsIHRoaXMuX3BhcmVudCwgbnVsbCk7XG4gICAgICAgIG5ld1BhcmVudC5lbWl0KCdjb250ZW50QWRkZWQnLCB0aGlzLCB0aGlzLl9wYXJlbnQsIG51bGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3UGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIEZyb20gY2hpbGQgdG8gcm9vdC5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDsgLy8gQmVjb21lcyBuZXcgcm9vdCBub2RlLlxuICAgICAgICBvbGRQYXJlbnQuX3JlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG51bGwpO1xuICAgICAgICBvbGRQYXJlbnQuZW1pdCgnY29udGVudFJlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRnJvbSBjaGlsZCB0byBjaGlsZC5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICBvbGRQYXJlbnQuX3JlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBuZXdQYXJlbnQuX2FkZENoaWxkKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG5ld1BhcmVudCk7XG4gICAgICAgIHRoaXMuZW1pdCgnYWRkZWQnLCB0aGlzLCBuZXdQYXJlbnQsIG9sZFBhcmVudCk7XG4gICAgICAgIC8vIFdpdGggYm90aCBvbGRQYXJlbnQgYW5kIG5ld1BhcmVudCwgU3BhY2VWaWV3IGlzIGFibGUgdG9cbiAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgdG8ga2VlcCBzYW1lIEhUTUxFbGVtZW50IG9yIHJlY3JlYXRlIGl0LlxuICAgICAgICBvbGRQYXJlbnQuZW1pdCgnY29udGVudFJlbW92ZWQnLCB0aGlzLCBvbGRQYXJlbnQsIG5ld1BhcmVudCk7XG4gICAgICAgIG5ld1BhcmVudC5lbWl0KCdjb250ZW50QWRkZWQnLCB0aGlzLCBuZXdQYXJlbnQsIG9sZFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgZW1pdHRlci5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVtb3ZlIHRoaXMgc3BhY2Ugbm9kZSBmcm9tIGl0cyBwYXJlbnQuXG4gICAgLy8gUmV0dXJuOiBzZWUgc2V0UGFyZW50XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyZW50KG51bGwpO1xuICB9O1xuXG4gIGVtaXR0ZXIuX2FkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gVG8gYmUgY2FsbGVkIGZyb20gY2hpbGQuc2V0UGFyZW50KCkuXG4gICAgLy9cbiAgICAvLyBQYXJhbWV0ZXJzXG4gICAgLy8gICBjaGlsZCwgQSBTcGFjZU5vZGVcbiAgICAvL1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgdW5kZWZpbmVkXG4gICAgLy9cbiAgICAvLyBEZXYuIG5vdGU6XG4gICAgLy8gICBQcmV2aW91c2x5IHRoaXMgd2FzIGNhbGxlZCBmcm9tIHRoZSBTcGFjZU5vZGUgY29uc3RydWN0b3IuXG4gICAgLy8gICBIb3dldmVyLCBiZWNhdXNlIFNwYWNlTm9kZSB1cGdyYWRlIGlzIGRvbmUgYmVmb3JlIG90aGVyXG4gICAgLy8gICB1cGdyYWRlcywgdGhlIGNoaWxkIHdvdWxkIG5vdCBiZSByZWFkeSB0byBiZSBhZGRlZCB0byBwYXJlbnQuXG5cbiAgICB2YXIgc2MgPSBjaGlsZDsgLy8gYWxpYXNcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9jaGlsZHJlbltzYy5pZF0gPSBzYztcblxuICAgIC8vIFN0YXJ0IHRvIGxpc3RlbiBpZiBjaGlsZCBoYXMgYmVlZCBhZGRlZCwgcmVtb3ZlZCBvciB0cmFuc2Zvcm1lZFxuICAgIHZhciBhZGRlZEhhbmRsZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgc2VsZi5lbWl0KCdjb250ZW50QWRkZWQnLCBhLCBiLCBjKTtcbiAgICB9O1xuICAgIHZhciByZW1vdmVkSGFuZGxlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICBzZWxmLmVtaXQoJ2NvbnRlbnRSZW1vdmVkJywgYSwgYiwgYyk7XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtZWRIYW5kbGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHNlbGYuZW1pdCgnY29udGVudFRyYW5zZm9ybWVkJywgYSwgYiwgYyk7XG4gICAgfTtcbiAgICAvLyBhZGRlZCBhbmQgcmVtb3ZlZCBldmVudHMgYXJlIG5vdCBsaXN0ZW5lZCBiZWNhdXNlXG4gICAgLy8gZm9yIGFmdGVyIHN1Y2Nlc3NmdWxseSBtYWRlIGFkZCBvciByZW1vdmUsXG4gICAgLy8gY29udGVudEFkZGVkIGFuZCBjb250ZW50UmVtb3ZlZCBhcmUgZmlyZWQgaW4gc2V0UGFyZW50LlxuICAgIHNjLm9uKCdjb250ZW50QWRkZWQnLCBhZGRlZEhhbmRsZXIpO1xuICAgIHNjLm9uKCdjb250ZW50UmVtb3ZlZCcsIHJlbW92ZWRIYW5kbGVyKTtcbiAgICBzYy5vbigndHJhbnNmb3JtZWQnLCB0cmFuc2Zvcm1lZEhhbmRsZXIpO1xuICAgIHNjLm9uKCdjb250ZW50VHJhbnNmb3JtZWQnLCB0cmFuc2Zvcm1lZEhhbmRsZXIpO1xuICAgIHRoaXMuX2FkZGVkSGFuZGxlcnNbc2MuaWRdID0gYWRkZWRIYW5kbGVyO1xuICAgIHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF0gPSByZW1vdmVkSGFuZGxlcjtcbiAgICB0aGlzLl90cmFuc2Zvcm1lZEhhbmRsZXJzW3NjLmlkXSA9IHRyYW5zZm9ybWVkSGFuZGxlcjtcbiAgfTtcblxuICBlbWl0dGVyLl9yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIFRvIGJlIGNhbGxlZCBmcm9tIFNwYWNlTm9kZSNyZW1vdmVcbiAgICAvLyBQcmVjb25kaXRpb246IGNoaWxkIGluIHNwYWNlXG4gICAgdmFyIHNjLCBoO1xuXG4gICAgc2MgPSBjaGlsZDsgLy8gYWxpYXNcbiAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bc2MuaWRdO1xuXG4gICAgLy8gUmVtb3ZlIGhhbmRsZXJzXG4gICAgaCA9IHRoaXMuX2FkZGVkSGFuZGxlcnNbc2MuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLl9hZGRlZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBzYy5vZmYoJ2NvbnRlbnRBZGRlZCcsIGgpO1xuXG4gICAgaCA9IHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgZGVsZXRlIHRoaXMuX3JlbW92ZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgc2Mub2ZmKCdjb250ZW50UmVtb3ZlZCcsIGgpO1xuXG4gICAgaCA9IHRoaXMuX3RyYW5zZm9ybWVkSGFuZGxlcnNbc2MuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLl90cmFuc2Zvcm1lZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBzYy5vZmYoJ3RyYW5zZm9ybWVkJywgaCk7XG4gICAgc2Mub2ZmKCdjb250ZW50VHJhbnNmb3JtZWQnLCBoKTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VOb2RlO1xuIiwiLypcblNwYWNlUGxhbmVcbkFQSSB2MC42LjBcblxuQSBTcGFjZVBsYW5lIHJlcHJlc2VudHMgYSBjb29yZGluYXRlIHN5c3RlbS4gSXQgZG9lcyBub3QgaW5jbHVkZVxubWV0aG9kcyB0byB0cmFuc2Zvcm0gdGhlIHN5c3RlbS4gU3BhY2VQbGFuZSBhbmQgVHJhbnNmb3JtZXIgYXJlIHNlcGFyYXRlZFxuYmVjYXVzZSB3ZSB3YW50IHRvIGhhdmUgcGxhbmVzIHRoYXQgY2Fubm90IGJlIHRyYW5zZm9ybWVkLCBhcyB0aGUgU3BhY2UuXG5cbiovXG5cbnZhciBudWRnZWQgPSByZXF1aXJlKCdudWRnZWQnKTtcbnZhciBTcGFjZVBvaW50ID0gcmVxdWlyZSgnLi9TcGFjZVBvaW50Jyk7XG5cbnZhciBhdCA9IGZ1bmN0aW9uICh4eSkge1xuICAvLyBSZXR1cm5cbiAgLy8gICBBIFNwYWNlUG9pbnQgYXQgKHgseSkgb24gdGhlIHBsYW5lLlxuICBpZiAoeHkubGVuZ3RoICE9PSAyKSB7ICAvLyBERUJVRyBUT0RPIHJlbW92ZSB0aGlzXG4gICAgdGhyb3cgJ0ludmFsaWQgcG9pbnQsIHVzZSBhcnJheSBbeCwgeV0nO1xuICB9XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eSwgdGhpcyk7ICAvLyBOb3RlOiB0aGlzID09PSBzcGFjZU5vZGVcbn07XG5cbnZhciBTcGFjZVBsYW5lID0gZnVuY3Rpb24gKHNwYWNlTm9kZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgc3BhY2VOb2RlXG4gIC8vICAgICBBIFNwYWNlTm9kZSB0byBtb25rZXkgcGF0Y2ggdG8gU3BhY2VQbGFuZVxuXG4gIC8vIENvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24uXG4gIC8vIFRoZSB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBwbGFuZSB0byB0aGUgcGFyZW50IChzcGFjZSkuXG4gIC8vIFNlZSAyMDE2LTAzLTA1LTA5XG4gIC8vIExldDpcbiAgLy8gICB4X3NwYWNlLCBhIHBvaW50IGluIHNwYWNlXG4gIC8vICAgeF9wbGFuZSwgYSBwb2ludCBvbiB0aGUgcGxhbmUuXG4gIC8vICAgVCwgdGhlIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHBsYW5lXG4gIC8vIFRoZW46XG4gIC8vICAgeF9zcGFjZSA9IFQgKiB4X3BsYW5lXG4gIC8vXG4gIC8vIEZvciBTcGFjZSwgaXQgaXMgb2J2aW91c2x5IHRoZSBpZGVudGl0eSB0cmFuc2Zvcm06XG4gIC8vICAgeF9zcGFjZSA9IFQgKiB4X3NwYWNlXG4gIHNwYWNlTm9kZS5fVCA9IG51ZGdlZC5UcmFuc2Zvcm0uSURFTlRJVFk7IC8vIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uXG5cbiAgc3BhY2VOb2RlLmF0ID0gYXQ7XG5cbiAgc3BhY2VOb2RlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBMb2NhbCB0cmFuc2Zvcm0gZnJvbSBwbGFuZSB0byBwYXJlbnRcbiAgICAvL1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgdHJhbnNmb3JtYXRpb24gZnJvbSBwbGFuZSB0byBwYXJlbnQsIGkuZS5cbiAgICAvLyAgICAgeHlfcGFyZW50ID0gVCAqIHh5X3BsYW5lXG4gICAgLy8gTmVlZGVkIHdoZW4gd2Ugd2FudCB0byBzdG9yZSB0cmFuc2Zvcm1lcidzIHBvc2l0aW9uIGZvciBsYXRlciB1c2UuXG4gICAgcmV0dXJuIHRoaXMuX1Q7XG4gIH07XG5cbiAgc3BhY2VOb2RlLmdldEdsb2JhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIHBsYW5lIHRvIHJvb3QgY29udGFpbmVyLlxuICAgIC8vXG4gICAgLy8gRGV2IG5vdGU6XG4gICAgLy8gICBMb2NhbCB0cmFuc2Zvcm1hdGlvbnMgZ28gbGlrZTpcbiAgICAvLyAgICAgeHlfcGFyZW50ID0gVF9wbGFuZSAqIHh5X3BsYW5lXG4gICAgLy8gICAgIHh5X3BhcmVudF9wYXJlbnQgPSBUX3BhcmVudCAqIHh5X3BhcmVudFxuICAgIC8vICAgICAuLi5cbiAgICAvLyAgICAgeHlfcm9vdCA9IFRfcGFyZW50X3BhcmVudC4uLl9wYXJlbnQgKiB4eV9wYXJlbnRfcGFyZW50Li4uX3BhcmVudFxuICAgIC8vICAgVGhlcmVmb3JlIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBpczpcbiAgICAvLyAgICAgeHlfcm9vdCA9IFRfcGFyZW50Xy4uLl9wYXJlbnQgKiAuLi4gKiBUX3BhcmVudCAqIFRfcGxhbmUgKiB4eV9wbGFuZVxuICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gbWF5YmUgdG9vIGZhcjogdGhpcy5fcGFyZW50Ll9wYXJlbnQgbWlnaHQgYmUgc3VmZmljaWVudC5cbiAgICAgIHJldHVybiB0aGlzLl9UO1xuICAgIH0gLy8gZWxzZVxuICAgIHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0R2xvYmFsVHJhbnNmb3JtKCkubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgfTtcblxuICBzcGFjZU5vZGUucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQmVjb21lIHNwYWNlLiBDYWxsZWQgZS5nLiB3aGVuIHBsYW5lIGlzIHJlbW92ZWQgZnJvbSBwYXJlbnQuXG4gICAgdGhpcy5fVCA9IG51ZGdlZC5UcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VQbGFuZTtcbiIsIi8vIEFQSSB2MC42LjBcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbnZhciBTcGFjZVBvaW50ID0gZnVuY3Rpb24gKHh5LCByZWZlcmVuY2UpIHtcbiAgLy8gRXhhbXBsZVxuICAvLyAgIHZhciBwID0gdGFhc3BhY2UuU3BhY2VQb2ludChbeCwgeV0sIHRhYSk7XG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHh5XG4gIC8vICAgICAyRCBhcnJheVxuICAvLyAgIHJlZmVyZW5jZVxuICAvLyAgICAgYSBTcGFjZU5vZGUgb3IgU3BhY2VQb2ludFxuICAvLyAgICAgICBhbiBpdGVtIGluIHNwYWNlLCBlbmFibGluZyBjb29yZCBwcm9qZWN0aW9ucy5cbiAgdGhpcy54eSA9IHh5O1xuXG4gIC8vIFRoZSBTcGFjZVBsYW5lJ3MgdHJhbnNmb3JtYXRpb24gdGhlIHh5IGFyZSBvbi5cbiAgLy8gRGVzaWduIG5vdGU6IGF0IGZpcnN0LCB0aGUgcmVmZXJlbmNlcyB3ZXJlIFNwYWNlUGxhbmVzIGFuZCBub3RcbiAgLy8gdHJhbnNmb3JtYXRpb25zLiBCdXQgYmVjYXVzZSBhIFNwYWNlUGxhbmUgY2FuIG1vdmUgb3IgYmUgcmVtb3ZlZCxcbiAgLy8gd2UgY2hvc2Ugb25seSB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYmUgcmVtZW1iZXJlZC5cbiAgLy8gRGVzaWduIG5vdGU6IGxhdGVyIHdlIGZvdW5kIGl0IHdvdWxkIGJlIGNvbnZlbmllbnQgZm9yIGRlYnVnZ2luZ1xuICAvLyB0byBrbm93IHdoZXJlIHRoZSBwb2ludCBjYW1lIGZyb20sIHdoaWNoIGxlZCB0byB0aGlzLl9vcmlnaW4uXG4gIC8vIEFmdGVyIHRoYXQgd2UgZm91bmQgdGhhdCBpbiB0b1NwYWNlIG1ldGhvZCwgd2Ugd291bGQgbmVlZCByZWZlcmVuY2VcbiAgLy8gdG8gc3BhY2UsIGFsdGhvdWdoIHdlIG9ubHkgaGF2ZSBpbXBsaWNpdCByZWZlcmVuY2UgdG8gaXRzIGNvb3Jkcy5cbiAgLy8gVGhlcmVmb3JlIHRoaXMuX29yaWdpbiB3YXMgZHJvcHBlZC5cblxuICBpZiAocmVmZXJlbmNlLmhhc093blByb3BlcnR5KCdnZXRHbG9iYWxUcmFuc2Zvcm0nKSkge1xuICAgIC8vIElzIGEgU3BhY2VQbGFuZVxuICAgIHRoaXMuX1QgPSByZWZlcmVuY2UuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgYSBTcGFjZVBvaW50XG4gICAgdGhpcy5fVCA9IHJlZmVyZW5jZS5fVDtcbiAgfVxufTtcblxudmFyIHByb3RvID0gU3BhY2VQb2ludC5wcm90b3R5cGU7XG5cblxucHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAvLyBDcmVhdGUgYSBuZXcgcG9pbnQgbmVhcmJ5LlxuICAvL1xuICAvLyBQYXJhbWV0ZXJcbiAgLy8gICBkeFxuICAvLyAgICAgTW92ZW1lbnQgdG93YXJkcyBwb3NpdGl2ZSB4XG4gIC8vICAgZHlcbiAgLy8gICAgIC4uLlxuICB2YXIgeHkgPSBbdGhpcy54eVswXSArIGR4LCB0aGlzLnh5WzFdICsgZHldO1xuICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoeHksIHRoaXMpO1xufTtcblxucHJvdG8ucG9sYXJPZmZzZXQgPSBmdW5jdGlvbiAocmFkaXVzLCByYWRpYW5zKSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBwb2ludCBtb3ZlZCBieSB0aGUgcG9sYXIgY29vcmRpbmF0ZXNcbiAgdmFyIHggPSB0aGlzLnh5WzBdICsgcmFkaXVzICogTWF0aC5jb3MocmFkaWFucyk7XG4gIHZhciB5ID0gdGhpcy54eVsxXSArIHJhZGl1cyAqIE1hdGguc2luKHJhZGlhbnMpO1xuICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3gsIHldLCB0aGlzKTtcbn07XG5cbnByb3RvLmVxdWFscyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICByZXR1cm4gKHRoaXMueHlbMF0gPT09IHBvaW50Lnh5WzBdICYmXG4gICAgICAgICAgdGhpcy54eVsxXSA9PT0gcG9pbnQueHlbMV0gJiZcbiAgICAgICAgICB0aGlzLl9ULmVxdWFscyhwb2ludC5fVCkpO1xufTtcblxucHJvdG8udG8gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBTcGFjZVBvaW50IGF0IHNhbWUgbG9jYXRpb24gYnV0IG9uIGFcbiAgLy8gZGlmZmVyZW50IFNwYWNlUGxhbmUuXG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHRhcmdldCwgYSBTcGFjZVBsYW5lIG9yIG51bGwuXG4gIC8vXG4gIC8vIEltcGxlbWVudGF0aW9uIG5vdGUgKFNlZSAyMDE2LTAzLTA1LTA5KTpcbiAgLy9cbiAgLy8gRmlyc3QsIGNvbXB1dGUgY29vcmQuIHRyYW5zZi4gQiBmcm9tIHRoZSBjdXJyZW50IHBsYW5lXG4gIC8vIHRvIHRoZSBzcGFjZTpcbiAgLy8gICB4X3NwYWNlID0gQiAqIHhfcGxhbmUgIDw9PiAgeF9wbGFuZSA9IGludihCKSAqIHhfc3BhY2VcbiAgLy8gICBCID0gcGxhbmUuX1RcbiAgLy8gU2Vjb25kLCBsZXQgQSBiZSBjb29yZC4gdHJhbnNmLiBmcm9tIHRoZSBzcGFjZSB0byB0aGUgdGFyZ2V0IHBsYW5lOlxuICAvLyAgIHhfdGFyZ2V0ID0gQSAqIHhfc3BhY2VcbiAgLy8gICBBID0gaW52KHRhcmdldC5fVClcbiAgLy8gVGhlcmVmb3JlIGNvbWJpbmVkIGNvb3JkLiB0cmFuc2YuIEMgZnJvbSB0aGUgY3Vyci4gcGxhbmUgdG8gdGhlIHRhcmdldDpcbiAgLy8gICB4X3RhcmdldCA9IEMgKiB4X3BsYW5lXG4gIC8vICAgPD0+IEEgKiB4X3NwYWNlID0gQyAqIGludihCKSAqIHhfc3BhY2VcbiAgLy8gICA8PT4gQSA9IEMgKiBpbnYoQilcbiAgLy8gICA8PT4gQyA9IEFCXG4gIC8vICAgPD0+IEMgPSBpbnYodGFyZ2V0Ll9UKSAqIHBsYW5lLl9UXG4gIC8vXG5cbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIHRhcmdldCBpcyB0aGUgcm9vdCBub2RlIChzcGFjZSlcbiAgICByZXR1cm4gdGhpcy50b1NwYWNlKCk7XG4gIH1cblxuICAvLyBUYXJnZXQncyBnbG9iYWwgdHJhbnNmb3JtYXRpb24uIFRoaXMuX1QgaXMgYWxyZWFkeSBnbG9iYWwuXG4gIHZhciB0YXJnZXRfZ1QgPSB0YXJnZXQuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG5cbiAgaWYgKHRhcmdldF9nVC5lcXVhbHModGhpcy5fVCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBlbHNlXG4gIHZhciBDID0gdGFyZ2V0X2dULmludmVyc2UoKS5tdWx0aXBseUJ5KHRoaXMuX1QpO1xuICB2YXIgeHlfdGFyZ2V0ID0gQy50cmFuc2Zvcm0odGhpcy54eSk7XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eV90YXJnZXQsIHRhcmdldCk7XG59O1xuXG5wcm90by50b1NwYWNlID0gZnVuY3Rpb24gKCkge1xuICAvLyBDcmVhdGUgYSBuZXcgU3BhY2VQb2ludCBhdCBzYW1lIGxvY2F0aW9uIGJ1dCByZXByZXNlbnRlZCBvbiBzcGFjZSBjb29yZHMuXG4gIC8vXG4gIC8vIEltcGxlbWVudGF0aW9uIG5vdGU6XG4gIC8vICAgV2UgYWxyZWFkeSBoYXZlIGNvb3JkLiB0cmFuc2YuIGZyb20gdGhlIGN1cnJlbnQgcGxhbmUgdG8gdGhlIHNwYWNlOlxuICAvLyAgICAgcGxhbmUuX1RcbiAgdmFyIHh5X3NwYWNlID0gdGhpcy5fVC50cmFuc2Zvcm0odGhpcy54eSk7XG4gIHZhciBzcGFjZV9tb2NrID0geydfVCc6IFRyYW5zZm9ybS5JREVOVElUWX07XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eV9zcGFjZSwgc3BhY2VfbW9jayk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHIpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IGJ5IHRyYW5zZm9ybWF0aW9uLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJcbiAgLy8gICB0clxuICAvLyAgICAgYSBUcmFuc2Zvcm1cbiAgdmFyIHh5X2hhdCA9IHRyLnRyYW5zZm9ybSh0aGlzLnh5KTtcbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5X2hhdCwgdGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VQb2ludDtcbiIsIi8vIEFQSSB2MC42LjBcblxudmFyIFNwYWNlUG9pbnQgPSByZXF1aXJlKCcuL1NwYWNlUG9pbnQnKTtcblxudmFyIFNwYWNlUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHRyYW5zZm9ybWVyKSB7XG5cbiAgdmFyIHQgPSB0cmFuc2Zvcm1lcjsgIC8vIEFsaWFzXG5cbiAgLy8gUmVjdGFuZ2xlcyBoYXZlIHNpemUuXG4gIC8vIEluIGl0cyBvd24gY29vcmRpbmF0ZXMsIHJlY3RhbmdsZSdzIHJpZ2h0IGJvdHRvbSBjb3JuZXJcbiAgLy8gaXMgbG9jYXRlZCBhdCBbd2lkdGgsIGhlaWdodF0uXG4gIC8vIEJ5IGRlZmF1bHQgdHJhbnNmb3JtYXRpb24sIHdpZHRoIDEgYW5kIGhlaWdodCAxIGVxdWFsIHRvIDEgc3BhY2UgdW5pdC5cbiAgdmFyIHdpZHRoID0gMTtcbiAgdmFyIGhlaWdodCA9IDE7XG5cbiAgdC5yZXNpemUgPSBmdW5jdGlvbiAoZGltZW5zaW9ucykge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgZGltZW5zaW9ucywgW3dpZHRoLCBoZWlnaHRdXG4gICAgd2lkdGggPSBkaW1lbnNpb25zWzBdO1xuICAgIGhlaWdodCA9IGRpbWVuc2lvbnNbMV07XG5cbiAgICB0aGlzLmVtaXQoJ3Jlc2l6ZWQnLCB0KTtcbiAgfTtcblxuICB0LmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgfTtcblxuICB0LmF0Tm9ybSA9IGZ1bmN0aW9uICh4eSkge1xuICAgIC8vIFJldHVybiBhIFNwYWNlUG9pbnQgYnkgY29vcmRpbmF0ZXMgbm9ybWFsaXplZCBhYm91dCB0aGUgc2l6ZS5cbiAgICAvLyBhdE5vcm0oWzEsMF0pIHJldHVybnMgdGhlIHBvaW50IGF0IHRoZSByaWdodCB1cHBlciBjb3JuZXIuXG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCAqIHh5WzBdLCBoZWlnaHQgKiB4eVsxXV0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoIC8gMiwgMF0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWRXID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbMCwgaGVpZ2h0IC8gMl0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWRFID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGgsIGhlaWdodCAvIDJdLCB0KTtcbiAgfTtcblxuICB0LmF0TWlkUyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoIC8gMiwgaGVpZ2h0XSwgdCk7XG4gIH07XG5cbiAgdC5hdE5XID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbMCwgMF0sIHQpO1xuICB9O1xuXG4gIHQuYXRORSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoLCAwXSwgdCk7XG4gIH07XG5cbiAgdC5hdFNXID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbMCwgaGVpZ2h0XSwgdCk7XG4gIH07XG5cbiAgdC5hdFNFID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGgsIGhlaWdodF0sIHQpO1xuICB9O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlUmVjdGFuZ2xlO1xuIiwiLy8gQVBJIHYwLjYuMFxuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VOb2RlID0gcmVxdWlyZSgnLi9TcGFjZU5vZGUnKTtcbnZhciBTcGFjZVBsYW5lID0gcmVxdWlyZSgnLi9TcGFjZVBsYW5lJyk7XG52YXIgVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL1RyYW5zZm9ybWVyJyk7XG52YXIgU3BhY2VSZWN0YW5nbGUgPSByZXF1aXJlKCcuL1NwYWNlUmVjdGFuZ2xlJyk7XG5cbnZhciBTcGFjZVRhYSA9IGZ1bmN0aW9uIChwYXJlbnQsIHRhYSkge1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAgIHBhcmVudFxuICAvLyAgICAgYSBTcGFjZU5vZGVcbiAgLy8gICB0YWFcbiAgLy8gICAgIGEgVGFhXG4gIEVtaXR0ZXIodGhpcyk7XG4gIFNwYWNlTm9kZSh0aGlzKTtcbiAgU3BhY2VQbGFuZSh0aGlzKTtcbiAgVHJhbnNmb3JtZXIodGhpcyk7XG4gIFNwYWNlUmVjdGFuZ2xlKHRoaXMpO1xuXG4gIHRoaXMudGFhID0gdGFhO1xuICB0aGlzLnJlc2l6ZShbMjU2LCAyNTZdKTsgIC8vIFNpemUgb2YgdGFhLlxuXG4gIHRoaXMuc2V0UGFyZW50KHBhcmVudCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlVGFhO1xuIiwiLy8gQVBJIHYwLjYuMFxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGxvYWRpbWFnZXMgPSByZXF1aXJlKCdsb2FkaW1hZ2VzJyk7XG5cbnZhciBOT09QID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBUYWEgPSBmdW5jdGlvbiAoaW1nU3JjLCBvbkxvYWRlZCkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgaW1nU3JjXG4gIC8vICAgb25Mb2FkZWQoZXJyLCB0YWEpXG4gIC8vICAgICBvcHRpb25hbCwgZnVuY3Rpb24gKHRhYSlcbiAgRW1pdHRlcih0aGlzKTtcbiAgdmFyIHRoaXMyID0gdGhpcztcblxuICAvLyBvbkxvYWRlZCBpcyBvcHRpb25hbFxuICBpZiAodHlwZW9mIG9uTG9hZGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Mb2FkZWQgPSBOT09QO1xuICB9XG5cbiAgLy8gVGhpcyBvYmplY3Qgd2lsbCBiZSByZXBsYWNlZCBieSBhIHJlYWwgSW1hZ2Ugb2JqZWN0IGJ1dCBiZWZvcmUgdGhhdFxuICAvLyBzcmMgaXMgbmVlZGVkIGluIFNwYWNlVmlldy5cbiAgdGhpcy5pbWFnZSA9IHsgc3JjOiBpbWdTcmMgfTtcblxuICAvLyBJZiB0aGUgaW1hZ2UgaXMgY2FjaGVkLCB0aGUgJ2xvYWQnIGV2ZW50IG9mIEltYWdlIGVsZW1lbnQgaXNcbiAgLy8gZmlyZWQgaW5zdGFudGx5IHdoZW4gY2FsbGluZyBsb2FkaW1hZ2VzLiBJZiB3ZSBkaWQgbm90IGNhcmVcbiAgLy8gYWJvdXQgdGhpcywgdGhlIG9uKCdsb2FkZWQnLCBmbikgbGlzdGVuZXJzIHdvdWxkIGV4cGVyaWVuY2VcbiAgLy8gZGlmZmVyZW50IGV4ZWN1dGlvbiBvcmRlciBkZXBlbmRpbmcgd2hldGhlciB0aGUgaW1hZ2VzIHdhc1xuICAvLyBjYWNoZWQgb3Igbm90LlxuICB2YXIgbm90Q2FjaGVkID0gZmFsc2U7XG5cbiAgbG9hZGltYWdlcyhpbWdTcmMsIGZ1bmN0aW9uIChlcnIsIGltYWdlKSB7XG4gICAgdmFyIGVtaXRlcnIsIGVtaXR0YWE7XG4gICAgaWYgKGVycikge1xuICAgICAgZW1pdGVyciA9IGVycjtcbiAgICAgIGVtaXR0YWEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzMi5pbWFnZSA9IGltYWdlO1xuICAgICAgZW1pdGVyciA9IG51bGw7XG4gICAgICBlbWl0dGFhID0gdGhpczI7XG4gICAgfVxuXG4gICAgaWYgKG5vdENhY2hlZCkge1xuICAgICAgdGhpczIuZW1pdCgnbG9hZGVkJywgZW1pdGVyciwgZW1pdHRhYSk7XG4gICAgICBvbkxvYWRlZChlbWl0ZXJyLCBlbWl0dGFhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUG9zdHBvbmUgZW1pdHRpbmcgb2YgdGhlIGxvYWRlZCBldmVudFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMyLmVtaXQoJ2xvYWRlZCcsIGVtaXRlcnIsIGVtaXR0YWEpO1xuICAgICAgICBvbkxvYWRlZChlbWl0ZXJyLCBlbWl0dGFhKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfSk7XG5cbiAgbm90Q2FjaGVkID0gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGFhO1xuIiwiLy8gQVBJIHYwLjYuMFxudmFyIG51ZGdlZCA9IHJlcXVpcmUoJ251ZGdlZCcpO1xuXG4vLyBUT0RPXG4vLyBtb25rZXlwYXRjaCBcInRvKHBsYW5lKVwiXG5cbm1vZHVsZS5leHBvcnRzID0gbnVkZ2VkLlRyYW5zZm9ybTtcbiIsIi8vIEFQSSB2MC42LjBcbnZhciBudWRnZWQgPSByZXF1aXJlKCdudWRnZWQnKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xudmFyIFNwYWNlUG9pbnQgPSByZXF1aXJlKCcuL1NwYWNlUG9pbnQnKTtcblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwb2ludHMsIHBsYW5lKSB7XG4gIC8vIFRyYW5zZm9ybSBhbGwgdGhlIHBvaW50cyBvbnRvIHRoZSBwYXJlbnQgYW5kXG4gIC8vIHJlcHJlc2VudCB0aGVtIGluIGFycmF5IFtbeDAseTBdLCBbeDEseTFdLCAuLi5dLlxuICAvL1xuICAvLyBBcmd1bWVudHM6XG4gIC8vICAgcG9pbnRzLCBhIHNpbmdsZSBzcGFjZXBvaW50IG9yIGEgbGlzdCBvZiBzcGFjZXBvaW50c1xuICAvLyAgIHBsYW5lLCBhIFNwYWNlUGxhbmUgZS5nLiBhIFNwYWNlVGFhIG9udG8gbm9ybWFsaXplLlxuICAvLyBSZXR1cm46XG4gIC8vICAgYXJyYXkgb2YgeHkgcG9pbnRzIGluIHNwYWNlLlxuICB2YXIgaSwgcCwgbnAsIG5vcm1hbGl6ZWQ7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpIHtcbiAgICAvLyBTaW5nbGUgU3BhY2VQb2ludFxuICAgIHAgPSBwb2ludHM7XG4gICAgbnAgPSBwLnRvKHBsYW5lKS54eTtcbiAgICByZXR1cm4gW25wXTtcbiAgfSAvLyBlbHNlXG4gIG5vcm1hbGl6ZWQgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbnAgPSBwLnRvKHBsYW5lKS54eTtcbiAgICBub3JtYWxpemVkLnB1c2gobnApO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG52YXIgdHJhbnNmb3JtQnlFc3RpbWF0ZSA9IGZ1bmN0aW9uIChwbGFuZSwgdHlwZSwgZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgLy8gVHlwZXM6IFQsUyxSLFRTLFRSLFNSLFRTUiAoc2VlIG51ZGdlZCBmb3IgZnVydGhlciBkZXRhaWxzKVxuXG4gIHZhciBub3JtUGl2b3Q7XG4gIGlmICh0eXBlb2YgcGl2b3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCBwbGFuZS5fcGFyZW50KVswXTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgYWxsIFNwYWNlUG9pbnRzIG9udG8gdGhlIHNwYWNlIGFuZCB0byBhcnJheXNcbiAgdmFyIG5vcm1Eb21haW4gPSBub3JtYWxpemUoZG9tYWluLCBwbGFuZS5fcGFyZW50KTtcbiAgdmFyIG5vcm1SYW5nZSA9IG5vcm1hbGl6ZShyYW5nZSwgcGxhbmUuX3BhcmVudCk7XG5cbiAgLy8gVGhlbiBjb21wdXRlIG9wdGltYWwgdHJhbnNmb3JtYXRpb24gaW4gc3BhY2VcbiAgdmFyIEhfc3BhY2UgPSBudWRnZWQuZXN0aW1hdGUodHlwZSwgbm9ybURvbWFpbiwgbm9ybVJhbmdlLCBub3JtUGl2b3QpO1xuICAvLyBTZWUgMjAxNi0wMy0wNS0xMTpcbiAgLy8gICBUbyBhcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBhIHNwYWNlIG9iamVjdDpcbiAgLy8gICAgIFRfaGF0ID0gdG9QYXJlbnQoSCkgKiBUXG4gIC8vIFRoZXJlZm9yZTpcbiAgcGxhbmUuX1QgPSBIX3NwYWNlLm11bHRpcGx5QnkocGxhbmUuX1QpO1xuXG4gIC8vIE5vdGlmeSBlc3BlY2lhbGx5IHZpZXcgYWJvdXQgdHJhbnNmb3JtYXRpb24uXG4gIHBsYW5lLmVtaXQoJ3RyYW5zZm9ybWVkJywgcGxhbmUpO1xufTtcblxuXG52YXIgVHJhbnNmb3JtZXIgPSBmdW5jdGlvbiAocGxhbmUpIHtcbiAgLy9cbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIHBsYW5lXG4gIC8vICAgICBhIFNwYWNlUGxhbmVcblxuICBwbGFuZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoVCkge1xuICAgIC8vIE5lZWRlZCB3aGVuIHdlIHdoYW4gdG8gcmVzdG9yZSBzdG9yZWQgcG9zaXRpb24sIG1heWJlIGFmdGVyXG4gICAgLy8gbW9kaWZpY2F0aW9uLlxuICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIGFyZSByb290LCBjYW5ub3Qgc2V0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9UID0gVDtcbiAgICB0aGlzLmVtaXQoJ3RyYW5zZm9ybWVkJywgdGhpcyk7XG4gIH07XG5cbiAgcGxhbmUuc2V0R2xvYmFsVHJhbnNmb3JtID0gZnVuY3Rpb24gKFQpIHtcbiAgICAvLyBTZXQgbG9jYWwgdHJhbnNmb3JtIHNvIHRoYXQgdGhlIGdsb2JhbCB0cmFuc2Zvcm0gYmVjb21lcyB0aGUgZ2l2ZW4gVC5cbiAgICAvL1xuICAgIC8vIERldiBub3RlOlxuICAgIC8vICAgR2l2ZW4gVCBpcyBjb29yZC4gdHJhbnNmLiBmcm9tIHRoZSBwbGFuZSB0byByb290IChzcGFjZSkuXG4gICAgLy8gICBTbyBpcyB0aGlzLl9ULlxuICAgIC8vICAgY3VycmVudF9nbG9iX3RyYW5zID0gcGFyZW50X2dsb2JfdHJhbnMgKiB0aGlzX1RcbiAgICAvLyAgIG5ld19nbG9iX3RyYW5zID0gcGFyZW50X2dsb2JfdHJhbnMgKiBYXG4gICAgLy8gICA8PT4gWCA9IGludihwYXJlbnRfZ2xvYl90cmFucykgKiBuZXdfZ2xvYl90cmFuc1xuICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIGFyZSByb290LCBjYW5ub3Qgc2V0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFyZW50X2dsb2JhbCA9IHRoaXMuX3BhcmVudC5nZXRHbG9iYWxUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9UID0gcGFyZW50X2dsb2JhbC5pbnZlcnNlKCkubXVsdGlwbHlCeShUKTtcbiAgICB0aGlzLmVtaXQoJ3RyYW5zZm9ybWVkJywgdGhpcyk7XG4gIH07XG5cbiAgcGxhbmUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBNb3ZlIHBsYW5lIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseSBieSBleGFtcGxlLlxuICAgIC8vXG4gICAgLy8gVHJhbnNsYXRlIHRoZSBwbGFuZSBzbyB0aGF0IGFmdGVyIHRoZSB0cmFuc2xhdGlvbiwgdGhlIGRvbWFpbiBwb2ludHNcbiAgICAvLyB3b3VsZCBiZSBhcyBjbG9zZSB0byBnaXZlbiByYW5nZSBwb2ludHMgYXMgcG9zc2libGUuXG4gICAgLy9cbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1QnLCBkb21haW4sIHJhbmdlKTtcbiAgfTtcblxuICBwbGFuZS5zY2FsZSA9IGZ1bmN0aW9uIChwaXZvdCwgbXVsdGlwbGllck9yRG9tYWluLCByYW5nZSkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgcGl2b3QsIGEgU3BhY2VQb2ludFxuICAgIC8vICAgbXVsdGlwbGllciwgdGhlIHNjYWxlIGZhY3RvciwgPiAwXG4gICAgLy8gIE9SXG4gICAgLy8gICBwaXZvdFxuICAgIC8vICAgZG9tYWluXG4gICAgLy8gICByYW5nZVxuXG4gICAgdmFyIHVzZU11bHRpcGxpZXIgPSAodHlwZW9mIHJhbmdlID09PSAndW5kZWZpbmVkJyk7XG5cbiAgICBpZiAodXNlTXVsdGlwbGllcikge1xuICAgICAgdmFyIG5vcm1QaXZvdCA9IG5vcm1hbGl6ZShwaXZvdCwgdGhpcy5fcGFyZW50KVswXTtcbiAgICAgIHZhciBtdWx0aXBsaWVyID0gbXVsdGlwbGllck9yRG9tYWluO1xuICAgICAgLy8gTXVsdGlwbGllciBkb2VzIG5vdCBkZXBlbmQgb24gcGxhbmUuXG4gICAgICAvLyBXZSBjcmVhdGUgYSBwaXZvdGVkIHNjYWxpbmcgdHJhbnNmb3JtIG9uIHBhcmVudC5cbiAgICAgIHZhciBTX3BhcmVudCA9IFRyYW5zZm9ybS5JREVOVElUWS5zY2FsZUJ5KG11bHRpcGxpZXIsIG5vcm1QaXZvdCk7XG4gICAgICAvLyBTZWUgMjAxNi0wMy0wNS0xMVxuICAgICAgLy8gICBXZSB0cmFuc2Zvcm0gc3BhY2Ugb2JqZWN0cyBieTpcbiAgICAgIC8vICAgVF9oYXQgPSBIX3NwYWNlICogVFxuICAgICAgdGhpcy5fVCA9IFNfcGFyZW50Lm11bHRpcGx5QnkodGhpcy5fVCk7XG4gICAgICB0aGlzLmVtaXQoJ3RyYW5zZm9ybWVkJywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb21haW4gPSBtdWx0aXBsaWVyT3JEb21haW47XG4gICAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdTJywgZG9tYWluLCByYW5nZSwgcGl2b3QpO1xuICAgIH1cbiAgfTtcblxuICBwbGFuZS5yb3RhdGUgPSBmdW5jdGlvbiAocGl2b3QsIHJhZGlhbnNPckRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICByYWRpYW5zXG4gICAgLy8gIE9SXG4gICAgLy8gICBwaXZvdFxuICAgIC8vICAgZG9tYWluXG4gICAgLy8gICByYW5nZVxuXG4gICAgdmFyIHVzZVJhZGlhbnMgPSAodHlwZW9mIHJhbmdlID09PSAndW5kZWZpbmVkJyk7XG5cbiAgICBpZiAodXNlUmFkaWFucykge1xuICAgICAgdmFyIG5vcm1QaXZvdCA9IG5vcm1hbGl6ZShwaXZvdCwgdGhpcy5fcGFyZW50KVswXTtcbiAgICAgIHZhciByYWRpYW5zID0gcmFkaWFuc09yRG9tYWluO1xuICAgICAgLy8gUmFkaWFucyBkbyBub3QgZGVwZW5kIG9uIHBsYW5lLlxuICAgICAgLy8gV2UgY3JlYXRlIGEgcGl2b3RlZCByb3RhdGlvbiB0cmFuc2Zvcm0gb24gcGFyZW50LlxuICAgICAgdmFyIFJfcGFyZW50ID0gVHJhbnNmb3JtLklERU5USVRZLnJvdGF0ZUJ5KHJhZGlhbnMsIG5vcm1QaXZvdCk7XG4gICAgICAvLyBTZWUgMjAxNi0wMy0wNS0xMVxuICAgICAgLy8gICBXZSB0cmFuc2Zvcm0gc3BhY2Ugb2JqZWN0cyBieTpcbiAgICAgIC8vICAgVF9oYXQgPSBIX3NwYWNlICogVFxuICAgICAgdGhpcy5fVCA9IFJfcGFyZW50Lm11bHRpcGx5QnkodGhpcy5fVCk7XG4gICAgICB0aGlzLmVtaXQoJ3RyYW5zZm9ybWVkJywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkb21haW4gPSByYWRpYW5zT3JEb21haW47XG4gICAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdSJywgZG9tYWluLCByYW5nZSwgcGl2b3QpO1xuICAgIH1cbiAgfTtcblxuICBwbGFuZS50cmFuc2xhdGVTY2FsZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUUycsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZVJvdGF0ZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUUicsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIHBsYW5lLnNjYWxlUm90YXRlID0gZnVuY3Rpb24gKHBpdm90LCBkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdTUicsIGRvbWFpbiwgcmFuZ2UsIHBpdm90KTtcbiAgfTtcblxuICBwbGFuZS50cmFuc2xhdGVTY2FsZVJvdGF0ZSA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB0cmFuc2Zvcm1CeUVzdGltYXRlKHRoaXMsICdUU1InLCBkb21haW4sIHJhbmdlKTtcbiAgfTtcblxuICAvLyBwbGFuZS50cmFuc2xhdGVBbmRTY2FsZVRvRml0LCBub3Qgc3VyZSBpZiBuZWNlc3NhcnkgZm9yIG5vd1xuXG4gIHBsYW5lLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24gKHNlbGYsIG9sZFBhcmVudCwgbmV3UGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbGRQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG9sZFBhcmVudCA9IG51bGw7IH1cbiAgICBpZiAodHlwZW9mIG5ld1BhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgbmV3UGFyZW50ID0gbnVsbDsgfVxuXG4gICAgdmFyIHNhbWVSb290O1xuICAgIGlmIChuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFJvb3Qgbm9kZXMgY2Fubm90IG1vdmUuXG4gICAgICB0aGlzLnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvbGRQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gUmVtb3ZlZCBmcm9tIG51bGwgcGFyZW50P1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdDYW5ub3QgcmVtb3ZlIGZyb20gbnVsbCBwYXJlbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1vdmVkIG9udG8gYW5vdGhlciBwYXJlbnQuXG4gICAgICAgIC8vIExldCB1cyBrZWVwIHRoZSBsb2NhdGlvbiBpbiBzcGFjZSB0aGUgc2FtZSBpZiBwb3NzaWJsZS5cbiAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgb25seSBpZiB0aGUgcGFyZW50cyBzaGFyZSBzYW1lIHJvb3QgaS5lLlxuICAgICAgICAvLyBhcmUgaW4gdGhlIHNhbWUgc3BhY2UuXG4gICAgICAgIHNhbWVSb290ID0gb2xkUGFyZW50LmdldFJvb3RQYXJlbnQoKSA9PT0gbmV3UGFyZW50LmdldFJvb3RQYXJlbnQoKTtcbiAgICAgICAgaWYgKHNhbWVSb290KSB7XG4gICAgICAgICAgLy8gS2VlcCB0aGUgbG9jYXRpb24uXG4gICAgICAgICAgLy8gTGV0XG4gICAgICAgICAgLy8gICBPVCBiZSB0aGUgb2xkIGxvY2FsIGNvb3JkLiB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAvLyAgIE5UIGJlIHRoZSB1bmtub3duIG5ldyBsb2NhbCBjb29yZC4gdHJhbnNmLlxuICAgICAgICAgIC8vICAgT1BHVCBiZSB0aGUgZ2xvYmFsIGNvb3JkLiB0cmFuc2YuIG9mIG9sZCBwYXJlbnRcbiAgICAgICAgICAvLyAgIE5QR1QgYmUgdGhlIGdsb2JhbCBjb29yZC4gdHJhbnNmLiBvZiBuZXcgcGFyZW50XG4gICAgICAgICAgLy8gTm93LCB3ZSB3YW50IHRvIGtlZXAgZ2xvYmFsIHRyYW5zZi4gdW5jaGFuZ2VkLlxuICAgICAgICAgIC8vICAgT1BHVCAqIE9UID0gTlBHVCAqIE5UXG4gICAgICAgICAgLy8gICA8PT4gTlQgPSBpbnYoTlBHVCkgKiBPUEdUICogT1RcbiAgICAgICAgICB2YXIgb3BndCA9IG9sZFBhcmVudC5nZXRHbG9iYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgICB2YXIgbnBndCA9IG5ld1BhcmVudC5nZXRHbG9iYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgICB2YXIgb3QgPSB0aGlzLl9UO1xuICAgICAgICAgIHZhciBudCA9IG5wZ3QuaW52ZXJzZSgpLm11bHRpcGx5Qnkob3BndCkubXVsdGlwbHlCeShvdCk7XG4gICAgICAgICAgdGhpcy5fVCA9IG50O1xuICAgICAgICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTsgLy8gVE9ETyBJcyBuZWVkZWQgYmVjYXVzZSBpbnBsYWNlP1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEluIGRpZmZlcmVudCBzcGFjZTogcmVzZXRcbiAgICAgICAgICB0aGlzLnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogdGhlcmUgY291bGQgYmUgYSBuZWVkIHRvIGNoYW5nZSBwYXJlbnQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAvLyBsb2NhbCB0cmFuc2Zvcm1hdGlvbi4gTm90IG5lZWRlZCBmb3Igbm93LlxuICAgICAgfVxuXG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtZXI7XG4iLCJcbmV4cG9ydHMuVGFhID0gcmVxdWlyZSgnLi9UYWEnKTtcbmV4cG9ydHMuU3BhY2VUYWEgPSByZXF1aXJlKCcuL1NwYWNlVGFhJyk7XG5leHBvcnRzLlNwYWNlSFRNTCA9IHJlcXVpcmUoJy4vU3BhY2VIVE1MJyk7XG5leHBvcnRzLlNwYWNlID0gcmVxdWlyZSgnLi9TcGFjZScpO1xuZXhwb3J0cy5IVE1MU3BhY2VWaWV3ID0gcmVxdWlyZSgnLi9IVE1MU3BhY2VWaWV3Jyk7XG5cbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAnMy4wLjAnO1xuIl19
