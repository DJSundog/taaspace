(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.taaspace = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],2:[function(require,module,exports){
module.exports = function loadimages(imgSrcs, then) {
  // Parameters
  //   imgSrcs
  //     array of image source paths OR single source path string.
  //   then(err, imgElements)
  //     Will be called after all the images are loaded. If string was given,
  //     imgElements is an Image instead of array of Images.

  var numberOfImages, stringGiven, thereWasSuccess, thereWasError, imgs;
  var onloadsCalled, onload, onerror;

  if (typeof then !== 'function') {
    throw new Error('callback should be a function: ' + then);
  }

  if (typeof imgSrcs === 'string') {
    numberOfImages = 1;
    stringGiven = true;
    imgSrcs = [imgSrcs]; // Normalize
  } else {
    // Array of images
    numberOfImages = imgSrcs.length;
    stringGiven = false;
  }
  thereWasSuccess = false;
  thereWasError = false;

  imgs = [];

  onloadsCalled = 0;
  onload = function () {
    // Note:
    //   this = Image
    if (!thereWasError) {
      onloadsCalled += 1;
      var isFinalImage = (onloadsCalled === numberOfImages);
      if (isFinalImage) {
        thereWasSuccess = true;
        if (stringGiven) {
          then(null, imgs[0]);
        } else {
          then(null, imgs);
        }
      }
    }
  };

  onerror = function (errMsg) {
    // Note:
    //   this = Image

    // No errors after success.
    if (!thereWasSuccess) {
      thereWasError = true;
      then(errMsg, null);
    }

    // Prevent firing the default event handler
    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers.onerror#Parameters
    return true;
  };

  for (i = 0; i < imgSrcs.length; i += 1) {
    imgs.push(new Image());
    imgs[i].onload = onload;
    imgs[i].onerror = onerror;
    imgs[i].src = imgSrcs[i];
  }
};

},{}],3:[function(require,module,exports){
/**
 * Module Dependencies.
 */

var Emitter = require('component-emitter');
var query = require('component-query');
var after = require('after-transition');
var has3d = require('has-translate3d');
var ease = require('css-ease');

/**
 * CSS Translate
 */

var translate = has3d
  ? ['translate3d(', ', 0)']
  : ['translate(', ')'];

/**
 * Export `Move`
 */

module.exports = Move;

/**
 * Get computed style.
 */

var style = window.getComputedStyle
  || window.currentStyle;

/**
 * Library version.
 */

Move.version = '0.5.0';

/**
 * Export `ease`
 */

Move.ease = ease;

/**
 * Defaults.
 *
 *   `duration` - default duration of 500ms
 *
 */

Move.defaults = {
  duration: 500
};

/**
 * Default element selection utilized by `move(selector)`.
 *
 * Override to implement your own selection, for example
 * with jQuery one might write:
 *
 *     move.select = function(selector) {
 *       return jQuery(selector).get(0);
 *     };
 *
 * @param {Object|String} selector
 * @return {Element}
 * @api public
 */

Move.select = function(selector){
  if ('string' != typeof selector) return selector;
  return query(selector);
};

/**
 * Initialize a new `Move` with the given `el`.
 *
 * @param {Element} el
 * @api public
 */

function Move(el) {
  if (!(this instanceof Move)) return new Move(el);
  if ('string' == typeof el) el = query(el);
  if (!el) throw new TypeError('Move must be initialized with element or selector');
  this.el = el;
  this._props = {};
  this._rotate = 0;
  this._transitionProps = [];
  this._transforms = [];
  this.duration(Move.defaults.duration)
};


/**
 * Inherit from `EventEmitter.prototype`.
 */

Emitter(Move.prototype);

/**
 * Buffer `transform`.
 *
 * @param {String} transform
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transform = function(transform){
  this._transforms.push(transform);
  return this;
};

/**
 * Skew `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skew = function(x, y){
  return this.transform('skew('
    + x + 'deg, '
    + (y || 0)
    + 'deg)');
};

/**
 * Skew x by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewX = function(n){
  return this.transform('skewX(' + n + 'deg)');
};

/**
 * Skew y by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.skewY = function(n){
  return this.transform('skewY(' + n + 'deg)');
};

/**
 * Translate `x` and `y` axis.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translate =
Move.prototype.to = function(x, y){
  return this.transform(translate.join(''
    + x +'px, '
    + (y || 0)
    + 'px'));
};

/**
 * Translate on the x axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateX =
Move.prototype.x = function(n){
  return this.transform('translateX(' + n + 'px)');
};

/**
 * Translate on the y axis to `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.translateY =
Move.prototype.y = function(n){
  return this.transform('translateY(' + n + 'px)');
};

/**
 * Scale the x and y axis by `x`, or
 * individually scale `x` and `y`.
 *
 * @param {Number} x
 * @param {Number} y
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scale = function(x, y){
  return this.transform('scale('
    + x + ', '
    + (y || x)
    + ')');
};

/**
 * Scale x axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleX = function(n){
  return this.transform('scaleX(' + n + ')')
};

/**
 * Apply a matrix transformation
 *
 * @param {Number} m11 A matrix coefficient
 * @param {Number} m12 A matrix coefficient
 * @param {Number} m21 A matrix coefficient
 * @param {Number} m22 A matrix coefficient
 * @param {Number} m31 A matrix coefficient
 * @param {Number} m32 A matrix coefficient
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.matrix = function(m11, m12, m21, m22, m31, m32){
  return this.transform('matrix(' + [m11,m12,m21,m22,m31,m32].join(',') + ')');
};

/**
 * Scale y axis by `n`.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.scaleY = function(n){
  return this.transform('scaleY(' + n + ')')
};

/**
 * Rotate `n` degrees.
 *
 * @param {Number} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.rotate = function(n){
  return this.transform('rotate(' + n + 'deg)');
};

/**
 * Set transition easing function to to `fn` string.
 *
 * When:
 *
 *   - null "ease" is used
 *   - "in" "ease-in" is used
 *   - "out" "ease-out" is used
 *   - "in-out" "ease-in-out" is used
 *
 * @param {String} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.ease = function(fn){
  fn = ease[fn] || fn || 'ease';
  return this.setVendorProperty('transition-timing-function', fn);
};

/**
 * Set animation properties
 *
 * @param {String} name
 * @param {Object} props
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.animate = function(name, props){
  for (var i in props){
    if (props.hasOwnProperty(i)){
      this.setVendorProperty('animation-' + i, props[i])
    }
  }
  return this.setVendorProperty('animation-name', name);
}

/**
 * Set duration to `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.duration = function(n){
  n = this._duration = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-duration', n + 'ms');
};

/**
 * Delay the animation by `n`.
 *
 * @param {Number|String} n
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.delay = function(n){
  n = 'string' == typeof n
    ? parseFloat(n) * 1000
    : n;
  return this.setVendorProperty('transition-delay', n + 'ms');
};

/**
 * Set `prop` to `val`, deferred until `.end()` is invoked.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setProperty = function(prop, val){
  this._props[prop] = val;
  return this;
};

/**
 * Set a vendor prefixed `prop` with the given `val`.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.setVendorProperty = function(prop, val){
  this.setProperty('-webkit-' + prop, val);
  this.setProperty('-moz-' + prop, val);
  this.setProperty('-ms-' + prop, val);
  this.setProperty('-o-' + prop, val);
  return this;
};

/**
 * Set `prop` to `value`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {String} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.set = function(prop, val){
  this.transition(prop);
  this._props[prop] = val;
  return this;
};

/**
 * Increment `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.add = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr + val + 'px');
  });
};

/**
 * Decrement `prop` by `val`, deferred until `.end()` is invoked
 * and adds the property to the list of transition props.
 *
 * @param {String} prop
 * @param {Number} val
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.sub = function(prop, val){
  if (!style) return;
  var self = this;
  return this.on('start', function(){
    var curr = parseInt(self.current(prop), 10);
    self.set(prop, curr - val + 'px');
  });
};

/**
 * Get computed or "current" value of `prop`.
 *
 * @param {String} prop
 * @return {String}
 * @api public
 */

Move.prototype.current = function(prop){
  return style(this.el).getPropertyValue(prop);
};

/**
 * Add `prop` to the list of internal transition properties.
 *
 * @param {String} prop
 * @return {Move} for chaining
 * @api private
 */

Move.prototype.transition = function(prop){
  if (!this._transitionProps.indexOf(prop)) return this;
  this._transitionProps.push(prop);
  return this;
};

/**
 * Commit style properties, aka apply them to `el.style`.
 *
 * @return {Move} for chaining
 * @see Move#end()
 * @api private
 */

Move.prototype.applyProperties = function(){
  for (var prop in this._props) {
    this.el.style.setProperty(prop, this._props[prop], '');
  }
  return this;
};

/**
 * Re-select element via `selector`, replacing
 * the current element.
 *
 * @param {String} selector
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.move =
Move.prototype.select = function(selector){
  this.el = Move.select(selector);
  return this;
};

/**
 * Defer the given `fn` until the animation
 * is complete. `fn` may be one of the following:
 *
 *   - a function to invoke
 *   - an instanceof `Move` to call `.end()`
 *   - nothing, to return a clone of this `Move` instance for chaining
 *
 * @param {Function|Move} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.then = function(fn){
  // invoke .end()
  if (fn instanceof Move) {
    this.on('end', function(){
      fn.end();
    });
  // callback
  } else if ('function' == typeof fn) {
    this.on('end', fn);
  // chain
  } else {
    var clone = new Move(this.el);
    clone._transforms = this._transforms.slice(0);
    this.then(clone);
    clone.parent = this;
    return clone;
  }

  return this;
};

/**
 * Pop the move context.
 *
 * @return {Move} parent Move
 * @api public
 */

Move.prototype.pop = function(){
  return this.parent;
};

/**
 * Reset duration.
 *
 * @return {Move}
 * @api public
 */

Move.prototype.reset = function(){
  this.el.style.webkitTransitionDuration =
  this.el.style.mozTransitionDuration =
  this.el.style.msTransitionDuration =
  this.el.style.oTransitionDuration = '';
  return this;
};

/**
 * Start animation, optionally calling `fn` when complete.
 *
 * @param {Function} fn
 * @return {Move} for chaining
 * @api public
 */

Move.prototype.end = function(fn){
  var self = this;

  // emit "start" event
  this.emit('start');

  // transforms
  if (this._transforms.length) {
    this.setVendorProperty('transform', this._transforms.join(' '));
  }

  // transition properties
  this.setVendorProperty('transition-properties', this._transitionProps.join(', '));
  this.applyProperties();

  // callback given
  if (fn) this.then(fn);

  // emit "end" when complete
  after.once(this.el, function(){
    self.reset();
    self.emit('end');
  });

  return this;
};

},{"after-transition":4,"component-emitter":1,"component-query":8,"css-ease":9,"has-translate3d":10}],4:[function(require,module,exports){
var hasTransitions = require('has-transitions');
var emitter = require('css-emitter');

function afterTransition(el, callback) {
  if(hasTransitions(el)) {
    return emitter(el).bind(callback);
  }
  return callback.apply(el);
};

afterTransition.once = function(el, callback) {
  afterTransition(el, function fn(){
    callback.apply(el);
    emitter(el).unbind(fn);
  });
};

module.exports = afterTransition;
},{"css-emitter":5,"has-transitions":7}],5:[function(require,module,exports){
/**
 * Module Dependencies
 */

var events = require('event');

// CSS events

var watch = [
  'transitionend'
, 'webkitTransitionEnd'
, 'oTransitionEnd'
, 'MSTransitionEnd'
, 'animationend'
, 'webkitAnimationEnd'
, 'oAnimationEnd'
, 'MSAnimationEnd'
];

/**
 * Expose `CSSnext`
 */

module.exports = CssEmitter;

/**
 * Initialize a new `CssEmitter`
 *
 */

function CssEmitter(element){
  if (!(this instanceof CssEmitter)) return new CssEmitter(element);
  this.el = element;
}

/**
 * Bind CSS events.
 *
 * @api public
 */

CssEmitter.prototype.bind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.bind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Unbind CSS events
 * 
 * @api public
 */

CssEmitter.prototype.unbind = function(fn){
  for (var i=0; i < watch.length; i++) {
    events.unbind(this.el, watch[i], fn);
  }
  return this;
};

/**
 * Fire callback only once
 * 
 * @api public
 */

CssEmitter.prototype.once = function(fn){
  var self = this;
  function on(){
    self.unbind(on);
    fn.apply(self.el, arguments);
  }
  self.bind(on);
  return this;
};


},{"event":6}],6:[function(require,module,exports){

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  if (el.addEventListener) {
    el.addEventListener(type, fn, capture);
  } else {
    el.attachEvent('on' + type, fn);
  }
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  if (el.removeEventListener) {
    el.removeEventListener(type, fn, capture);
  } else {
    el.detachEvent('on' + type, fn);
  }
  return fn;
};

},{}],7:[function(require,module,exports){
/**
 * This will store the property that the current
 * browser uses for transitionDuration
 */
var property;

/**
 * The properties we'll check on an element
 * to determine if it actually has transitions
 * We use duration as this is the only property
 * needed to technically have transitions
 * @type {Array}
 */
var types = [
  "transitionDuration",
  "MozTransitionDuration",
  "webkitTransitionDuration"
];

/**
 * Determine the correct property for this browser
 * just once so we done need to check every time
 */
while(types.length) {
  var type = types.shift();
  if(type in document.body.style) {
    property = type;
  }
}

/**
 * Determine if the browser supports transitions or
 * if an element has transitions at all.
 * @param  {Element}  el Optional. Returns browser support if not included
 * @return {Boolean}
 */
function hasTransitions(el){
  if(!property) {
    return false; // No browser support for transitions
  }
  if(!el) {
    return property != null; // We just want to know if browsers support it
  }
  var duration = getComputedStyle(el)[property];
  return duration !== "" && parseFloat(duration) !== 0; // Does this element have transitions?
}

module.exports = hasTransitions;
},{}],8:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],9:[function(require,module,exports){

/**
 * CSS Easing functions
 */

module.exports = {
    'in':                'ease-in'
  , 'out':               'ease-out'
  , 'in-out':            'ease-in-out'
  , 'snap':              'cubic-bezier(0,1,.5,1)'
  , 'linear':            'cubic-bezier(0.250, 0.250, 0.750, 0.750)'
  , 'ease-in-quad':      'cubic-bezier(0.550, 0.085, 0.680, 0.530)'
  , 'ease-in-cubic':     'cubic-bezier(0.550, 0.055, 0.675, 0.190)'
  , 'ease-in-quart':     'cubic-bezier(0.895, 0.030, 0.685, 0.220)'
  , 'ease-in-quint':     'cubic-bezier(0.755, 0.050, 0.855, 0.060)'
  , 'ease-in-sine':      'cubic-bezier(0.470, 0.000, 0.745, 0.715)'
  , 'ease-in-expo':      'cubic-bezier(0.950, 0.050, 0.795, 0.035)'
  , 'ease-in-circ':      'cubic-bezier(0.600, 0.040, 0.980, 0.335)'
  , 'ease-in-back':      'cubic-bezier(0.600, -0.280, 0.735, 0.045)'
  , 'ease-out-quad':     'cubic-bezier(0.250, 0.460, 0.450, 0.940)'
  , 'ease-out-cubic':    'cubic-bezier(0.215, 0.610, 0.355, 1.000)'
  , 'ease-out-quart':    'cubic-bezier(0.165, 0.840, 0.440, 1.000)'
  , 'ease-out-quint':    'cubic-bezier(0.230, 1.000, 0.320, 1.000)'
  , 'ease-out-sine':     'cubic-bezier(0.390, 0.575, 0.565, 1.000)'
  , 'ease-out-expo':     'cubic-bezier(0.190, 1.000, 0.220, 1.000)'
  , 'ease-out-circ':     'cubic-bezier(0.075, 0.820, 0.165, 1.000)'
  , 'ease-out-back':     'cubic-bezier(0.175, 0.885, 0.320, 1.275)'
  , 'ease-out-quad':     'cubic-bezier(0.455, 0.030, 0.515, 0.955)'
  , 'ease-out-cubic':    'cubic-bezier(0.645, 0.045, 0.355, 1.000)'
  , 'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'
  , 'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'
  , 'ease-in-out-sine':  'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
  , 'ease-in-out-expo':  'cubic-bezier(1.000, 0.000, 0.000, 1.000)'
  , 'ease-in-out-circ':  'cubic-bezier(0.785, 0.135, 0.150, 0.860)'
  , 'ease-in-out-back':  'cubic-bezier(0.680, -0.550, 0.265, 1.550)'
};

},{}],10:[function(require,module,exports){

var prop = require('transform-property');

// IE <=8 doesn't have `getComputedStyle`
if (!prop || !window.getComputedStyle) {
  module.exports = false;

} else {
  var map = {
    webkitTransform: '-webkit-transform',
    OTransform: '-o-transform',
    msTransform: '-ms-transform',
    MozTransform: '-moz-transform',
    transform: 'transform'
  };

  // from: https://gist.github.com/lorenzopolidori/3794226
  var el = document.createElement('div');
  el.style[prop] = 'translate3d(1px,1px,1px)';
  document.body.insertBefore(el, null);
  var val = getComputedStyle(el).getPropertyValue(map[prop]);
  document.body.removeChild(el);
  module.exports = null != val && val.length && 'none' != val;
}

},{"transform-property":11}],11:[function(require,module,exports){

var styles = [
  'webkitTransform',
  'MozTransform',
  'msTransform',
  'OTransform',
  'transform'
];

var el = document.createElement('p');
var style;

for (var i = 0; i < styles.length; i++) {
  style = styles[i];
  if (null != el.style[style]) {
    module.exports = style;
    break;
  }
}

},{}],12:[function(require,module,exports){
/*

*/
exports.Transform = require('./lib/Transform');
exports.estimateT = require('./lib/estimateT');
exports.estimateS = require('./lib/estimateS');
exports.estimateR = require('./lib/estimateR');
exports.estimateTS = require('./lib/estimateTS');
exports.estimateTR = require('./lib/estimateTR');
exports.estimateSR = require('./lib/estimateSR');
exports.estimateTSR = require('./lib/estimateTSR');
exports.version = require('./lib/version');

exports.estimate = function (type, domain, range, pivot) {
  // Parameter
  //   type
  //     string. One of the following: 'T', 'S', 'R', 'TS', 'TR', 'SR', 'TSR'
  //   domain
  //     array of 2d arrays
  //   range
  //     array of 2d arrays
  //   pivot
  //     optional 2d array, does nothing for translation estimators
  var name = 'estimate' + type.toUpperCase();
  if (exports.hasOwnProperty(name)) {
    return exports[name](domain, range, pivot);
  } // else
  throw new Error('Unknown estimator type: ' + type);
};

},{"./lib/Transform":13,"./lib/estimateR":14,"./lib/estimateS":15,"./lib/estimateSR":16,"./lib/estimateT":17,"./lib/estimateTR":18,"./lib/estimateTS":19,"./lib/estimateTSR":20,"./lib/version":21}],13:[function(require,module,exports){

var Transform = function (s, r, tx, ty) {

  // Public, to allow user access
  this.s = s;
  this.r = r;
  this.tx = tx;
  this.ty = ty;

  this.equals = function (t) {
    return (s === t.s && r === t.r && tx === t.tx && ty === t.ty);
  };

  this.transform = function (p) {
    // p
    //   point [x, y] or array of points [[x1,y1], [x2, y2], ...]

    if (typeof p[0] === 'number') {
      // Single point
      return [s * p[0] - r * p[1] + tx, r * p[0] + s * p[1] + ty];
    } // else

    var i, c = [];
    for (i = 0; i < p.length; i += 1) {
      c.push([s * p[i][0] - r * p[i][1] + tx, r * p[i][0] + s * p[i][1] + ty]);
    }
    return c;
  };

  this.getMatrix = function () {
    // Get the transformation matrix in the format common to
    // many APIs, including:
    // - kld-affine
    //
    // Return
    //   object o, having properties a, b, c, d, e, f:
    //   [ s  -r  tx ]   [ o.a  o.c  o.e ]
    //   [ r   s  ty ] = [ o.b  o.d  o.f ]
    //   [ 0   0   1 ]   [  -    -    -  ]
    return { a: s, b: r, c: -r, d: s, e: tx, f: ty };
  };

  this.getRotation = function () {
    // in rads
    return Math.atan2(r, s);
  };

  this.getScale = function () {
    // scale multiplier
    return Math.sqrt(r * r + s * s);
  };

  this.getTranslation = function () {
    return [tx, ty];
  };

  this.inverse = function () {
    // Return inversed transform instance
    // See note 2015-10-26-16-30
    var det = s * s + r * r;
    // Test if singular transformation. These might occur when all the range
    // points are the same, forcing the scale to drop to zero.
    var eps = 0.00000001;
    if (Math.abs(det) < eps) {
      throw new Error('Singular transformations cannot be inversed.');
    }
    var shat = s / det;
    var rhat = -r / det;
    var txhat = (-s * tx - r * ty) / det;
    var tyhat = ( r * tx - s * ty) / det;
    return new Transform(shat, rhat, txhat, tyhat);
  };

  this.translateBy = function (dx, dy) {
    return new Transform(s, r, tx + dx, ty + dy);
  };

  this.scaleBy = function (multiplier, pivot) {
    // Parameter
    //   multiplier
    //   pivot
    //     optional, a [x, y] point
    var m, x, y;
    m = multiplier; // alias
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    return new Transform(m * s, m * r, m * tx + (1-m) * x, m * ty + (1-m) * y);
  };

  this.rotateBy = function (radians, pivot) {
    // Parameter
    //   radians
    //     from positive x to positive y axis
    //   pivot
    //     optional, a [x, y] point
    var co, si, x, y, shat, rhat, txhat, tyhat;
    co = Math.cos(radians);
    si = Math.sin(radians);
    if (typeof pivot === 'undefined') {
      x = y = 0;
    } else {
      x = pivot[0];
      y = pivot[1];
    }
    shat = s * co - r * si;
    rhat = s * si + r * co;
    txhat = (tx - x) * co - (ty - y) * si + x;
    tyhat = (tx - x) * si + (ty - y) * co + y;
    return new Transform(shat, rhat, txhat, tyhat);
  };


  this.multiplyBy = function (transform) {
    // Multiply this transformation matrix A
    // from the right with the given transformation matrix B
    // and return the result AB

    // For reading aid:
    // s -r tx  t.s -r tx
    // r  s ty *  r  s ty
    // 0  0  1    0  0  1
    var t = transform; // alias
    var shat = s * t.s - r * t.r;
    var rhat = s * t.r + r * t.s;
    var txhat = s * t.tx - r * t.ty + tx;
    var tyhat = r * t.tx + s * t.ty + ty;
    return new Transform(shat, rhat, txhat, tyhat);
  };
};

Transform.IDENTITY = new Transform(1, 0, 0, 0);

module.exports = Transform;

},{}],14:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, ad, bc, bd, shat, rhat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = ad = bc = bd = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  p = ac + bd;
  q = ad - bc;

  D = Math.sqrt(p * p + q * q);

  if (D === 0) {
    // D === 0
    // <=> q === 0 and p === 0.
    // <=> ad === bc and ac === -bd
    // <=> domain in pivot OR range in pivot OR yet unknown cases
    //     where the angle cannot be determined.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  shat = p / D;
  rhat = q / D;
  tx = a0 - a0 * shat + b0 * rhat;
  ty = b0 - a0 * rhat - b0 * shat;

  return new Transform(shat, rhat, tx, ty);
};

},{"./Transform":13}],15:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  var i, N, D, a0, b0, a, b, c, d, ac, bd, aa, bb, shat, tx, ty;

  N = Math.min(domain.length, range.length);
  ac = bd = aa = bb = 0;

  if (typeof pivot === 'undefined') {
    a0 = b0 = 0;
  } else {
    a0 = pivot[0];
    b0 = pivot[1];
  }

  for (i = 0; i < N; i += 1) {
    a = domain[i][0] - a0;
    b = domain[i][1] - b0;
    c = range[i][0] - a0;
    d = range[i][1] - b0;
    ac += a * c;
    bd += b * d;
    aa += a * a;
    bb += b * b;
  }

  D = aa + bb;

  if (D === 0) {
    // All domain points equal the pivot.
    // Identity transform is then only solution.
    // D === 0 also if N === 0.
    // Assume identity transform to be the best guess
    return Transform.IDENTITY;
  }

  // Prevent negative scaling because it would be same as positive scaling
  // and rotation => limit to zero
  shat = Math.max(0, (ac + bd) / D);
  tx = (1 - shat) * a0;
  ty = (1 - shat) * b0;

  return new Transform(shat, 0, tx, ty);
};

},{"./Transform":13}],16:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range, pivot) {
  // Estimate optimal transformation given the domain and the range
  // so that the pivot point remains the same.
  //
  // Use cases
  //   - transform an image that has one corner fixed with a pin.
  //   - allow only scale and rotation by fixing the middle of the object
  //     to transform.
  //
  // Parameters
  //   domain, an array of [x, y] points
  //   range, an array of [x, y] points
  //   pivot, optional
  //     the point [x, y] that must remain constant in the tranformation.
  //     Defaults to origo [0, 0]
  //
  //
  var X, Y, N, s, r, tx, ty;

  // Optional pivot
  if (typeof pivot === 'undefined') {
    pivot = [0, 0];
  }

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  var v = pivot[0];
  var w = pivot[1];

  var i, a, b, c, d;
  var a2, b2;
  a2 = b2 = 0;
  var ac, bd, bc, ad;
  ac = bd = bc = ad = 0;

  for (i = 0; i < N; i += 1) {
    a = X[i][0] - v;
    b = X[i][1] - w;
    c = Y[i][0] - v;
    d = Y[i][1] - w;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
    bc += b * c;
    ad += a * d;
  }

  // Denominator = determinant.
  // It becomes zero iff N = 0 or X[i] = [v, w] for every i in [0, n).
  // In other words, iff all the domain points are under the fixed point or
  // there is no domain points.
  var den = a2 + b2;

  var eps = 0.00000001;
  if (Math.abs(den) < eps) {
    // The domain points are under the pivot or there is no domain points.
    // We assume identity transform be the simplest guess. It keeps
    // the domain points under the pivot if there is some.
    return new Transform(1, 0, 0, 0);
  }

  // Estimators
  s = (ac + bd) / den;
  r = (-bc + ad) / den;
  tx =  w * r - v * s + v;
  ty = -v * r - w * s + w;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],17:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  var i, N, a1, b1, c1, d1, txhat, tyhat;

  N = Math.min(domain.length, range.length);
  a1 = b1 = c1 = d1 = 0;

  if (N < 1) {
    // Assume identity transform be the best guess
    return Transform.IDENTITY;
  }

  for (i = 0; i < N; i += 1) {
    a1 += domain[i][0];
    b1 += domain[i][1];
    c1 += range[i][0];
    d1 += range[i][1];
  }

  txhat = (c1 - a1) / N;
  tyhat = (d1 - b1) / N;

  return new Transform(1, 0, txhat, tyhat);
};

},{"./Transform":13}],18:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, ac, ad, bc, bd;
  a1 = b1 = c1 = d1 = ac = ad = bc = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    ac += a * c;
    ad += a * d;
    bc += b * c;
    bd += b * d;
  }

  // Denominator.
  var v = N * (ad - bc) - a1 * d1 + b1 * c1;
  var w = N * (ac + bd) - a1 * c1 - b1 * d1;
  var D = Math.sqrt(v * v + w * w);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> undecidable
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 - a1) / N, (d1 - b1) / N);
  }

  // Estimators
  var shat = w / D;
  var rhat = v / D;
  var txhat = (-a1 * shat + b1 * rhat + c1) / N;
  var tyhat = (-a1 * rhat - b1 * shat + d1) / N;

  return new Transform(shat, rhat, txhat, tyhat);
};

},{"./Transform":13}],19:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays

  // Alias
  var X = domain;
  var Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  var N = Math.min(X.length, Y.length);

  var i, a, b, c, d, a1, b1, c1, d1, a2, b2, ac, bd;
  a1 = b1 = c1 = d1 = a2 = b2 = ac = bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  var N2 = N * N;
  var a12 = a1 * a1;
  var b12 = b1 * b1;
  var p = a2 + b2;
  var q = ac + bd;
  var D = N2 * p - N * (a12 + b12);

  if (D === 0) {
    // N === 0 => D === 0
    if (N === 0) {
      return new Transform(1, 0, 0, 0);
    } // else
    // D === 0 <=> all the domain points are the same
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  var shat = (N2 * q - N * (a1 * c1 + b1 * d1)) / D;
  var txhat = (-N * a1 * q + N * c1 * p - b12 * c1 + a1 * b1 * d1) / D;
  var tyhat = (-N * b1 * q + N * d1 * p - a12 * d1 + a1 * b1 * c1) / D;

  return new Transform(shat, 0, txhat, tyhat);
};

},{"./Transform":13}],20:[function(require,module,exports){
var Transform = require('./Transform');

module.exports = function (domain, range) {
  // Parameters
  //   domain
  //     array of [x, y] 2D arrays
  //   range
  //     array of [x, y] 2D arrays
  var X, Y, N, s, r, tx, ty;

  // Alias
  X = domain;
  Y = range;

  // Allow arrays of different length but
  // ignore the extra points.
  N = Math.min(X.length, Y.length);

  // If length is zero, no estimation can be done. We choose the indentity
  // transformation be the best quess.
  if (N === 0) {
    return new Transform(1, 0, 0, 0);
  } // else

  var i, a, b, c, d;
  var a1 = 0;
  var b1 = 0;
  var c1 = 0;
  var d1 = 0;
  var a2 = 0;
  var b2 = 0;
  var ad = 0;
  var bc = 0;
  var ac = 0;
  var bd = 0;
  for (i = 0; i < N; i += 1) {
    a = X[i][0];
    b = X[i][1];
    c = Y[i][0];
    d = Y[i][1];
    a1 += a;
    b1 += b;
    c1 += c;
    d1 += d;
    a2 += a * a;
    b2 += b * b;
    ad += a * d;
    bc += b * c;
    ac += a * c;
    bd += b * d;
  }

  // Denominator.
  // It is zero iff X[i] = X[j] for every i and j in [0, n).
  // In other words, iff all the domain points are the same or there is only one domain point.
  var den = N * a2 + N * b2 - a1 * a1 - b1 * b1;

  var eps = 0.00000001;
  if (-eps < den && den < eps) {
    // The domain points are the same.
    // We guess the translation to the mean of the range to be the best guess.
    // Here a, b represents the mean of domain points.
    return new Transform(1, 0, (c1 / N) - a, (d1 / N) - b);
  }

  // Estimators
  s = (N * (ac + bd) - a1 * c1 - b1 * d1) / den;
  r = (N * (ad - bc) + b1 * c1 - a1 * d1) / den;
  tx = (-a1 * (ac + bd) + b1 * (ad - bc) + a2 * c1 + b2 * c1) / den;
  ty = (-b1 * (ac + bd) - a1 * (ad - bc) + a2 * d1 + b2 * d1) / den;

  return new Transform(s, r, tx, ty);
};

},{"./Transform":13}],21:[function(require,module,exports){
module.exports = '1.0.1';

},{}],22:[function(require,module,exports){
"use strict";

module.exports = SeqId

function SeqId(initial) {
  if (!(this instanceof SeqId)) {
    return new SeqId(initial)
  }
  if (initial == null) {
    initial = (Math.random() - 0.5) * Math.pow(2, 32)
  }
  this._id = initial | 0
}
SeqId.prototype.next = function () {
  this._id = (this._id + 1) | 0
  return this._id
}

},{}],23:[function(require,module,exports){
/*

View

*/
var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var SpaceTransformer = require('./SpaceTransformer');
var SpaceRectangle = require('./SpaceRectangle');
var SpaceTaa = require('./SpaceTaa');
var SpaceHTML = require('./SpaceHTML');
var Space = require('./Space');
var move = require('movejs');

// Disable animations by default.
move.defaults = { duration: 0 };

var HTMLSpaceView = function (space, htmlContainer) {
  // Test if valid space
  if (!(space instanceof Space)) {
    throw 'Parent of a View must be a Space.';
  }
  // Test if valid dom element
  if (!('tagName' in htmlContainer)) {
    throw 'Container should be a DOM Element';
  }

  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  SpaceTransformer(this);
  SpaceRectangle(this);
  var this2 = this;

  this._el = htmlContainer;

  // Two mappings from space taa ids:
  // 1. to HTML elements of the space nodes.
  // 2. to SpaceNode instances
  // Dev decision:
  //   For data structure, dict over list because key search time complexity.
  this._elements = {};
  this._nodes = {};

  (function initSize() {
    var w = this2._el.clientWidth;
    var h = this2._el.clientHeight;
    this2.resize([w, h]);
  }());

  var _hasNodeId = function (nodeid) {
    return this2._elements.hasOwnProperty(nodeid);
  };

  var transformNode = function (htmlElement, spaceNode) {
    // Transform elements because the view orientation.
    // See 2016-03-05-09 for math.
    var node_global_T = spaceNode.getGlobalTransform();
    var T = this2._T.inverse().multiplyBy(node_global_T);
    // Current move.js does not prevent scientific notation reaching CSS
    // which leads to problems with Safari and Opera. Therefore we must
    // prevent the notation here.
    // Of course this will cause error in the presentation.
    // However the error is only in the presentation and thus not a problem.
    var prec = 8;
    var s = T.s.toFixed(prec);
    var r = T.r.toFixed(prec);
    var tx = T.tx.toFixed(prec);
    var ty = T.ty.toFixed(prec);
    move(htmlElement).matrix(s, r,-r, s, tx, ty).end();
  };

  var getViewSpecificId = function (spaceNodeId) {
    // Each rendered element has own ID. The ID differs from
    // the id of space nodes because a space node can become
    // visualized through multiple views.
    return this2.id + '-' + spaceNodeId;
  };


  // Listen the space for new or removed nodes or transformations

  var transformedHandler = function (spaceNode) {
    // Update css transformation.
    // If the node has children, they must also be transformed
    // because the children do not emit transformed by themselves.
    var nodes, i, node, el;
    nodes = spaceNode.getDescendants();
    nodes.push(spaceNode);

    for (i = 0; i < nodes.length; i += 1) {
      node = nodes[i];
      if (_hasNodeId(node.id)) {
        if (node instanceof SpaceTaa) {
          el = this2._elements[node.id];
          transformNode(el, node);
        } else if (node instanceof SpaceHTML) {
          el = this2._elements[node.id];
          transformNode(el, node);
        }
        // Else: no transformable representation for Views.
      }
    }
  };

  var resizedHandler = function (node) {
    var el, wh;
    if (_hasNodeId(node.id)) {
      // Safeguard: if is a SpaceRectangle
      if (node.hasOwnProperty('resize')) {
        wh = node.getSize();
        el = this2._elements[node.id];
        el.style.width = wh[0] + 'px';
        el.style.height = wh[1] + 'px';
      }
    }
  };

  var contentAddedHandler = function (spaceNode, newParent, oldParent) {
    // Parameters:
    //   spaceNode: a SpaceNode i.e. the content unit that was added.
    //   newParent: optional. The new parent of the SpaceNode
    //     Not used for anything for now but probably in the future.
    //   oldParent: optional. The old parent of the SpaceNode.
    //     Not used for anything for now but probably in the future.
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var node, el, wh;

    // SpaceView, SpaceTaa ...
    node = spaceNode;

    // Ensure the spaceNode is in same space. Otherwise,
    // if view's space has been just changed, a waiting
    // contentAdded event could add spaceNode from the old space.
    if (spaceNode.getRootParent() !== this2.getRootParent()) {
      return;
    }

    if (_hasNodeId(node.id)) {
      // Content is already drawn.
    } else {
      if (node instanceof SpaceTaa) {
        el = new Image(256, 256);
        el.src = node.taa.image.src;
        el.id = getViewSpecificId(node.id);
        el.className = 'taaspace-taa';
        // Show to client
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[node.id] = el;
        this2._nodes[node.id] = node;
        // Make transformation
        transformNode(el, node);
        // Listen to further transformations
        node.on('transformed', transformedHandler);
        node.on('resized', resizedHandler);
      } else if (node instanceof SpaceHTML) {
        // Create container div.
        el = document.createElement('div');
        el.innerHTML = node.html;
        el.id = getViewSpecificId(node.id);
        el.className = 'taaspace-html';
        // Resize, and let taaspace styles do the rest.
        wh = node.getSize();
        el.style.width = wh[0] + 'px';
        el.style.height = wh[1] + 'px';
        // Render
        this2._el.appendChild(el);
        // Make referencable
        this2._elements[node.id] = el;
        this2._nodes[node.id] = node;
        // Make transformation
        transformNode(el, node);
        // Listen to further transformations
        node.on('transformed', transformedHandler);
        node.on('resized', resizedHandler);
      } else if (node instanceof HTMLSpaceView) {
        // No representation for views.
      } else {
        throw new Exception('Unknown SpaceNode subtype; cannot represent');
      }
    }
  };

  var contentRemovedHandler = function (spaceNode, oldParent, newParent) {
    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot, el, node;

    node = spaceNode; // Alias

    // Decide sameRoot
    if (oldParent === null || newParent === null) {
      sameRoot = false;
    } else {
      sameRoot = oldParent.getRootParent() === newParent.getRootParent();
    }

    if (sameRoot) {
      // No reason to remove and then add again.
    } else {
      // New parent in different space, so not displayed in this view anymore.
      if (_hasNodeId(node.id)) {
        // Remove HTML element
        el = this2._elements[node.id];
        this2._el.removeChild(el);
        // Remove from memory.
        // JS feature of delete: does not throw if key does not exist
        delete this2._elements[node.id];
        delete this2._nodes[node.id];
        // Remove handlers.
        node.off('transformed', transformedHandler);
        node.off('resized', resizedHandler);
      }
    }

  };

  // View added to new parent.
  this.on('added', function (self, newSpace, oldSpace) {
    var des, i;

    if (oldSpace === newSpace) {
      // Already set up. Do nothing.
      return;
    }

    // Render nodes from the new space.
    des = newSpace.getDescendants();
    for (i = 0; i < des.length; i += 1) {
      contentAddedHandler(des[i]);
    }

    // Start to listen for changes.
    newSpace.on('contentAdded', contentAddedHandler);
    newSpace.on('contentRemoved', contentRemovedHandler);
  });

  // View removed from parent.
  this.on('removed', function (self, oldSpace, newSpace) {
    var des, i;

    if (newSpace === oldSpace) {
      // Already set up. Do nothing.
      return;
    }

    // Stop listening for changes.
    oldSpace.off('contentAdded', contentAddedHandler);
    oldSpace.off('contentRemoved', contentRemovedHandler);

    // Remove all nodes from old space.
    des = oldSpace.getDescendants();
    for (i = 0; i < des.length; i += 1) {
      contentRemovedHandler(des[i]);
    }
  });

  // If the view is transformed, we of course need to retransform everything.
  this.on('transformed', function () {
    var id, element, node;
    for (id in this2._elements) {
      if (this2._elements.hasOwnProperty(id)) {
        element  = this2._elements[id];
        node = this2._nodes[id];
        transformNode(element, node);
      }
    }
  });

  this.getElementBySpaceNode = function (spaceNode) {
    // Get HTML element representation of the space taa.
    // Return null if not found.
    if (_hasNodeId(spaceNode.id)) {
      return this._elements[spaceNode.id];
    }
    return null;
  };

  this.getSpaceNodeByElementId = function (id) {
    // Get space taa by HTML element id
    // Return null if no space taa for such id.
    var i = id.split('-');
    var spaceViewId = i[0];
    var spaceNodeId = i[1];
    if (this.id === spaceViewId) {
      if (_hasNodeId(spaceNodeId)) {
        return this._nodes[spaceNodeId];
      }
    }
    return null;
  };

  this.getRootElement = function () {
    // Return the container HTML element.
    return this._el;
  };

  // Override the setParent so that only a Space
  // is allowed to become the parent.
  var superSetParent = this.setParent;
  this.setParent = function (space) {
    if (!(space instanceof Space)) {
      throw 'A View can only be a child of a Space';
    }
    superSetParent.call(this, space);
  };

  // View ready to be added to Space.
  this.setParent(space);
};

module.exports = HTMLSpaceView;

},{"./Space":24,"./SpaceHTML":25,"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./SpaceTaa":30,"./SpaceTransformer":31,"component-emitter":1,"movejs":3}],24:[function(require,module,exports){
/*
Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
  contentTransformed
*/
var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');

var Space = function () {
  Emitter(this);

  SpaceNode(this);
  // TODO remove possibility to add to parent.

  SpacePlane(this);
  // Space has constant identity transformation _T
};

module.exports = Space;

},{"./SpaceNode":26,"./SpacePlane":27,"component-emitter":1}],25:[function(require,module,exports){
/*
# SpaceElement

A HTMLElement [1] in the space.

[1] https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
*/

var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var SpaceTransformer = require('./SpaceTransformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceHTML = function (parent, html) {
  // Parameters:
  //   parent:
  //     a SpaceNode
  //   html:
  //     a string, containing html
  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  SpaceTransformer(this);
  SpaceRectangle(this);

  this.html = html;
  this.resize([256, 256]);  // Initial element size.

  this.getHTML = function () {
    return this.html;
  };

  // Ready
  this.setParent(parent);
};

module.exports = SpaceHTML;

},{"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./SpaceTransformer":31,"component-emitter":1}],26:[function(require,module,exports){
/*
API v3.0.0

Emits
  contentAdded
  contentRemoved
    not thrown if the content to remove did not exist in the first place.
*/
var Emitter = require('component-emitter');

// Unique ID generator. Unique over session.
// Usage: seqid.next()
// Return: int
var seqid = require('seqid')(0);

var SpaceNode = function (emitter) {
  // Parameters
  //   emitter, an Emitter.

  // Each node has an id. That is used by the parent nodes and in views.
  emitter.id = seqid.next().toString();

  // Nodes with null parent are root nodes i.e. spaces.
  // SpaceNode#remove sets _parent to null.
  emitter._parent = null;

  // Dict over list because key search time complexity
  emitter._children = {};

  // We need to store built handlers bound to children
  // to be able to remove the handlers when child is removed.
  emitter._addedHandlers = {};
  emitter._removedHandlers = {};

  emitter.getChildren = function () {
    // Return child SpaceNodes in a list.
    // Does not include the children of the children.
    var id, arr, obj;
    arr = [];
    obj = this._children;
    for (id in obj) {
      arr.push(obj[id]);
    }
    return arr;
  };

  emitter.getDescendants = function () {
    // All descendants in a list, including the children.
    var i, children, child, arr;
    arr = [];
    children = this.getChildren();
    for (i = 0; i < children.length; i += 1) {
      child = children[i];
      arr = arr.concat(child, child.getDescendants());
    }
    return arr;
  };

  emitter.getParent = function () {
    return this._parent;
  };

  emitter.getRootParent = function () {
    // Get the predecessor without parents in recursive manner.
    if (this._parent === null) {
      return this;
    } // else
    return this._parent.getRootParent();
  };

  emitter.hasChild = function (spaceNode) {
    // Return
    //   true if spaceNode is a child of this.
    return spaceNode._parent === this;
  };

  emitter.remove = function () {
    // Remove this space node from its parent.
    // Return: see setParent
    return this.setParent(null);
  };

  emitter.setParent = function (newParent) {
    // Add to new parent.

    var oldParent = this._parent;

    if (oldParent === null) {
      if (newParent === null) {
        // From root to root.
        // Do nothing
      } else {
        // From root to child.
        this._parent = newParent;
        this._parent._addChild(this);
        this.emit('added', this, this._parent, null);
        newParent.emit('contentAdded', this, this._parent, null);
      }
    } else {
      if (newParent === null) {
        // From child to root.
        this._parent = null; // Becomes new root node.
        oldParent._removeChild(this);
        this.emit('removed', this, oldParent, null);
        oldParent.emit('contentRemoved', this, oldParent, null);
      } else {
        // From child to child.
        this._parent = newParent;
        oldParent._removeChild(this);
        newParent._addChild(this);
        this.emit('removed', this, oldParent, newParent);
        this.emit('added', this, newParent, oldParent);
        // With both oldParent and newParent, SpaceView is able to
        // decide whether to keep same HTMLElement or recreate it.
        oldParent.emit('contentRemoved', this, oldParent, newParent);
        newParent.emit('contentAdded', this, newParent, oldParent);
      }
    }

  };

  emitter._addChild = function (child) {
    // To be called from child.setParent().
    //
    // Parameters
    //   child, A SpaceNode
    //
    // Return
    //   undefined
    //
    // Dev. note:
    //   Previously this was called from the SpaceNode constructor.
    //   However, because SpaceNode upgrade is done before other
    //   upgrades, the child would not be ready to be added to parent.

    var sc = child; // alias
    var self = this;

    this._children[sc.id] = sc;

    // Start to listen if child has beed added, removed or transformed
    var addedHandler = function (a, b, c) {
      self.emit('contentAdded', a, b, c);
    };
    var removedHandler = function (a, b, c) {
      self.emit('contentRemoved', a, b, c);
    };
    // added and removed events are not listened because
    // for after successfully made add or remove,
    // contentAdded and contentRemoved are fired in setParent.
    sc.on('contentAdded', addedHandler);
    sc.on('contentRemoved', removedHandler);
    this._addedHandlers[sc.id] = addedHandler;
    this._removedHandlers[sc.id] = removedHandler;
  };

  emitter._removeChild = function (child) {
    // To be called from SpaceNode#remove
    // Precondition: child in space
    var sc, h;

    sc = child; // alias
    delete this._children[sc.id];

    // Remove handlers
    h = this._addedHandlers[sc.id];
    delete this._addedHandlers[sc.id];
    sc.off('contentAdded', h);

    h = this._removedHandlers[sc.id];
    delete this._removedHandlers[sc.id];
    sc.off('contentRemoved', h);
  };
};

module.exports = SpaceNode;

},{"component-emitter":1,"seqid":22}],27:[function(require,module,exports){
/*
SpacePlane
API v0.6.0

A SpacePlane represents a coordinate system. It does not include
methods to transform the system. SpacePlane and SpaceTransformer are separated
because we want to have planes that cannot be transformed, as the Space.

*/

var nudged = require('nudged');
var SpacePoint = require('./SpacePoint');

var at = function (xy) {
  // Return
  //   A SpacePoint at (x,y) on the plane.
  if (xy.length !== 2) {  // DEBUG TODO remove this
    throw 'Invalid point, use array [x, y]';
  }
  return new SpacePoint(xy, this);  // Note: this === spaceNode
};

var SpacePlane = function (spaceNode) {
  // Parameters
  //   spaceNode
  //     A SpaceNode to monkey patch to SpacePlane

  // Coordinate transformation.
  // The transformation from the plane to the parent (space).
  // See 2016-03-05-09
  // Let:
  //   x_space, a point in space
  //   x_plane, a point on the plane.
  //   T, the coordinate transformation of the plane
  // Then:
  //   x_space = T * x_plane
  //
  // For Space, it is obviously the identity transform:
  //   x_space = T * x_space
  spaceNode._T = nudged.Transform.IDENTITY; // identity transformation

  spaceNode.at = at;

  spaceNode.getTransform = function () {
    // Local transform from plane to parent
    //
    // Return
    //   transformation from plane to parent, i.e.
    //     xy_parent = T * xy_plane
    // Needed when we want to store transformer's position for later use.
    return this._T;
  };

  spaceNode.getGlobalTransform = function () {
    // Return
    //   transformation from the plane to root container.
    //
    // Dev note:
    //   Local transformations go like:
    //     xy_parent = T_plane * xy_plane
    //     xy_parent_parent = T_parent * xy_parent
    //     ...
    //     xy_root = T_parent_parent..._parent * xy_parent_parent..._parent
    //   Therefore global transformation is:
    //     xy_root = T_parent_..._parent * ... * T_parent * T_plane * xy_plane
    if (this._parent === null) {
      // TODO maybe too far: this._parent._parent might be sufficient.
      return this._T;
    } // else
    return this._parent.getGlobalTransform().multiplyBy(this._T);
  };

  spaceNode.resetTransform = function () {
    // Become space. Called e.g. when plane is removed from parent.
    this._T = nudged.Transform.IDENTITY;
  };

};

module.exports = SpacePlane;

},{"./SpacePoint":28,"nudged":12}],28:[function(require,module,exports){
// API v0.6.0

var Transform = require('./Transform');

var SpacePoint = function (xy, reference) {
  // Example
  //   var p = taaspace.SpacePoint([x, y], taa);
  //
  // Parameter
  //   xy
  //     2D array
  //   reference
  //     a SpaceNode or SpacePoint
  //       an item in space, enabling coord projections.
  this.xy = xy;

  // The SpacePlane's transformation the xy are on.
  // Design note: at first, the references were SpacePlanes and not
  // transformations. But because a SpacePlane can move or be removed,
  // we chose only the transformation to be remembered.
  // Design note: later we found it would be convenient for debugging
  // to know where the point came from, which led to this._origin.
  // After that we found that in toSpace method, we would need reference
  // to space, although we only have implicit reference to its coords.
  // Therefore this._origin was dropped.

  if (reference.hasOwnProperty('getGlobalTransform')) {
    // Is a SpacePlane
    this._T = reference.getGlobalTransform();
  } else {
    // Is a SpacePoint
    this._T = reference._T;
  }
};

var proto = SpacePoint.prototype;

proto.equals = function (point) {
  return (this.xy[0] === point.xy[0] &&
    this.xy[1] === point.xy[1] &&
    this._T.equals(point._T));
  };

proto.offset = function (dx, dy) {
  // Create a new point nearby.
  //
  // Parameter
  //   dx
  //     Movement towards positive x
  //   dy
  //     ...
  var xy = [this.xy[0] + dx, this.xy[1] + dy];
  return new SpacePoint(xy, this);
};

proto.polarOffset = function (radius, radians) {
  // Create a new point moved by the polar coordinates
  var x = this.xy[0] + radius * Math.cos(radians);
  var y = this.xy[1] + radius * Math.sin(radians);
  return new SpacePoint([x, y], this);
};

proto.to = function (target) {
  // Create a new SpacePoint at same location but on a
  // different SpacePlane.
  //
  // Parameter
  //   target, a SpacePlane or null.
  //
  // Implementation note (See 2016-03-05-09):
  //
  // First, compute coord. transf. B from the current plane
  // to the space:
  //   x_space = B * x_plane  <=>  x_plane = inv(B) * x_space
  //   B = plane._T
  // Second, let A be coord. transf. from the space to the target plane:
  //   x_target = A * x_space
  //   A = inv(target._T)
  // Therefore combined coord. transf. C from the curr. plane to the target:
  //   x_target = C * x_plane
  //   <=> A * x_space = C * inv(B) * x_space
  //   <=> A = C * inv(B)
  //   <=> C = AB
  //   <=> C = inv(target._T) * plane._T
  //

  if (target === null) {
    // target is the root node (space)
    return this.toSpace();
  }

  // Target's global transformation. This._T is already global.
  var target_gT = target.getGlobalTransform();

  if (target_gT.equals(this._T)) {
    return this;
  } // else
  var C = target_gT.inverse().multiplyBy(this._T);
  var xy_target = C.transform(this.xy);
  return new SpacePoint(xy_target, target);
};

proto.toSpace = function () {
  // Create a new SpacePoint at same location but represented on space coords.
  //
  // Implementation note:
  //   We already have coord. transf. from the current plane to the space:
  //     plane._T
  var xy_space = this._T.transform(this.xy);
  var space_mock = {'_T': Transform.IDENTITY};
  return new SpacePoint(xy_space, space_mock);
};

proto.transform = function (tr) {
  // Create a new point by transformation.
  //
  // Parameter
  //   tr
  //     a Transform
  var xy_hat = tr.transform(this.xy);
  return new SpacePoint(xy_hat, this);
};


module.exports = SpacePoint;

},{"./Transform":33}],29:[function(require,module,exports){
// API v3.0.0

var SpacePoint = require('./SpacePoint');

var SpaceRectangle = function (spaceTransformer) {

  var t = spaceTransformer;  // Alias

  // Rectangles have size.
  // In its own coordinates, rectangle's right bottom corner
  // is located at [width, height].
  // By default transformation, width 1 and height 1 equal to 1 space unit.
  var width = 1;
  var height = 1;

  t.atNorm = function (xy) {
    // Return a SpacePoint by coordinates normalized about the size.
    // atNorm([1,0]) returns the point at the right upper corner.
    return new SpacePoint([width * xy[0], height * xy[1]], t);
  };

  t.atMid = function () {
    return new SpacePoint([width / 2, height / 2], t);
  };

  t.atMidN = function () {
    return new SpacePoint([width / 2, 0], t);
  };

  t.atMidW = function () {
    return new SpacePoint([0, height / 2], t);
  };

  t.atMidE = function () {
    return new SpacePoint([width, height / 2], t);
  };

  t.atMidS = function () {
    return new SpacePoint([width / 2, height], t);
  };

  t.atNW = function () {
    return new SpacePoint([0, 0], t);
  };

  t.atNE = function () {
    return new SpacePoint([width, 0], t);
  };

  t.atSW = function () {
    return new SpacePoint([0, height], t);
  };

  t.atSE = function () {
    return new SpacePoint([width, height], t);
  };

  t.getSize = function () {
    return [width, height];
  };

  t.resize = function (dimensions) {
    // Parameter
    //   dimensions, [width, height]
    width = dimensions[0];
    height = dimensions[1];

    this.emit('resized', t);
  };

};

module.exports = SpaceRectangle;

},{"./SpacePoint":28}],30:[function(require,module,exports){
// API v0.6.0

var Emitter = require('component-emitter');
var SpaceNode = require('./SpaceNode');
var SpacePlane = require('./SpacePlane');
var SpaceTransformer = require('./SpaceTransformer');
var SpaceRectangle = require('./SpaceRectangle');

var SpaceTaa = function (parent, taa) {
  // Parameters:
  //   parent
  //     a SpaceNode
  //   taa
  //     a Taa
  Emitter(this);
  SpaceNode(this);
  SpacePlane(this);
  SpaceTransformer(this);
  SpaceRectangle(this);

  this.taa = taa;
  this.resize([256, 256]);  // Size of taa.

  this.setParent(parent);
};

module.exports = SpaceTaa;

},{"./SpaceNode":26,"./SpacePlane":27,"./SpaceRectangle":29,"./SpaceTransformer":31,"component-emitter":1}],31:[function(require,module,exports){
// API v3.0.0
var nudged = require('nudged');
var Transform = require('./Transform');
var SpacePoint = require('./SpacePoint');

var normalize = function (points, plane) {
  // Transform all the points onto the parent and
  // represent them in array [[x0,y0], [x1,y1], ...].
  //
  // Arguments:
  //   points, a single spacepoint or a list of spacepoints
  //   plane, a SpacePlane e.g. a SpaceTaa onto normalize.
  // Return:
  //   array of xy points in space.
  var i, p, np, normalized;

  if (!Array.isArray(points)) {
    // Single SpacePoint
    p = points;
    np = p.to(plane).xy;
    return [np];
  } // else
  normalized = [];
  for (i = 0; i < points.length; i += 1) {
    p = points[i];
    np = p.to(plane).xy;
    normalized.push(np);
  }
  return normalized;
};


var transformByEstimate = function (plane, type, domain, range, pivot) {
  // Types: T,S,R,TS,TR,SR,TSR (see nudged for further details)

  var normPivot;
  if (typeof pivot !== 'undefined') {
    normPivot = normalize(pivot, plane._parent)[0];
  }

  // Convert all SpacePoints onto the space and to arrays
  var normDomain = normalize(domain, plane._parent);
  var normRange = normalize(range, plane._parent);

  // Then compute optimal transformation in space
  var H_space = nudged.estimate(type, normDomain, normRange, normPivot);
  // See 2016-03-05-11:
  //   To apply transformation to a space object:
  //     T_hat = toParent(H) * T
  // Therefore:
  plane._T = H_space.multiplyBy(plane._T);

  // Notify especially view about transformation.
  plane.emit('transformed', plane);
};


var SpaceTransformer = function (plane) {
  //
  // Parameters
  //   plane
  //     a SpacePlane

  plane.setTransform = function (T) {
    // Needed when we whan to restore stored position, maybe after
    // modification.
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    this._T = T;
    this.emit('transformed', this);
  };

  plane.setGlobalTransform = function (T) {
    // Set local transform so that the global transform becomes the given T.
    //
    // Dev note:
    //   Given T is coord. transf. from the plane to root (space).
    //   So is this._T.
    //   current_glob_trans = parent_glob_trans * this_T
    //   new_glob_trans = parent_glob_trans * X
    //   <=> X = inv(parent_glob_trans) * new_glob_trans
    if (this._parent === null) {
      // We are root, cannot set.
      return;
    }
    var parent_global = this._parent.getGlobalTransform();
    this._T = parent_global.inverse().multiplyBy(T);
    this.emit('transformed', this);
  };

  plane.translate = function (domain, range) {
    // Move plane horizontally and vertically by example.
    //
    // Translate the plane so that after the translation, the domain points
    // would be as close to given range points as possible.
    //
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'T', domain, range);
  };

  plane.scale = function (pivot, multiplierOrDomain, range) {
    // Parameter
    //   pivot, a SpacePoint
    //   multiplier, the scale factor, > 0
    //  OR
    //   pivot
    //   domain
    //   range

    var useMultiplier = (typeof range === 'undefined');

    if (useMultiplier) {
      var normPivot = normalize(pivot, this._parent)[0];
      var multiplier = multiplierOrDomain;
      // Multiplier does not depend on plane.
      // We create a pivoted scaling transform on parent.
      var S_parent = Transform.IDENTITY.scaleBy(multiplier, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = S_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = multiplierOrDomain;
      transformByEstimate(this, 'S', domain, range, pivot);
    }
  };

  plane.rotate = function (pivot, radiansOrDomain, range) {
    // Parameter
    //   pivot
    //   radians
    //  OR
    //   pivot
    //   domain
    //   range

    var useRadians = (typeof range === 'undefined');

    if (useRadians) {
      var normPivot = normalize(pivot, this._parent)[0];
      var radians = radiansOrDomain;
      // Radians do not depend on plane.
      // We create a pivoted rotation transform on parent.
      var R_parent = Transform.IDENTITY.rotateBy(radians, normPivot);
      // See 2016-03-05-11
      //   We transform space objects by:
      //   T_hat = H_space * T
      this._T = R_parent.multiplyBy(this._T);
      this.emit('transformed', this);
    } else {
      var domain = radiansOrDomain;
      transformByEstimate(this, 'R', domain, range, pivot);
    }
  };

  plane.translateScale = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TS', domain, range);
  };

  plane.translateRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TR', domain, range);
  };

  plane.scaleRotate = function (pivot, domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'SR', domain, range, pivot);
  };

  plane.translateScaleRotate = function (domain, range) {
    // Parameter
    //   domain
    //   range

    transformByEstimate(this, 'TSR', domain, range);
  };

  // plane.translateAndScaleToFit, not sure if necessary for now

  plane.on('removed', function (self, oldParent, newParent) {
    // Maintain global location

    if (typeof oldParent === 'undefined') { oldParent = null; }
    if (typeof newParent === 'undefined') { newParent = null; }

    var sameRoot;
    if (newParent === null) {
      // Root nodes cannot move.
      this.resetTransform();
    } else {
      if (oldParent === null) {
        // Removed from null parent?
        throw new Exception('Cannot remove from null parent');
      } else {
        // Moved onto another parent.
        // Let us keep the location in space the same if possible.
        // It is possible only if the parents share same root i.e.
        // are in the same space.
        sameRoot = oldParent.getRootParent() === newParent.getRootParent();
        if (sameRoot) {
          // Keep the location.
          // Let
          //   OT be the old local coord. transformation.
          //   NT be the unknown new local coord. transf.
          //   OPGT be the global coord. transf. of old parent
          //   NPGT be the global coord. transf. of new parent
          // Now, we want to keep global transf. unchanged.
          //   OPGT * OT = NPGT * NT
          //   <=> NT = inv(NPGT) * OPGT * OT
          var opgt = oldParent.getGlobalTransform();
          var npgt = newParent.getGlobalTransform();
          var ot = this._T;
          var nt = npgt.inverse().multiplyBy(opgt).multiplyBy(ot);
          this._T = nt;
          this.emit('transformed', this); // TODO Is needed because inplace?
        } else {
          // In different space: reset
          this.resetTransform();
        }
        // Note: there could be a need to change parent with the same
        // local transformation. Not needed for now.
      }

    }
  });
};

module.exports = SpaceTransformer;

},{"./SpacePoint":28,"./Transform":33,"nudged":12}],32:[function(require,module,exports){
// API v0.6.0
var Emitter = require('component-emitter');
var loadimages = require('loadimages');

var NOOP = function () {};

var Taa = function (imgSrc, onLoaded) {
  // Parameters
  //   imgSrc
  //   onLoaded(err, taa)
  //     optional, function (taa)
  Emitter(this);
  var this2 = this;

  // onLoaded is optional
  if (typeof onLoaded !== 'function') {
    onLoaded = NOOP;
  }

  // This object will be replaced by a real Image object but before that
  // src is needed in SpaceView.
  this.image = { src: imgSrc };

  // If the image is cached, the 'load' event of Image element is
  // fired instantly when calling loadimages. If we did not care
  // about this, the on('loaded', fn) listeners would experience
  // different execution order depending whether the images was
  // cached or not.
  var notCached = false;

  loadimages(imgSrc, function (err, image) {
    var emiterr, emittaa;
    if (err) {
      emiterr = err;
      emittaa = null;
    } else {
      this2.image = image;
      emiterr = null;
      emittaa = this2;
    }

    if (notCached) {
      this2.emit('loaded', emiterr, emittaa);
      onLoaded(emiterr, emittaa);
    } else {
      // Postpone emitting of the loaded event
      setTimeout(function () {
        this2.emit('loaded', emiterr, emittaa);
        onLoaded(emiterr, emittaa);
      }, 0);
    }
  });

  notCached = true;
};

module.exports = Taa;

},{"component-emitter":1,"loadimages":2}],33:[function(require,module,exports){
// API v0.6.0
var nudged = require('nudged');

// TODO
// monkeypatch "to(plane)"

module.exports = nudged.Transform;

},{"nudged":12}],34:[function(require,module,exports){

exports.Taa = require('./Taa');
exports.SpaceTaa = require('./SpaceTaa');
exports.SpaceHTML = require('./SpaceHTML');
exports.Space = require('./Space');
exports.HTMLSpaceView = require('./HTMLSpaceView');

exports.version = require('./version');

},{"./HTMLSpaceView":23,"./Space":24,"./SpaceHTML":25,"./SpaceTaa":30,"./Taa":32,"./version":35}],35:[function(require,module,exports){
module.exports = '3.0.0';

},{}]},{},[34])(34)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9hZGltYWdlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vdmVqcy9ub2RlX21vZHVsZXMvYWZ0ZXItdHJhbnNpdGlvbi9ub2RlX21vZHVsZXMvY3NzLWVtaXR0ZXItY29tcG9uZW50L25vZGVfbW9kdWxlcy9ldmVudC1jb21wb25lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9hZnRlci10cmFuc2l0aW9uL25vZGVfbW9kdWxlcy9oYXMtdHJhbnNpdGlvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jb21wb25lbnQtcXVlcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW92ZWpzL25vZGVfbW9kdWxlcy9jc3MtZWFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb3ZlanMvbm9kZV9tb2R1bGVzL2hhcy10cmFuc2xhdGUzZC9ub2RlX21vZHVsZXMvdHJhbnNmb3JtLXByb3BlcnR5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL1RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUi5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlU1IuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVQuanMiLCJub2RlX21vZHVsZXMvbnVkZ2VkL2xpYi9lc3RpbWF0ZVRSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvZXN0aW1hdGVUUy5qcyIsIm5vZGVfbW9kdWxlcy9udWRnZWQvbGliL2VzdGltYXRlVFNSLmpzIiwibm9kZV9tb2R1bGVzL251ZGdlZC9saWIvdmVyc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZXFpZC9zZXFpZC5qcyIsInNyYy9IVE1MU3BhY2VWaWV3LmpzIiwic3JjL1NwYWNlLmpzIiwic3JjL1NwYWNlSFRNTC5qcyIsInNyYy9TcGFjZU5vZGUuanMiLCJzcmMvU3BhY2VQbGFuZS5qcyIsInNyYy9TcGFjZVBvaW50LmpzIiwic3JjL1NwYWNlUmVjdGFuZ2xlLmpzIiwic3JjL1NwYWNlVGFhLmpzIiwic3JjL1NwYWNlVHJhbnNmb3JtZXIuanMiLCJzcmMvVGFhLmpzIiwic3JjL1RyYW5zZm9ybS5qcyIsInNyYy9pbmRleC5qcyIsInNyYy92ZXJzaW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICBmdW5jdGlvbiBvbigpIHtcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWRpbWFnZXMoaW1nU3JjcywgdGhlbikge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgaW1nU3Jjc1xuICAvLyAgICAgYXJyYXkgb2YgaW1hZ2Ugc291cmNlIHBhdGhzIE9SIHNpbmdsZSBzb3VyY2UgcGF0aCBzdHJpbmcuXG4gIC8vICAgdGhlbihlcnIsIGltZ0VsZW1lbnRzKVxuICAvLyAgICAgV2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHRoZSBpbWFnZXMgYXJlIGxvYWRlZC4gSWYgc3RyaW5nIHdhcyBnaXZlbixcbiAgLy8gICAgIGltZ0VsZW1lbnRzIGlzIGFuIEltYWdlIGluc3RlYWQgb2YgYXJyYXkgb2YgSW1hZ2VzLlxuXG4gIHZhciBudW1iZXJPZkltYWdlcywgc3RyaW5nR2l2ZW4sIHRoZXJlV2FzU3VjY2VzcywgdGhlcmVXYXNFcnJvciwgaW1ncztcbiAgdmFyIG9ubG9hZHNDYWxsZWQsIG9ubG9hZCwgb25lcnJvcjtcblxuICBpZiAodHlwZW9mIHRoZW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIHNob3VsZCBiZSBhIGZ1bmN0aW9uOiAnICsgdGhlbik7XG4gIH1cblxuICBpZiAodHlwZW9mIGltZ1NyY3MgPT09ICdzdHJpbmcnKSB7XG4gICAgbnVtYmVyT2ZJbWFnZXMgPSAxO1xuICAgIHN0cmluZ0dpdmVuID0gdHJ1ZTtcbiAgICBpbWdTcmNzID0gW2ltZ1NyY3NdOyAvLyBOb3JtYWxpemVcbiAgfSBlbHNlIHtcbiAgICAvLyBBcnJheSBvZiBpbWFnZXNcbiAgICBudW1iZXJPZkltYWdlcyA9IGltZ1NyY3MubGVuZ3RoO1xuICAgIHN0cmluZ0dpdmVuID0gZmFsc2U7XG4gIH1cbiAgdGhlcmVXYXNTdWNjZXNzID0gZmFsc2U7XG4gIHRoZXJlV2FzRXJyb3IgPSBmYWxzZTtcblxuICBpbWdzID0gW107XG5cbiAgb25sb2Fkc0NhbGxlZCA9IDA7XG4gIG9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBOb3RlOlxuICAgIC8vICAgdGhpcyA9IEltYWdlXG4gICAgaWYgKCF0aGVyZVdhc0Vycm9yKSB7XG4gICAgICBvbmxvYWRzQ2FsbGVkICs9IDE7XG4gICAgICB2YXIgaXNGaW5hbEltYWdlID0gKG9ubG9hZHNDYWxsZWQgPT09IG51bWJlck9mSW1hZ2VzKTtcbiAgICAgIGlmIChpc0ZpbmFsSW1hZ2UpIHtcbiAgICAgICAgdGhlcmVXYXNTdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmluZ0dpdmVuKSB7XG4gICAgICAgICAgdGhlbihudWxsLCBpbWdzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGVuKG51bGwsIGltZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyTXNnKSB7XG4gICAgLy8gTm90ZTpcbiAgICAvLyAgIHRoaXMgPSBJbWFnZVxuXG4gICAgLy8gTm8gZXJyb3JzIGFmdGVyIHN1Y2Nlc3MuXG4gICAgaWYgKCF0aGVyZVdhc1N1Y2Nlc3MpIHtcbiAgICAgIHRoZXJlV2FzRXJyb3IgPSB0cnVlO1xuICAgICAgdGhlbihlcnJNc2csIG51bGwpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZmlyaW5nIHRoZSBkZWZhdWx0IGV2ZW50IGhhbmRsZXJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvR2xvYmFsRXZlbnRIYW5kbGVycy5vbmVycm9yI1BhcmFtZXRlcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaW1nU3Jjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGltZ3MucHVzaChuZXcgSW1hZ2UoKSk7XG4gICAgaW1nc1tpXS5vbmxvYWQgPSBvbmxvYWQ7XG4gICAgaW1nc1tpXS5vbmVycm9yID0gb25lcnJvcjtcbiAgICBpbWdzW2ldLnNyYyA9IGltZ1NyY3NbaV07XG4gIH1cbn07XG4iLCIvKipcbiAqIE1vZHVsZSBEZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHF1ZXJ5ID0gcmVxdWlyZSgnY29tcG9uZW50LXF1ZXJ5Jyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlci10cmFuc2l0aW9uJyk7XG52YXIgaGFzM2QgPSByZXF1aXJlKCdoYXMtdHJhbnNsYXRlM2QnKTtcbnZhciBlYXNlID0gcmVxdWlyZSgnY3NzLWVhc2UnKTtcblxuLyoqXG4gKiBDU1MgVHJhbnNsYXRlXG4gKi9cblxudmFyIHRyYW5zbGF0ZSA9IGhhczNkXG4gID8gWyd0cmFuc2xhdGUzZCgnLCAnLCAwKSddXG4gIDogWyd0cmFuc2xhdGUoJywgJyknXTtcblxuLyoqXG4gKiBFeHBvcnQgYE1vdmVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNb3ZlO1xuXG4vKipcbiAqIEdldCBjb21wdXRlZCBzdHlsZS5cbiAqL1xuXG52YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZVxuICB8fCB3aW5kb3cuY3VycmVudFN0eWxlO1xuXG4vKipcbiAqIExpYnJhcnkgdmVyc2lvbi5cbiAqL1xuXG5Nb3ZlLnZlcnNpb24gPSAnMC41LjAnO1xuXG4vKipcbiAqIEV4cG9ydCBgZWFzZWBcbiAqL1xuXG5Nb3ZlLmVhc2UgPSBlYXNlO1xuXG4vKipcbiAqIERlZmF1bHRzLlxuICpcbiAqICAgYGR1cmF0aW9uYCAtIGRlZmF1bHQgZHVyYXRpb24gb2YgNTAwbXNcbiAqXG4gKi9cblxuTW92ZS5kZWZhdWx0cyA9IHtcbiAgZHVyYXRpb246IDUwMFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGVsZW1lbnQgc2VsZWN0aW9uIHV0aWxpemVkIGJ5IGBtb3ZlKHNlbGVjdG9yKWAuXG4gKlxuICogT3ZlcnJpZGUgdG8gaW1wbGVtZW50IHlvdXIgb3duIHNlbGVjdGlvbiwgZm9yIGV4YW1wbGVcbiAqIHdpdGggalF1ZXJ5IG9uZSBtaWdodCB3cml0ZTpcbiAqXG4gKiAgICAgbW92ZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICogICAgICAgcmV0dXJuIGpRdWVyeShzZWxlY3RvcikuZ2V0KDApO1xuICogICAgIH07XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7RWxlbWVudH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2Ygc2VsZWN0b3IpIHJldHVybiBzZWxlY3RvcjtcbiAgcmV0dXJuIHF1ZXJ5KHNlbGVjdG9yKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTW92ZWAgd2l0aCB0aGUgZ2l2ZW4gYGVsYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1vdmUoZWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdmUpKSByZXR1cm4gbmV3IE1vdmUoZWwpO1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGVsKSBlbCA9IHF1ZXJ5KGVsKTtcbiAgaWYgKCFlbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTW92ZSBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggZWxlbWVudCBvciBzZWxlY3RvcicpO1xuICB0aGlzLmVsID0gZWw7XG4gIHRoaXMuX3Byb3BzID0ge307XG4gIHRoaXMuX3JvdGF0ZSA9IDA7XG4gIHRoaXMuX3RyYW5zaXRpb25Qcm9wcyA9IFtdO1xuICB0aGlzLl90cmFuc2Zvcm1zID0gW107XG4gIHRoaXMuZHVyYXRpb24oTW92ZS5kZWZhdWx0cy5kdXJhdGlvbilcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxuICovXG5cbkVtaXR0ZXIoTW92ZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEJ1ZmZlciBgdHJhbnNmb3JtYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSl7XG4gIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tldyBgeGAgYW5kIGB5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3ID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2tldygnXG4gICAgKyB4ICsgJ2RlZywgJ1xuICAgICsgKHkgfHwgMClcbiAgICArICdkZWcpJyk7XG59O1xuXG4vKipcbiAqIFNrZXcgeCBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5za2V3WCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NrZXdYKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogU2tldyB5IGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNrZXdZID0gZnVuY3Rpb24obil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2tld1koJyArIG4gKyAnZGVnKScpO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYHhgIGFuZCBgeWAgYXhpcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50cmFuc2xhdGUgPVxuTW92ZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbih4LCB5KXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHRyYW5zbGF0ZS5qb2luKCcnXG4gICAgKyB4ICsncHgsICdcbiAgICArICh5IHx8IDApXG4gICAgKyAncHgnKSk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBvbiB0aGUgeCBheGlzIHRvIGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zbGF0ZVggPVxuTW92ZS5wcm90b3R5cGUueCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZVgoJyArIG4gKyAncHgpJyk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBvbiB0aGUgeSBheGlzIHRvIGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zbGF0ZVkgPVxuTW92ZS5wcm90b3R5cGUueSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZVkoJyArIG4gKyAncHgpJyk7XG59O1xuXG4vKipcbiAqIFNjYWxlIHRoZSB4IGFuZCB5IGF4aXMgYnkgYHhgLCBvclxuICogaW5kaXZpZHVhbGx5IHNjYWxlIGB4YCBhbmQgYHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oeCwgeSl7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2NhbGUoJ1xuICAgICsgeCArICcsICdcbiAgICArICh5IHx8IHgpXG4gICAgKyAnKScpO1xufTtcblxuLyoqXG4gKiBTY2FsZSB4IGF4aXMgYnkgYG5gLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc2NhbGVYID0gZnVuY3Rpb24obil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgnc2NhbGVYKCcgKyBuICsgJyknKVxufTtcblxuLyoqXG4gKiBBcHBseSBhIG1hdHJpeCB0cmFuc2Zvcm1hdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQSBtYXRyaXggY29lZmZpY2llbnRcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5tYXRyaXggPSBmdW5jdGlvbihtMTEsIG0xMiwgbTIxLCBtMjIsIG0zMSwgbTMyKXtcbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKCdtYXRyaXgoJyArIFttMTEsbTEyLG0yMSxtMjIsbTMxLG0zMl0uam9pbignLCcpICsgJyknKTtcbn07XG5cbi8qKlxuICogU2NhbGUgeSBheGlzIGJ5IGBuYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNjYWxlWSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oJ3NjYWxlWSgnICsgbiArICcpJylcbn07XG5cbi8qKlxuICogUm90YXRlIGBuYCBkZWdyZWVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24obil7XG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybSgncm90YXRlKCcgKyBuICsgJ2RlZyknKTtcbn07XG5cbi8qKlxuICogU2V0IHRyYW5zaXRpb24gZWFzaW5nIGZ1bmN0aW9uIHRvIHRvIGBmbmAgc3RyaW5nLlxuICpcbiAqIFdoZW46XG4gKlxuICogICAtIG51bGwgXCJlYXNlXCIgaXMgdXNlZFxuICogICAtIFwiaW5cIiBcImVhc2UtaW5cIiBpcyB1c2VkXG4gKiAgIC0gXCJvdXRcIiBcImVhc2Utb3V0XCIgaXMgdXNlZFxuICogICAtIFwiaW4tb3V0XCIgXCJlYXNlLWluLW91dFwiIGlzIHVzZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5lYXNlID0gZnVuY3Rpb24oZm4pe1xuICBmbiA9IGVhc2VbZm5dIHx8IGZuIHx8ICdlYXNlJztcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgZm4pO1xufTtcblxuLyoqXG4gKiBTZXQgYW5pbWF0aW9uIHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHByb3BzKXtcbiAgZm9yICh2YXIgaSBpbiBwcm9wcyl7XG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGkpKXtcbiAgICAgIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ2FuaW1hdGlvbi0nICsgaSwgcHJvcHNbaV0pXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnNldFZlbmRvclByb3BlcnR5KCdhbmltYXRpb24tbmFtZScsIG5hbWUpO1xufVxuXG4vKipcbiAqIFNldCBkdXJhdGlvbiB0byBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihuKXtcbiAgbiA9IHRoaXMuX2R1cmF0aW9uID0gJ3N0cmluZycgPT0gdHlwZW9mIG5cbiAgICA/IHBhcnNlRmxvYXQobikgKiAxMDAwXG4gICAgOiBuO1xuICByZXR1cm4gdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNpdGlvbi1kdXJhdGlvbicsIG4gKyAnbXMnKTtcbn07XG5cbi8qKlxuICogRGVsYXkgdGhlIGFuaW1hdGlvbiBieSBgbmAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBuXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbihuKXtcbiAgbiA9ICdzdHJpbmcnID09IHR5cGVvZiBuXG4gICAgPyBwYXJzZUZsb2F0KG4pICogMTAwMFxuICAgIDogbjtcbiAgcmV0dXJuIHRoaXMuc2V0VmVuZG9yUHJvcGVydHkoJ3RyYW5zaXRpb24tZGVsYXknLCBuICsgJ21zJyk7XG59O1xuXG4vKipcbiAqIFNldCBgcHJvcGAgdG8gYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIHZhbCl7XG4gIHRoaXMuX3Byb3BzW3Byb3BdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGEgdmVuZG9yIHByZWZpeGVkIGBwcm9wYCB3aXRoIHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLnNldFZlbmRvclByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLXdlYmtpdC0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW1vei0nICsgcHJvcCwgdmFsKTtcbiAgdGhpcy5zZXRQcm9wZXJ0eSgnLW1zLScgKyBwcm9wLCB2YWwpO1xuICB0aGlzLnNldFByb3BlcnR5KCctby0nICsgcHJvcCwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBgcHJvcGAgdG8gYHZhbHVlYCwgZGVmZXJyZWQgdW50aWwgYC5lbmQoKWAgaXMgaW52b2tlZFxuICogYW5kIGFkZHMgdGhlIHByb3BlcnR5IHRvIHRoZSBsaXN0IG9mIHRyYW5zaXRpb24gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICB0aGlzLnRyYW5zaXRpb24ocHJvcCk7XG4gIHRoaXMuX3Byb3BzW3Byb3BdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5jcmVtZW50IGBwcm9wYCBieSBgdmFsYCwgZGVmZXJyZWQgdW50aWwgYC5lbmQoKWAgaXMgaW52b2tlZFxuICogYW5kIGFkZHMgdGhlIHByb3BlcnR5IHRvIHRoZSBsaXN0IG9mIHRyYW5zaXRpb24gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwcm9wLCB2YWwpe1xuICBpZiAoIXN0eWxlKSByZXR1cm47XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMub24oJ3N0YXJ0JywgZnVuY3Rpb24oKXtcbiAgICB2YXIgY3VyciA9IHBhcnNlSW50KHNlbGYuY3VycmVudChwcm9wKSwgMTApO1xuICAgIHNlbGYuc2V0KHByb3AsIGN1cnIgKyB2YWwgKyAncHgnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlY3JlbWVudCBgcHJvcGAgYnkgYHZhbGAsIGRlZmVycmVkIHVudGlsIGAuZW5kKClgIGlzIGludm9rZWRcbiAqIGFuZCBhZGRzIHRoZSBwcm9wZXJ0eSB0byB0aGUgbGlzdCBvZiB0cmFuc2l0aW9uIHByb3BzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgaWYgKCFzdHlsZSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLm9uKCdzdGFydCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN1cnIgPSBwYXJzZUludChzZWxmLmN1cnJlbnQocHJvcCksIDEwKTtcbiAgICBzZWxmLnNldChwcm9wLCBjdXJyIC0gdmFsICsgJ3B4Jyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgY29tcHV0ZWQgb3IgXCJjdXJyZW50XCIgdmFsdWUgb2YgYHByb3BgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vdmUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbihwcm9wKXtcbiAgcmV0dXJuIHN0eWxlKHRoaXMuZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG59O1xuXG4vKipcbiAqIEFkZCBgcHJvcGAgdG8gdGhlIGxpc3Qgb2YgaW50ZXJuYWwgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vdmUucHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbihwcm9wKXtcbiAgaWYgKCF0aGlzLl90cmFuc2l0aW9uUHJvcHMuaW5kZXhPZihwcm9wKSkgcmV0dXJuIHRoaXM7XG4gIHRoaXMuX3RyYW5zaXRpb25Qcm9wcy5wdXNoKHByb3ApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tbWl0IHN0eWxlIHByb3BlcnRpZXMsIGFrYSBhcHBseSB0aGVtIHRvIGBlbC5zdHlsZWAuXG4gKlxuICogQHJldHVybiB7TW92ZX0gZm9yIGNoYWluaW5nXG4gKiBAc2VlIE1vdmUjZW5kKClcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vdmUucHJvdG90eXBlLmFwcGx5UHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIHByb3AgaW4gdGhpcy5fcHJvcHMpIHtcbiAgICB0aGlzLmVsLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHRoaXMuX3Byb3BzW3Byb3BdLCAnJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlLXNlbGVjdCBlbGVtZW50IHZpYSBgc2VsZWN0b3JgLCByZXBsYWNpbmdcbiAqIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtNb3ZlfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUubW92ZSA9XG5Nb3ZlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gIHRoaXMuZWwgPSBNb3ZlLnNlbGVjdChzZWxlY3Rvcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZlciB0aGUgZ2l2ZW4gYGZuYCB1bnRpbCB0aGUgYW5pbWF0aW9uXG4gKiBpcyBjb21wbGV0ZS4gYGZuYCBtYXkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogICAtIGEgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIC0gYW4gaW5zdGFuY2VvZiBgTW92ZWAgdG8gY2FsbCBgLmVuZCgpYFxuICogICAtIG5vdGhpbmcsIHRvIHJldHVybiBhIGNsb25lIG9mIHRoaXMgYE1vdmVgIGluc3RhbmNlIGZvciBjaGFpbmluZ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258TW92ZX0gZm5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oZm4pe1xuICAvLyBpbnZva2UgLmVuZCgpXG4gIGlmIChmbiBpbnN0YW5jZW9mIE1vdmUpIHtcbiAgICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgICAgZm4uZW5kKCk7XG4gICAgfSk7XG4gIC8vIGNhbGxiYWNrXG4gIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZm4pIHtcbiAgICB0aGlzLm9uKCdlbmQnLCBmbik7XG4gIC8vIGNoYWluXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNsb25lID0gbmV3IE1vdmUodGhpcy5lbCk7XG4gICAgY2xvbmUuX3RyYW5zZm9ybXMgPSB0aGlzLl90cmFuc2Zvcm1zLnNsaWNlKDApO1xuICAgIHRoaXMudGhlbihjbG9uZSk7XG4gICAgY2xvbmUucGFyZW50ID0gdGhpcztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUG9wIHRoZSBtb3ZlIGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7TW92ZX0gcGFyZW50IE1vdmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW92ZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuLyoqXG4gKiBSZXNldCBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtNb3ZlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZWwuc3R5bGUud2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5tb3pUcmFuc2l0aW9uRHVyYXRpb24gPVxuICB0aGlzLmVsLnN0eWxlLm1zVHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgdGhpcy5lbC5zdHlsZS5vVHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydCBhbmltYXRpb24sIG9wdGlvbmFsbHkgY2FsbGluZyBgZm5gIHdoZW4gY29tcGxldGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge01vdmV9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb3ZlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBlbWl0IFwic3RhcnRcIiBldmVudFxuICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XG5cbiAgLy8gdHJhbnNmb3Jtc1xuICBpZiAodGhpcy5fdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICB0aGlzLnNldFZlbmRvclByb3BlcnR5KCd0cmFuc2Zvcm0nLCB0aGlzLl90cmFuc2Zvcm1zLmpvaW4oJyAnKSk7XG4gIH1cblxuICAvLyB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgdGhpcy5zZXRWZW5kb3JQcm9wZXJ0eSgndHJhbnNpdGlvbi1wcm9wZXJ0aWVzJywgdGhpcy5fdHJhbnNpdGlvblByb3BzLmpvaW4oJywgJykpO1xuICB0aGlzLmFwcGx5UHJvcGVydGllcygpO1xuXG4gIC8vIGNhbGxiYWNrIGdpdmVuXG4gIGlmIChmbikgdGhpcy50aGVuKGZuKTtcblxuICAvLyBlbWl0IFwiZW5kXCIgd2hlbiBjb21wbGV0ZVxuICBhZnRlci5vbmNlKHRoaXMuZWwsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5yZXNldCgpO1xuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbiIsInZhciBoYXNUcmFuc2l0aW9ucyA9IHJlcXVpcmUoJ2hhcy10cmFuc2l0aW9ucycpO1xudmFyIGVtaXR0ZXIgPSByZXF1aXJlKCdjc3MtZW1pdHRlcicpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zaXRpb24oZWwsIGNhbGxiYWNrKSB7XG4gIGlmKGhhc1RyYW5zaXRpb25zKGVsKSkge1xuICAgIHJldHVybiBlbWl0dGVyKGVsKS5iaW5kKGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2suYXBwbHkoZWwpO1xufTtcblxuYWZ0ZXJUcmFuc2l0aW9uLm9uY2UgPSBmdW5jdGlvbihlbCwgY2FsbGJhY2spIHtcbiAgYWZ0ZXJUcmFuc2l0aW9uKGVsLCBmdW5jdGlvbiBmbigpe1xuICAgIGNhbGxiYWNrLmFwcGx5KGVsKTtcbiAgICBlbWl0dGVyKGVsKS51bmJpbmQoZm4pO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJUcmFuc2l0aW9uOyIsIi8qKlxuICogTW9kdWxlIERlcGVuZGVuY2llc1xuICovXG5cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudCcpO1xuXG4vLyBDU1MgZXZlbnRzXG5cbnZhciB3YXRjaCA9IFtcbiAgJ3RyYW5zaXRpb25lbmQnXG4sICd3ZWJraXRUcmFuc2l0aW9uRW5kJ1xuLCAnb1RyYW5zaXRpb25FbmQnXG4sICdNU1RyYW5zaXRpb25FbmQnXG4sICdhbmltYXRpb25lbmQnXG4sICd3ZWJraXRBbmltYXRpb25FbmQnXG4sICdvQW5pbWF0aW9uRW5kJ1xuLCAnTVNBbmltYXRpb25FbmQnXG5dO1xuXG4vKipcbiAqIEV4cG9zZSBgQ1NTbmV4dGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENzc0VtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ3NzRW1pdHRlcmBcbiAqXG4gKi9cblxuZnVuY3Rpb24gQ3NzRW1pdHRlcihlbGVtZW50KXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENzc0VtaXR0ZXIpKSByZXR1cm4gbmV3IENzc0VtaXR0ZXIoZWxlbWVudCk7XG4gIHRoaXMuZWwgPSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEJpbmQgQ1NTIGV2ZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNzc0VtaXR0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihmbil7XG4gIGZvciAodmFyIGk9MDsgaSA8IHdhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgZXZlbnRzLmJpbmQodGhpcy5lbCwgd2F0Y2hbaV0sIGZuKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kIENTUyBldmVudHNcbiAqIFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Dc3NFbWl0dGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihmbil7XG4gIGZvciAodmFyIGk9MDsgaSA8IHdhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgZXZlbnRzLnVuYmluZCh0aGlzLmVsLCB3YXRjaFtpXSwgZm4pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaXJlIGNhbGxiYWNrIG9ubHkgb25jZVxuICogXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNzc0VtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gb24oKXtcbiAgICBzZWxmLnVuYmluZChvbik7XG4gICAgZm4uYXBwbHkoc2VsZi5lbCwgYXJndW1lbnRzKTtcbiAgfVxuICBzZWxmLmJpbmQob24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbiIsIlxuLyoqXG4gKiBCaW5kIGBlbGAgZXZlbnQgYHR5cGVgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgYGVsYCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51bmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGNhcHR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyB0eXBlLCBmbik7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcbiIsIi8qKlxuICogVGhpcyB3aWxsIHN0b3JlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZSBjdXJyZW50XG4gKiBicm93c2VyIHVzZXMgZm9yIHRyYW5zaXRpb25EdXJhdGlvblxuICovXG52YXIgcHJvcGVydHk7XG5cbi8qKlxuICogVGhlIHByb3BlcnRpZXMgd2UnbGwgY2hlY2sgb24gYW4gZWxlbWVudFxuICogdG8gZGV0ZXJtaW5lIGlmIGl0IGFjdHVhbGx5IGhhcyB0cmFuc2l0aW9uc1xuICogV2UgdXNlIGR1cmF0aW9uIGFzIHRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHlcbiAqIG5lZWRlZCB0byB0ZWNobmljYWxseSBoYXZlIHRyYW5zaXRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciB0eXBlcyA9IFtcbiAgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIixcbiAgXCJNb3pUcmFuc2l0aW9uRHVyYXRpb25cIixcbiAgXCJ3ZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cIlxuXTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGNvcnJlY3QgcHJvcGVydHkgZm9yIHRoaXMgYnJvd3NlclxuICoganVzdCBvbmNlIHNvIHdlIGRvbmUgbmVlZCB0byBjaGVjayBldmVyeSB0aW1lXG4gKi9cbndoaWxlKHR5cGVzLmxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVzLnNoaWZ0KCk7XG4gIGlmKHR5cGUgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSkge1xuICAgIHByb3BlcnR5ID0gdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0cmFuc2l0aW9ucyBvclxuICogaWYgYW4gZWxlbWVudCBoYXMgdHJhbnNpdGlvbnMgYXQgYWxsLlxuICogQHBhcmFtICB7RWxlbWVudH0gIGVsIE9wdGlvbmFsLiBSZXR1cm5zIGJyb3dzZXIgc3VwcG9ydCBpZiBub3QgaW5jbHVkZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1RyYW5zaXRpb25zKGVsKXtcbiAgaWYoIXByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBObyBicm93c2VyIHN1cHBvcnQgZm9yIHRyYW5zaXRpb25zXG4gIH1cbiAgaWYoIWVsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5ICE9IG51bGw7IC8vIFdlIGp1c3Qgd2FudCB0byBrbm93IGlmIGJyb3dzZXJzIHN1cHBvcnQgaXRcbiAgfVxuICB2YXIgZHVyYXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGVsKVtwcm9wZXJ0eV07XG4gIHJldHVybiBkdXJhdGlvbiAhPT0gXCJcIiAmJiBwYXJzZUZsb2F0KGR1cmF0aW9uKSAhPT0gMDsgLy8gRG9lcyB0aGlzIGVsZW1lbnQgaGF2ZSB0cmFuc2l0aW9ucz9cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNUcmFuc2l0aW9uczsiLCJmdW5jdGlvbiBvbmUoc2VsZWN0b3IsIGVsKSB7XG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIG9uZShzZWxlY3RvciwgZWwpO1xufTtcblxuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbihzZWxlY3RvciwgZWwpe1xuICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59O1xuXG5leHBvcnRzLmVuZ2luZSA9IGZ1bmN0aW9uKG9iail7XG4gIGlmICghb2JqLm9uZSkgdGhyb3cgbmV3IEVycm9yKCcub25lIGNhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIGlmICghb2JqLmFsbCkgdGhyb3cgbmV3IEVycm9yKCcuYWxsIGNhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIG9uZSA9IG9iai5vbmU7XG4gIGV4cG9ydHMuYWxsID0gb2JqLmFsbDtcbiAgcmV0dXJuIGV4cG9ydHM7XG59O1xuIiwiXG4vKipcbiAqIENTUyBFYXNpbmcgZnVuY3Rpb25zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ2luJzogICAgICAgICAgICAgICAgJ2Vhc2UtaW4nXG4gICwgJ291dCc6ICAgICAgICAgICAgICAgJ2Vhc2Utb3V0J1xuICAsICdpbi1vdXQnOiAgICAgICAgICAgICdlYXNlLWluLW91dCdcbiAgLCAnc25hcCc6ICAgICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAsMSwuNSwxKSdcbiAgLCAnbGluZWFyJzogICAgICAgICAgICAnY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjI1MCwgMC43NTAsIDAuNzUwKSdcbiAgLCAnZWFzZS1pbi1xdWFkJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA4NSwgMC42ODAsIDAuNTMwKSdcbiAgLCAnZWFzZS1pbi1jdWJpYyc6ICAgICAnY3ViaWMtYmV6aWVyKDAuNTUwLCAwLjA1NSwgMC42NzUsIDAuMTkwKSdcbiAgLCAnZWFzZS1pbi1xdWFydCc6ICAgICAnY3ViaWMtYmV6aWVyKDAuODk1LCAwLjAzMCwgMC42ODUsIDAuMjIwKSdcbiAgLCAnZWFzZS1pbi1xdWludCc6ICAgICAnY3ViaWMtYmV6aWVyKDAuNzU1LCAwLjA1MCwgMC44NTUsIDAuMDYwKSdcbiAgLCAnZWFzZS1pbi1zaW5lJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNDcwLCAwLjAwMCwgMC43NDUsIDAuNzE1KSdcbiAgLCAnZWFzZS1pbi1leHBvJzogICAgICAnY3ViaWMtYmV6aWVyKDAuOTUwLCAwLjA1MCwgMC43OTUsIDAuMDM1KSdcbiAgLCAnZWFzZS1pbi1jaXJjJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNjAwLCAwLjA0MCwgMC45ODAsIDAuMzM1KSdcbiAgLCAnZWFzZS1pbi1iYWNrJzogICAgICAnY3ViaWMtYmV6aWVyKDAuNjAwLCAtMC4yODAsIDAuNzM1LCAwLjA0NSknXG4gICwgJ2Vhc2Utb3V0LXF1YWQnOiAgICAgJ2N1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCknXG4gICwgJ2Vhc2Utb3V0LWN1YmljJzogICAgJ2N1YmljLWJlemllcigwLjIxNSwgMC42MTAsIDAuMzU1LCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LXF1YXJ0JzogICAgJ2N1YmljLWJlemllcigwLjE2NSwgMC44NDAsIDAuNDQwLCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LXF1aW50JzogICAgJ2N1YmljLWJlemllcigwLjIzMCwgMS4wMDAsIDAuMzIwLCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LXNpbmUnOiAgICAgJ2N1YmljLWJlemllcigwLjM5MCwgMC41NzUsIDAuNTY1LCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LWV4cG8nOiAgICAgJ2N1YmljLWJlemllcigwLjE5MCwgMS4wMDAsIDAuMjIwLCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LWNpcmMnOiAgICAgJ2N1YmljLWJlemllcigwLjA3NSwgMC44MjAsIDAuMTY1LCAxLjAwMCknXG4gICwgJ2Vhc2Utb3V0LWJhY2snOiAgICAgJ2N1YmljLWJlemllcigwLjE3NSwgMC44ODUsIDAuMzIwLCAxLjI3NSknXG4gICwgJ2Vhc2Utb3V0LXF1YWQnOiAgICAgJ2N1YmljLWJlemllcigwLjQ1NSwgMC4wMzAsIDAuNTE1LCAwLjk1NSknXG4gICwgJ2Vhc2Utb3V0LWN1YmljJzogICAgJ2N1YmljLWJlemllcigwLjY0NSwgMC4wNDUsIDAuMzU1LCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LXF1YXJ0JzogJ2N1YmljLWJlemllcigwLjc3MCwgMC4wMDAsIDAuMTc1LCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LXF1aW50JzogJ2N1YmljLWJlemllcigwLjg2MCwgMC4wMDAsIDAuMDcwLCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LXNpbmUnOiAgJ2N1YmljLWJlemllcigwLjQ0NSwgMC4wNTAsIDAuNTUwLCAwLjk1MCknXG4gICwgJ2Vhc2UtaW4tb3V0LWV4cG8nOiAgJ2N1YmljLWJlemllcigxLjAwMCwgMC4wMDAsIDAuMDAwLCAxLjAwMCknXG4gICwgJ2Vhc2UtaW4tb3V0LWNpcmMnOiAgJ2N1YmljLWJlemllcigwLjc4NSwgMC4xMzUsIDAuMTUwLCAwLjg2MCknXG4gICwgJ2Vhc2UtaW4tb3V0LWJhY2snOiAgJ2N1YmljLWJlemllcigwLjY4MCwgLTAuNTUwLCAwLjI2NSwgMS41NTApJ1xufTtcbiIsIlxudmFyIHByb3AgPSByZXF1aXJlKCd0cmFuc2Zvcm0tcHJvcGVydHknKTtcblxuLy8gSUUgPD04IGRvZXNuJ3QgaGF2ZSBgZ2V0Q29tcHV0ZWRTdHlsZWBcbmlmICghcHJvcCB8fCAhd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxufSBlbHNlIHtcbiAgdmFyIG1hcCA9IHtcbiAgICB3ZWJraXRUcmFuc2Zvcm06ICctd2Via2l0LXRyYW5zZm9ybScsXG4gICAgT1RyYW5zZm9ybTogJy1vLXRyYW5zZm9ybScsXG4gICAgbXNUcmFuc2Zvcm06ICctbXMtdHJhbnNmb3JtJyxcbiAgICBNb3pUcmFuc2Zvcm06ICctbW96LXRyYW5zZm9ybScsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJ1xuICB9O1xuXG4gIC8vIGZyb206IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2xvcmVuem9wb2xpZG9yaS8zNzk0MjI2XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5zdHlsZVtwcm9wXSA9ICd0cmFuc2xhdGUzZCgxcHgsMXB4LDFweCknO1xuICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gIHZhciB2YWwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKG1hcFtwcm9wXSk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICBtb2R1bGUuZXhwb3J0cyA9IG51bGwgIT0gdmFsICYmIHZhbC5sZW5ndGggJiYgJ25vbmUnICE9IHZhbDtcbn1cbiIsIlxudmFyIHN0eWxlcyA9IFtcbiAgJ3dlYmtpdFRyYW5zZm9ybScsXG4gICdNb3pUcmFuc2Zvcm0nLFxuICAnbXNUcmFuc2Zvcm0nLFxuICAnT1RyYW5zZm9ybScsXG4gICd0cmFuc2Zvcm0nXG5dO1xuXG52YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG52YXIgc3R5bGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gIHN0eWxlID0gc3R5bGVzW2ldO1xuICBpZiAobnVsbCAhPSBlbC5zdHlsZVtzdHlsZV0pIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHN0eWxlO1xuICAgIGJyZWFrO1xuICB9XG59XG4iLCIvKlxuXG4qL1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9UcmFuc2Zvcm0nKTtcbmV4cG9ydHMuZXN0aW1hdGVUID0gcmVxdWlyZSgnLi9saWIvZXN0aW1hdGVUJyk7XG5leHBvcnRzLmVzdGltYXRlUyA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlUycpO1xuZXhwb3J0cy5lc3RpbWF0ZVIgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVInKTtcbmV4cG9ydHMuZXN0aW1hdGVUUyA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlVFMnKTtcbmV4cG9ydHMuZXN0aW1hdGVUUiA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlVFInKTtcbmV4cG9ydHMuZXN0aW1hdGVTUiA9IHJlcXVpcmUoJy4vbGliL2VzdGltYXRlU1InKTtcbmV4cG9ydHMuZXN0aW1hdGVUU1IgPSByZXF1aXJlKCcuL2xpYi9lc3RpbWF0ZVRTUicpO1xuZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9saWIvdmVyc2lvbicpO1xuXG5leHBvcnRzLmVzdGltYXRlID0gZnVuY3Rpb24gKHR5cGUsIGRvbWFpbiwgcmFuZ2UsIHBpdm90KSB7XG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHR5cGVcbiAgLy8gICAgIHN0cmluZy4gT25lIG9mIHRoZSBmb2xsb3dpbmc6ICdUJywgJ1MnLCAnUicsICdUUycsICdUUicsICdTUicsICdUU1InXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiAyZCBhcnJheXNcbiAgLy8gICByYW5nZVxuICAvLyAgICAgYXJyYXkgb2YgMmQgYXJyYXlzXG4gIC8vICAgcGl2b3RcbiAgLy8gICAgIG9wdGlvbmFsIDJkIGFycmF5LCBkb2VzIG5vdGhpbmcgZm9yIHRyYW5zbGF0aW9uIGVzdGltYXRvcnNcbiAgdmFyIG5hbWUgPSAnZXN0aW1hdGUnICsgdHlwZS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybiBleHBvcnRzW25hbWVdKGRvbWFpbiwgcmFuZ2UsIHBpdm90KTtcbiAgfSAvLyBlbHNlXG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlc3RpbWF0b3IgdHlwZTogJyArIHR5cGUpO1xufTtcbiIsIlxudmFyIFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzLCByLCB0eCwgdHkpIHtcblxuICAvLyBQdWJsaWMsIHRvIGFsbG93IHVzZXIgYWNjZXNzXG4gIHRoaXMucyA9IHM7XG4gIHRoaXMuciA9IHI7XG4gIHRoaXMudHggPSB0eDtcbiAgdGhpcy50eSA9IHR5O1xuXG4gIHRoaXMuZXF1YWxzID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gKHMgPT09IHQucyAmJiByID09PSB0LnIgJiYgdHggPT09IHQudHggJiYgdHkgPT09IHQudHkpO1xuICB9O1xuXG4gIHRoaXMudHJhbnNmb3JtID0gZnVuY3Rpb24gKHApIHtcbiAgICAvLyBwXG4gICAgLy8gICBwb2ludCBbeCwgeV0gb3IgYXJyYXkgb2YgcG9pbnRzIFtbeDEseTFdLCBbeDIsIHkyXSwgLi4uXVxuXG4gICAgaWYgKHR5cGVvZiBwWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gU2luZ2xlIHBvaW50XG4gICAgICByZXR1cm4gW3MgKiBwWzBdIC0gciAqIHBbMV0gKyB0eCwgciAqIHBbMF0gKyBzICogcFsxXSArIHR5XTtcbiAgICB9IC8vIGVsc2VcblxuICAgIHZhciBpLCBjID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGMucHVzaChbcyAqIHBbaV1bMF0gLSByICogcFtpXVsxXSArIHR4LCByICogcFtpXVswXSArIHMgKiBwW2ldWzFdICsgdHldKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH07XG5cbiAgdGhpcy5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gR2V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gdGhlIGZvcm1hdCBjb21tb24gdG9cbiAgICAvLyBtYW55IEFQSXMsIGluY2x1ZGluZzpcbiAgICAvLyAtIGtsZC1hZmZpbmVcbiAgICAvL1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgb2JqZWN0IG8sIGhhdmluZyBwcm9wZXJ0aWVzIGEsIGIsIGMsIGQsIGUsIGY6XG4gICAgLy8gICBbIHMgIC1yICB0eCBdICAgWyBvLmEgIG8uYyAgby5lIF1cbiAgICAvLyAgIFsgciAgIHMgIHR5IF0gPSBbIG8uYiAgby5kICBvLmYgXVxuICAgIC8vICAgWyAwICAgMCAgIDEgXSAgIFsgIC0gICAgLSAgICAtICBdXG4gICAgcmV0dXJuIHsgYTogcywgYjogciwgYzogLXIsIGQ6IHMsIGU6IHR4LCBmOiB0eSB9O1xuICB9O1xuXG4gIHRoaXMuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaW4gcmFkc1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHIsIHMpO1xuICB9O1xuXG4gIHRoaXMuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gc2NhbGUgbXVsdGlwbGllclxuICAgIHJldHVybiBNYXRoLnNxcnQociAqIHIgKyBzICogcyk7XG4gIH07XG5cbiAgdGhpcy5nZXRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3R4LCB0eV07XG4gIH07XG5cbiAgdGhpcy5pbnZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBpbnZlcnNlZCB0cmFuc2Zvcm0gaW5zdGFuY2VcbiAgICAvLyBTZWUgbm90ZSAyMDE1LTEwLTI2LTE2LTMwXG4gICAgdmFyIGRldCA9IHMgKiBzICsgciAqIHI7XG4gICAgLy8gVGVzdCBpZiBzaW5ndWxhciB0cmFuc2Zvcm1hdGlvbi4gVGhlc2UgbWlnaHQgb2NjdXIgd2hlbiBhbGwgdGhlIHJhbmdlXG4gICAgLy8gcG9pbnRzIGFyZSB0aGUgc2FtZSwgZm9yY2luZyB0aGUgc2NhbGUgdG8gZHJvcCB0byB6ZXJvLlxuICAgIHZhciBlcHMgPSAwLjAwMDAwMDAxO1xuICAgIGlmIChNYXRoLmFicyhkZXQpIDwgZXBzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Npbmd1bGFyIHRyYW5zZm9ybWF0aW9ucyBjYW5ub3QgYmUgaW52ZXJzZWQuJyk7XG4gICAgfVxuICAgIHZhciBzaGF0ID0gcyAvIGRldDtcbiAgICB2YXIgcmhhdCA9IC1yIC8gZGV0O1xuICAgIHZhciB0eGhhdCA9ICgtcyAqIHR4IC0gciAqIHR5KSAvIGRldDtcbiAgICB2YXIgdHloYXQgPSAoIHIgKiB0eCAtIHMgKiB0eSkgLyBkZXQ7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbiAgfTtcblxuICB0aGlzLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKHMsIHIsIHR4ICsgZHgsIHR5ICsgZHkpO1xuICB9O1xuXG4gIHRoaXMuc2NhbGVCeSA9IGZ1bmN0aW9uIChtdWx0aXBsaWVyLCBwaXZvdCkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgbXVsdGlwbGllclxuICAgIC8vICAgcGl2b3RcbiAgICAvLyAgICAgb3B0aW9uYWwsIGEgW3gsIHldIHBvaW50XG4gICAgdmFyIG0sIHgsIHk7XG4gICAgbSA9IG11bHRpcGxpZXI7IC8vIGFsaWFzXG4gICAgaWYgKHR5cGVvZiBwaXZvdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBpdm90WzBdO1xuICAgICAgeSA9IHBpdm90WzFdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShtICogcywgbSAqIHIsIG0gKiB0eCArICgxLW0pICogeCwgbSAqIHR5ICsgKDEtbSkgKiB5KTtcbiAgfTtcblxuICB0aGlzLnJvdGF0ZUJ5ID0gZnVuY3Rpb24gKHJhZGlhbnMsIHBpdm90KSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICByYWRpYW5zXG4gICAgLy8gICAgIGZyb20gcG9zaXRpdmUgeCB0byBwb3NpdGl2ZSB5IGF4aXNcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICAgIG9wdGlvbmFsLCBhIFt4LCB5XSBwb2ludFxuICAgIHZhciBjbywgc2ksIHgsIHksIHNoYXQsIHJoYXQsIHR4aGF0LCB0eWhhdDtcbiAgICBjbyA9IE1hdGguY29zKHJhZGlhbnMpO1xuICAgIHNpID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgaWYgKHR5cGVvZiBwaXZvdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHBpdm90WzBdO1xuICAgICAgeSA9IHBpdm90WzFdO1xuICAgIH1cbiAgICBzaGF0ID0gcyAqIGNvIC0gciAqIHNpO1xuICAgIHJoYXQgPSBzICogc2kgKyByICogY287XG4gICAgdHhoYXQgPSAodHggLSB4KSAqIGNvIC0gKHR5IC0geSkgKiBzaSArIHg7XG4gICAgdHloYXQgPSAodHggLSB4KSAqIHNpICsgKHR5IC0geSkgKiBjbyArIHk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbiAgfTtcblxuXG4gIHRoaXMubXVsdGlwbHlCeSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAvLyBNdWx0aXBseSB0aGlzIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBBXG4gICAgLy8gZnJvbSB0aGUgcmlnaHQgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtYXRpb24gbWF0cml4IEJcbiAgICAvLyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgQUJcblxuICAgIC8vIEZvciByZWFkaW5nIGFpZDpcbiAgICAvLyBzIC1yIHR4ICB0LnMgLXIgdHhcbiAgICAvLyByICBzIHR5ICogIHIgIHMgdHlcbiAgICAvLyAwICAwICAxICAgIDAgIDAgIDFcbiAgICB2YXIgdCA9IHRyYW5zZm9ybTsgLy8gYWxpYXNcbiAgICB2YXIgc2hhdCA9IHMgKiB0LnMgLSByICogdC5yO1xuICAgIHZhciByaGF0ID0gcyAqIHQuciArIHIgKiB0LnM7XG4gICAgdmFyIHR4aGF0ID0gcyAqIHQudHggLSByICogdC50eSArIHR4O1xuICAgIHZhciB0eWhhdCA9IHIgKiB0LnR4ICsgcyAqIHQudHkgKyB0eTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShzaGF0LCByaGF0LCB0eGhhdCwgdHloYXQpO1xuICB9O1xufTtcblxuVHJhbnNmb3JtLklERU5USVRZID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgdmFyIGksIE4sIEQsIGEwLCBiMCwgYSwgYiwgYywgZCwgYWMsIGFkLCBiYywgYmQsIHNoYXQsIHJoYXQsIHR4LCB0eTtcblxuICBOID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKTtcbiAgYWMgPSBhZCA9IGJjID0gYmQgPSAwO1xuXG4gIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYTAgPSBiMCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYTAgPSBwaXZvdFswXTtcbiAgICBiMCA9IHBpdm90WzFdO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBkb21haW5baV1bMF0gLSBhMDtcbiAgICBiID0gZG9tYWluW2ldWzFdIC0gYjA7XG4gICAgYyA9IHJhbmdlW2ldWzBdIC0gYTA7XG4gICAgZCA9IHJhbmdlW2ldWzFdIC0gYjA7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYWQgKz0gYSAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICBwID0gYWMgKyBiZDtcbiAgcSA9IGFkIC0gYmM7XG5cbiAgRCA9IE1hdGguc3FydChwICogcCArIHEgKiBxKTtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIEQgPT09IDBcbiAgICAvLyA8PT4gcSA9PT0gMCBhbmQgcCA9PT0gMC5cbiAgICAvLyA8PT4gYWQgPT09IGJjIGFuZCBhYyA9PT0gLWJkXG4gICAgLy8gPD0+IGRvbWFpbiBpbiBwaXZvdCBPUiByYW5nZSBpbiBwaXZvdCBPUiB5ZXQgdW5rbm93biBjYXNlc1xuICAgIC8vICAgICB3aGVyZSB0aGUgYW5nbGUgY2Fubm90IGJlIGRldGVybWluZWQuXG4gICAgLy8gRCA9PT0gMCBhbHNvIGlmIE4gPT09IDAuXG4gICAgLy8gQXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybSB0byBiZSB0aGUgYmVzdCBndWVzc1xuICAgIHJldHVybiBUcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH1cblxuICBzaGF0ID0gcCAvIEQ7XG4gIHJoYXQgPSBxIC8gRDtcbiAgdHggPSBhMCAtIGEwICogc2hhdCArIGIwICogcmhhdDtcbiAgdHkgPSBiMCAtIGEwICogcmhhdCAtIGIwICogc2hhdDtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybShzaGF0LCByaGF0LCB0eCwgdHkpO1xufTtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb21haW4sIHJhbmdlLCBwaXZvdCkge1xuICB2YXIgaSwgTiwgRCwgYTAsIGIwLCBhLCBiLCBjLCBkLCBhYywgYmQsIGFhLCBiYiwgc2hhdCwgdHgsIHR5O1xuXG4gIE4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpO1xuICBhYyA9IGJkID0gYWEgPSBiYiA9IDA7XG5cbiAgaWYgKHR5cGVvZiBwaXZvdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhMCA9IGIwID0gMDtcbiAgfSBlbHNlIHtcbiAgICBhMCA9IHBpdm90WzBdO1xuICAgIGIwID0gcGl2b3RbMV07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSAxKSB7XG4gICAgYSA9IGRvbWFpbltpXVswXSAtIGEwO1xuICAgIGIgPSBkb21haW5baV1bMV0gLSBiMDtcbiAgICBjID0gcmFuZ2VbaV1bMF0gLSBhMDtcbiAgICBkID0gcmFuZ2VbaV1bMV0gLSBiMDtcbiAgICBhYyArPSBhICogYztcbiAgICBiZCArPSBiICogZDtcbiAgICBhYSArPSBhICogYTtcbiAgICBiYiArPSBiICogYjtcbiAgfVxuXG4gIEQgPSBhYSArIGJiO1xuXG4gIGlmIChEID09PSAwKSB7XG4gICAgLy8gQWxsIGRvbWFpbiBwb2ludHMgZXF1YWwgdGhlIHBpdm90LlxuICAgIC8vIElkZW50aXR5IHRyYW5zZm9ybSBpcyB0aGVuIG9ubHkgc29sdXRpb24uXG4gICAgLy8gRCA9PT0gMCBhbHNvIGlmIE4gPT09IDAuXG4gICAgLy8gQXNzdW1lIGlkZW50aXR5IHRyYW5zZm9ybSB0byBiZSB0aGUgYmVzdCBndWVzc1xuICAgIHJldHVybiBUcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH1cblxuICAvLyBQcmV2ZW50IG5lZ2F0aXZlIHNjYWxpbmcgYmVjYXVzZSBpdCB3b3VsZCBiZSBzYW1lIGFzIHBvc2l0aXZlIHNjYWxpbmdcbiAgLy8gYW5kIHJvdGF0aW9uID0+IGxpbWl0IHRvIHplcm9cbiAgc2hhdCA9IE1hdGgubWF4KDAsIChhYyArIGJkKSAvIEQpO1xuICB0eCA9ICgxIC0gc2hhdCkgKiBhMDtcbiAgdHkgPSAoMSAtIHNoYXQpICogYjA7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgMCwgdHgsIHR5KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgLy8gRXN0aW1hdGUgb3B0aW1hbCB0cmFuc2Zvcm1hdGlvbiBnaXZlbiB0aGUgZG9tYWluIGFuZCB0aGUgcmFuZ2VcbiAgLy8gc28gdGhhdCB0aGUgcGl2b3QgcG9pbnQgcmVtYWlucyB0aGUgc2FtZS5cbiAgLy9cbiAgLy8gVXNlIGNhc2VzXG4gIC8vICAgLSB0cmFuc2Zvcm0gYW4gaW1hZ2UgdGhhdCBoYXMgb25lIGNvcm5lciBmaXhlZCB3aXRoIGEgcGluLlxuICAvLyAgIC0gYWxsb3cgb25seSBzY2FsZSBhbmQgcm90YXRpb24gYnkgZml4aW5nIHRoZSBtaWRkbGUgb2YgdGhlIG9iamVjdFxuICAvLyAgICAgdG8gdHJhbnNmb3JtLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluLCBhbiBhcnJheSBvZiBbeCwgeV0gcG9pbnRzXG4gIC8vICAgcmFuZ2UsIGFuIGFycmF5IG9mIFt4LCB5XSBwb2ludHNcbiAgLy8gICBwaXZvdCwgb3B0aW9uYWxcbiAgLy8gICAgIHRoZSBwb2ludCBbeCwgeV0gdGhhdCBtdXN0IHJlbWFpbiBjb25zdGFudCBpbiB0aGUgdHJhbmZvcm1hdGlvbi5cbiAgLy8gICAgIERlZmF1bHRzIHRvIG9yaWdvIFswLCAwXVxuICAvL1xuICAvL1xuICB2YXIgWCwgWSwgTiwgcywgciwgdHgsIHR5O1xuXG4gIC8vIE9wdGlvbmFsIHBpdm90XG4gIGlmICh0eXBlb2YgcGl2b3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcGl2b3QgPSBbMCwgMF07XG4gIH1cblxuICAvLyBBbGlhc1xuICBYID0gZG9tYWluO1xuICBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICB2YXIgdiA9IHBpdm90WzBdO1xuICB2YXIgdyA9IHBpdm90WzFdO1xuXG4gIHZhciBpLCBhLCBiLCBjLCBkO1xuICB2YXIgYTIsIGIyO1xuICBhMiA9IGIyID0gMDtcbiAgdmFyIGFjLCBiZCwgYmMsIGFkO1xuICBhYyA9IGJkID0gYmMgPSBhZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdIC0gdjtcbiAgICBiID0gWFtpXVsxXSAtIHc7XG4gICAgYyA9IFlbaV1bMF0gLSB2O1xuICAgIGQgPSBZW2ldWzFdIC0gdztcbiAgICBhMiArPSBhICogYTtcbiAgICBiMiArPSBiICogYjtcbiAgICBhYyArPSBhICogYztcbiAgICBiZCArPSBiICogZDtcbiAgICBiYyArPSBiICogYztcbiAgICBhZCArPSBhICogZDtcbiAgfVxuXG4gIC8vIERlbm9taW5hdG9yID0gZGV0ZXJtaW5hbnQuXG4gIC8vIEl0IGJlY29tZXMgemVybyBpZmYgTiA9IDAgb3IgWFtpXSA9IFt2LCB3XSBmb3IgZXZlcnkgaSBpbiBbMCwgbikuXG4gIC8vIEluIG90aGVyIHdvcmRzLCBpZmYgYWxsIHRoZSBkb21haW4gcG9pbnRzIGFyZSB1bmRlciB0aGUgZml4ZWQgcG9pbnQgb3JcbiAgLy8gdGhlcmUgaXMgbm8gZG9tYWluIHBvaW50cy5cbiAgdmFyIGRlbiA9IGEyICsgYjI7XG5cbiAgdmFyIGVwcyA9IDAuMDAwMDAwMDE7XG4gIGlmIChNYXRoLmFicyhkZW4pIDwgZXBzKSB7XG4gICAgLy8gVGhlIGRvbWFpbiBwb2ludHMgYXJlIHVuZGVyIHRoZSBwaXZvdCBvciB0aGVyZSBpcyBubyBkb21haW4gcG9pbnRzLlxuICAgIC8vIFdlIGFzc3VtZSBpZGVudGl0eSB0cmFuc2Zvcm0gYmUgdGhlIHNpbXBsZXN0IGd1ZXNzLiBJdCBrZWVwc1xuICAgIC8vIHRoZSBkb21haW4gcG9pbnRzIHVuZGVyIHRoZSBwaXZvdCBpZiB0aGVyZSBpcyBzb21lLlxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIDAsIDApO1xuICB9XG5cbiAgLy8gRXN0aW1hdG9yc1xuICBzID0gKGFjICsgYmQpIC8gZGVuO1xuICByID0gKC1iYyArIGFkKSAvIGRlbjtcbiAgdHggPSAgdyAqIHIgLSB2ICogcyArIHY7XG4gIHR5ID0gLXYgKiByIC0gdyAqIHMgKyB3O1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHMsIHIsIHR4LCB0eSk7XG59O1xuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgdmFyIGksIE4sIGExLCBiMSwgYzEsIGQxLCB0eGhhdCwgdHloYXQ7XG5cbiAgTiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCk7XG4gIGExID0gYjEgPSBjMSA9IGQxID0gMDtcblxuICBpZiAoTiA8IDEpIHtcbiAgICAvLyBBc3N1bWUgaWRlbnRpdHkgdHJhbnNmb3JtIGJlIHRoZSBiZXN0IGd1ZXNzXG4gICAgcmV0dXJuIFRyYW5zZm9ybS5JREVOVElUWTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpICs9IDEpIHtcbiAgICBhMSArPSBkb21haW5baV1bMF07XG4gICAgYjEgKz0gZG9tYWluW2ldWzFdO1xuICAgIGMxICs9IHJhbmdlW2ldWzBdO1xuICAgIGQxICs9IHJhbmdlW2ldWzFdO1xuICB9XG5cbiAgdHhoYXQgPSAoYzEgLSBhMSkgLyBOO1xuICB0eWhhdCA9IChkMSAtIGIxKSAvIE47XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgdHhoYXQsIHR5aGF0KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIFt4LCB5XSAyRCBhcnJheXNcblxuICAvLyBBbGlhc1xuICB2YXIgWCA9IGRvbWFpbjtcbiAgdmFyIFkgPSByYW5nZTtcblxuICAvLyBBbGxvdyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aCBidXRcbiAgLy8gaWdub3JlIHRoZSBleHRyYSBwb2ludHMuXG4gIHZhciBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICB2YXIgaSwgYSwgYiwgYywgZCwgYTEsIGIxLCBjMSwgZDEsIGFjLCBhZCwgYmMsIGJkO1xuICBhMSA9IGIxID0gYzEgPSBkMSA9IGFjID0gYWQgPSBiYyA9IGJkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdO1xuICAgIGIgPSBYW2ldWzFdO1xuICAgIGMgPSBZW2ldWzBdO1xuICAgIGQgPSBZW2ldWzFdO1xuICAgIGExICs9IGE7XG4gICAgYjEgKz0gYjtcbiAgICBjMSArPSBjO1xuICAgIGQxICs9IGQ7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYWQgKz0gYSAqIGQ7XG4gICAgYmMgKz0gYiAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvci5cbiAgdmFyIHYgPSBOICogKGFkIC0gYmMpIC0gYTEgKiBkMSArIGIxICogYzE7XG4gIHZhciB3ID0gTiAqIChhYyArIGJkKSAtIGExICogYzEgLSBiMSAqIGQxO1xuICB2YXIgRCA9IE1hdGguc3FydCh2ICogdiArIHcgKiB3KTtcblxuICBpZiAoRCA9PT0gMCkge1xuICAgIC8vIE4gPT09IDAgPT4gRCA9PT0gMFxuICAgIGlmIChOID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAwLCAwKTtcbiAgICB9IC8vIGVsc2VcbiAgICAvLyBEID09PSAwIDw9PiB1bmRlY2lkYWJsZVxuICAgIC8vIFdlIGd1ZXNzIHRoZSB0cmFuc2xhdGlvbiB0byB0aGUgbWVhbiBvZiB0aGUgcmFuZ2UgdG8gYmUgdGhlIGJlc3QgZ3Vlc3MuXG4gICAgLy8gSGVyZSBhLCBiIHJlcHJlc2VudHMgdGhlIG1lYW4gb2YgZG9tYWluIHBvaW50cy5cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAoYzEgLSBhMSkgLyBOLCAoZDEgLSBiMSkgLyBOKTtcbiAgfVxuXG4gIC8vIEVzdGltYXRvcnNcbiAgdmFyIHNoYXQgPSB3IC8gRDtcbiAgdmFyIHJoYXQgPSB2IC8gRDtcbiAgdmFyIHR4aGF0ID0gKC1hMSAqIHNoYXQgKyBiMSAqIHJoYXQgKyBjMSkgLyBOO1xuICB2YXIgdHloYXQgPSAoLWExICogcmhhdCAtIGIxICogc2hhdCArIGQxKSAvIE47XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgcmhhdCwgdHhoYXQsIHR5aGF0KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIFt4LCB5XSAyRCBhcnJheXNcblxuICAvLyBBbGlhc1xuICB2YXIgWCA9IGRvbWFpbjtcbiAgdmFyIFkgPSByYW5nZTtcblxuICAvLyBBbGxvdyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aCBidXRcbiAgLy8gaWdub3JlIHRoZSBleHRyYSBwb2ludHMuXG4gIHZhciBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICB2YXIgaSwgYSwgYiwgYywgZCwgYTEsIGIxLCBjMSwgZDEsIGEyLCBiMiwgYWMsIGJkO1xuICBhMSA9IGIxID0gYzEgPSBkMSA9IGEyID0gYjIgPSBhYyA9IGJkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gMSkge1xuICAgIGEgPSBYW2ldWzBdO1xuICAgIGIgPSBYW2ldWzFdO1xuICAgIGMgPSBZW2ldWzBdO1xuICAgIGQgPSBZW2ldWzFdO1xuICAgIGExICs9IGE7XG4gICAgYjEgKz0gYjtcbiAgICBjMSArPSBjO1xuICAgIGQxICs9IGQ7XG4gICAgYTIgKz0gYSAqIGE7XG4gICAgYjIgKz0gYiAqIGI7XG4gICAgYWMgKz0gYSAqIGM7XG4gICAgYmQgKz0gYiAqIGQ7XG4gIH1cblxuICAvLyBEZW5vbWluYXRvci5cbiAgdmFyIE4yID0gTiAqIE47XG4gIHZhciBhMTIgPSBhMSAqIGExO1xuICB2YXIgYjEyID0gYjEgKiBiMTtcbiAgdmFyIHAgPSBhMiArIGIyO1xuICB2YXIgcSA9IGFjICsgYmQ7XG4gIHZhciBEID0gTjIgKiBwIC0gTiAqIChhMTIgKyBiMTIpO1xuXG4gIGlmIChEID09PSAwKSB7XG4gICAgLy8gTiA9PT0gMCA9PiBEID09PSAwXG4gICAgaWYgKE4gPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKDEsIDAsIDAsIDApO1xuICAgIH0gLy8gZWxzZVxuICAgIC8vIEQgPT09IDAgPD0+IGFsbCB0aGUgZG9tYWluIHBvaW50cyBhcmUgdGhlIHNhbWVcbiAgICAvLyBXZSBndWVzcyB0aGUgdHJhbnNsYXRpb24gdG8gdGhlIG1lYW4gb2YgdGhlIHJhbmdlIHRvIGJlIHRoZSBiZXN0IGd1ZXNzLlxuICAgIC8vIEhlcmUgYSwgYiByZXByZXNlbnRzIHRoZSBtZWFuIG9mIGRvbWFpbiBwb2ludHMuXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgKGMxIC8gTikgLSBhLCAoZDEgLyBOKSAtIGIpO1xuICB9XG5cbiAgLy8gRXN0aW1hdG9yc1xuICB2YXIgc2hhdCA9IChOMiAqIHEgLSBOICogKGExICogYzEgKyBiMSAqIGQxKSkgLyBEO1xuICB2YXIgdHhoYXQgPSAoLU4gKiBhMSAqIHEgKyBOICogYzEgKiBwIC0gYjEyICogYzEgKyBhMSAqIGIxICogZDEpIC8gRDtcbiAgdmFyIHR5aGF0ID0gKC1OICogYjEgKiBxICsgTiAqIGQxICogcCAtIGExMiAqIGQxICsgYTEgKiBiMSAqIGMxKSAvIEQ7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oc2hhdCwgMCwgdHhoYXQsIHR5aGF0KTtcbn07XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgZG9tYWluXG4gIC8vICAgICBhcnJheSBvZiBbeCwgeV0gMkQgYXJyYXlzXG4gIC8vICAgcmFuZ2VcbiAgLy8gICAgIGFycmF5IG9mIFt4LCB5XSAyRCBhcnJheXNcbiAgdmFyIFgsIFksIE4sIHMsIHIsIHR4LCB0eTtcblxuICAvLyBBbGlhc1xuICBYID0gZG9tYWluO1xuICBZID0gcmFuZ2U7XG5cbiAgLy8gQWxsb3cgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGggYnV0XG4gIC8vIGlnbm9yZSB0aGUgZXh0cmEgcG9pbnRzLlxuICBOID0gTWF0aC5taW4oWC5sZW5ndGgsIFkubGVuZ3RoKTtcblxuICAvLyBJZiBsZW5ndGggaXMgemVybywgbm8gZXN0aW1hdGlvbiBjYW4gYmUgZG9uZS4gV2UgY2hvb3NlIHRoZSBpbmRlbnRpdHlcbiAgLy8gdHJhbnNmb3JtYXRpb24gYmUgdGhlIGJlc3QgcXVlc3MuXG4gIGlmIChOID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCwgMCk7XG4gIH0gLy8gZWxzZVxuXG4gIHZhciBpLCBhLCBiLCBjLCBkO1xuICB2YXIgYTEgPSAwO1xuICB2YXIgYjEgPSAwO1xuICB2YXIgYzEgPSAwO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgYTIgPSAwO1xuICB2YXIgYjIgPSAwO1xuICB2YXIgYWQgPSAwO1xuICB2YXIgYmMgPSAwO1xuICB2YXIgYWMgPSAwO1xuICB2YXIgYmQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgTjsgaSArPSAxKSB7XG4gICAgYSA9IFhbaV1bMF07XG4gICAgYiA9IFhbaV1bMV07XG4gICAgYyA9IFlbaV1bMF07XG4gICAgZCA9IFlbaV1bMV07XG4gICAgYTEgKz0gYTtcbiAgICBiMSArPSBiO1xuICAgIGMxICs9IGM7XG4gICAgZDEgKz0gZDtcbiAgICBhMiArPSBhICogYTtcbiAgICBiMiArPSBiICogYjtcbiAgICBhZCArPSBhICogZDtcbiAgICBiYyArPSBiICogYztcbiAgICBhYyArPSBhICogYztcbiAgICBiZCArPSBiICogZDtcbiAgfVxuXG4gIC8vIERlbm9taW5hdG9yLlxuICAvLyBJdCBpcyB6ZXJvIGlmZiBYW2ldID0gWFtqXSBmb3IgZXZlcnkgaSBhbmQgaiBpbiBbMCwgbikuXG4gIC8vIEluIG90aGVyIHdvcmRzLCBpZmYgYWxsIHRoZSBkb21haW4gcG9pbnRzIGFyZSB0aGUgc2FtZSBvciB0aGVyZSBpcyBvbmx5IG9uZSBkb21haW4gcG9pbnQuXG4gIHZhciBkZW4gPSBOICogYTIgKyBOICogYjIgLSBhMSAqIGExIC0gYjEgKiBiMTtcblxuICB2YXIgZXBzID0gMC4wMDAwMDAwMTtcbiAgaWYgKC1lcHMgPCBkZW4gJiYgZGVuIDwgZXBzKSB7XG4gICAgLy8gVGhlIGRvbWFpbiBwb2ludHMgYXJlIHRoZSBzYW1lLlxuICAgIC8vIFdlIGd1ZXNzIHRoZSB0cmFuc2xhdGlvbiB0byB0aGUgbWVhbiBvZiB0aGUgcmFuZ2UgdG8gYmUgdGhlIGJlc3QgZ3Vlc3MuXG4gICAgLy8gSGVyZSBhLCBiIHJlcHJlc2VudHMgdGhlIG1lYW4gb2YgZG9tYWluIHBvaW50cy5cbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybSgxLCAwLCAoYzEgLyBOKSAtIGEsIChkMSAvIE4pIC0gYik7XG4gIH1cblxuICAvLyBFc3RpbWF0b3JzXG4gIHMgPSAoTiAqIChhYyArIGJkKSAtIGExICogYzEgLSBiMSAqIGQxKSAvIGRlbjtcbiAgciA9IChOICogKGFkIC0gYmMpICsgYjEgKiBjMSAtIGExICogZDEpIC8gZGVuO1xuICB0eCA9ICgtYTEgKiAoYWMgKyBiZCkgKyBiMSAqIChhZCAtIGJjKSArIGEyICogYzEgKyBiMiAqIGMxKSAvIGRlbjtcbiAgdHkgPSAoLWIxICogKGFjICsgYmQpIC0gYTEgKiAoYWQgLSBiYykgKyBhMiAqIGQxICsgYjIgKiBkMSkgLyBkZW47XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ocywgciwgdHgsIHR5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICcxLjAuMSc7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXFJZFxuXG5mdW5jdGlvbiBTZXFJZChpbml0aWFsKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXFJZCkpIHtcbiAgICByZXR1cm4gbmV3IFNlcUlkKGluaXRpYWwpXG4gIH1cbiAgaWYgKGluaXRpYWwgPT0gbnVsbCkge1xuICAgIGluaXRpYWwgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBNYXRoLnBvdygyLCAzMilcbiAgfVxuICB0aGlzLl9pZCA9IGluaXRpYWwgfCAwXG59XG5TZXFJZC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faWQgPSAodGhpcy5faWQgKyAxKSB8IDBcbiAgcmV0dXJuIHRoaXMuX2lkXG59XG4iLCIvKlxuXG5WaWV3XG5cbiovXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VOb2RlID0gcmVxdWlyZSgnLi9TcGFjZU5vZGUnKTtcbnZhciBTcGFjZVBsYW5lID0gcmVxdWlyZSgnLi9TcGFjZVBsYW5lJyk7XG52YXIgU3BhY2VUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vU3BhY2VUcmFuc2Zvcm1lcicpO1xudmFyIFNwYWNlUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9TcGFjZVJlY3RhbmdsZScpO1xudmFyIFNwYWNlVGFhID0gcmVxdWlyZSgnLi9TcGFjZVRhYScpO1xudmFyIFNwYWNlSFRNTCA9IHJlcXVpcmUoJy4vU3BhY2VIVE1MJyk7XG52YXIgU3BhY2UgPSByZXF1aXJlKCcuL1NwYWNlJyk7XG52YXIgbW92ZSA9IHJlcXVpcmUoJ21vdmVqcycpO1xuXG4vLyBEaXNhYmxlIGFuaW1hdGlvbnMgYnkgZGVmYXVsdC5cbm1vdmUuZGVmYXVsdHMgPSB7IGR1cmF0aW9uOiAwIH07XG5cbnZhciBIVE1MU3BhY2VWaWV3ID0gZnVuY3Rpb24gKHNwYWNlLCBodG1sQ29udGFpbmVyKSB7XG4gIC8vIFRlc3QgaWYgdmFsaWQgc3BhY2VcbiAgaWYgKCEoc3BhY2UgaW5zdGFuY2VvZiBTcGFjZSkpIHtcbiAgICB0aHJvdyAnUGFyZW50IG9mIGEgVmlldyBtdXN0IGJlIGEgU3BhY2UuJztcbiAgfVxuICAvLyBUZXN0IGlmIHZhbGlkIGRvbSBlbGVtZW50XG4gIGlmICghKCd0YWdOYW1lJyBpbiBodG1sQ29udGFpbmVyKSkge1xuICAgIHRocm93ICdDb250YWluZXIgc2hvdWxkIGJlIGEgRE9NIEVsZW1lbnQnO1xuICB9XG5cbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VOb2RlKHRoaXMpO1xuICBTcGFjZVBsYW5lKHRoaXMpO1xuICBTcGFjZVRyYW5zZm9ybWVyKHRoaXMpO1xuICBTcGFjZVJlY3RhbmdsZSh0aGlzKTtcbiAgdmFyIHRoaXMyID0gdGhpcztcblxuICB0aGlzLl9lbCA9IGh0bWxDb250YWluZXI7XG5cbiAgLy8gVHdvIG1hcHBpbmdzIGZyb20gc3BhY2UgdGFhIGlkczpcbiAgLy8gMS4gdG8gSFRNTCBlbGVtZW50cyBvZiB0aGUgc3BhY2Ugbm9kZXMuXG4gIC8vIDIuIHRvIFNwYWNlTm9kZSBpbnN0YW5jZXNcbiAgLy8gRGV2IGRlY2lzaW9uOlxuICAvLyAgIEZvciBkYXRhIHN0cnVjdHVyZSwgZGljdCBvdmVyIGxpc3QgYmVjYXVzZSBrZXkgc2VhcmNoIHRpbWUgY29tcGxleGl0eS5cbiAgdGhpcy5fZWxlbWVudHMgPSB7fTtcbiAgdGhpcy5fbm9kZXMgPSB7fTtcblxuICAoZnVuY3Rpb24gaW5pdFNpemUoKSB7XG4gICAgdmFyIHcgPSB0aGlzMi5fZWwuY2xpZW50V2lkdGg7XG4gICAgdmFyIGggPSB0aGlzMi5fZWwuY2xpZW50SGVpZ2h0O1xuICAgIHRoaXMyLnJlc2l6ZShbdywgaF0pO1xuICB9KCkpO1xuXG4gIHZhciBfaGFzTm9kZUlkID0gZnVuY3Rpb24gKG5vZGVpZCkge1xuICAgIHJldHVybiB0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkobm9kZWlkKTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtTm9kZSA9IGZ1bmN0aW9uIChodG1sRWxlbWVudCwgc3BhY2VOb2RlKSB7XG4gICAgLy8gVHJhbnNmb3JtIGVsZW1lbnRzIGJlY2F1c2UgdGhlIHZpZXcgb3JpZW50YXRpb24uXG4gICAgLy8gU2VlIDIwMTYtMDMtMDUtMDkgZm9yIG1hdGguXG4gICAgdmFyIG5vZGVfZ2xvYmFsX1QgPSBzcGFjZU5vZGUuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gICAgdmFyIFQgPSB0aGlzMi5fVC5pbnZlcnNlKCkubXVsdGlwbHlCeShub2RlX2dsb2JhbF9UKTtcbiAgICAvLyBDdXJyZW50IG1vdmUuanMgZG9lcyBub3QgcHJldmVudCBzY2llbnRpZmljIG5vdGF0aW9uIHJlYWNoaW5nIENTU1xuICAgIC8vIHdoaWNoIGxlYWRzIHRvIHByb2JsZW1zIHdpdGggU2FmYXJpIGFuZCBPcGVyYS4gVGhlcmVmb3JlIHdlIG11c3RcbiAgICAvLyBwcmV2ZW50IHRoZSBub3RhdGlvbiBoZXJlLlxuICAgIC8vIE9mIGNvdXJzZSB0aGlzIHdpbGwgY2F1c2UgZXJyb3IgaW4gdGhlIHByZXNlbnRhdGlvbi5cbiAgICAvLyBIb3dldmVyIHRoZSBlcnJvciBpcyBvbmx5IGluIHRoZSBwcmVzZW50YXRpb24gYW5kIHRodXMgbm90IGEgcHJvYmxlbS5cbiAgICB2YXIgcHJlYyA9IDg7XG4gICAgdmFyIHMgPSBULnMudG9GaXhlZChwcmVjKTtcbiAgICB2YXIgciA9IFQuci50b0ZpeGVkKHByZWMpO1xuICAgIHZhciB0eCA9IFQudHgudG9GaXhlZChwcmVjKTtcbiAgICB2YXIgdHkgPSBULnR5LnRvRml4ZWQocHJlYyk7XG4gICAgbW92ZShodG1sRWxlbWVudCkubWF0cml4KHMsIHIsLXIsIHMsIHR4LCB0eSkuZW5kKCk7XG4gIH07XG5cbiAgdmFyIGdldFZpZXdTcGVjaWZpY0lkID0gZnVuY3Rpb24gKHNwYWNlTm9kZUlkKSB7XG4gICAgLy8gRWFjaCByZW5kZXJlZCBlbGVtZW50IGhhcyBvd24gSUQuIFRoZSBJRCBkaWZmZXJzIGZyb21cbiAgICAvLyB0aGUgaWQgb2Ygc3BhY2Ugbm9kZXMgYmVjYXVzZSBhIHNwYWNlIG5vZGUgY2FuIGJlY29tZVxuICAgIC8vIHZpc3VhbGl6ZWQgdGhyb3VnaCBtdWx0aXBsZSB2aWV3cy5cbiAgICByZXR1cm4gdGhpczIuaWQgKyAnLScgKyBzcGFjZU5vZGVJZDtcbiAgfTtcblxuXG4gIC8vIExpc3RlbiB0aGUgc3BhY2UgZm9yIG5ldyBvciByZW1vdmVkIG5vZGVzIG9yIHRyYW5zZm9ybWF0aW9uc1xuXG4gIHZhciB0cmFuc2Zvcm1lZEhhbmRsZXIgPSBmdW5jdGlvbiAoc3BhY2VOb2RlKSB7XG4gICAgLy8gVXBkYXRlIGNzcyB0cmFuc2Zvcm1hdGlvbi5cbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgY2hpbGRyZW4sIHRoZXkgbXVzdCBhbHNvIGJlIHRyYW5zZm9ybWVkXG4gICAgLy8gYmVjYXVzZSB0aGUgY2hpbGRyZW4gZG8gbm90IGVtaXQgdHJhbnNmb3JtZWQgYnkgdGhlbXNlbHZlcy5cbiAgICB2YXIgbm9kZXMsIGksIG5vZGUsIGVsO1xuICAgIG5vZGVzID0gc3BhY2VOb2RlLmdldERlc2NlbmRhbnRzKCk7XG4gICAgbm9kZXMucHVzaChzcGFjZU5vZGUpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoX2hhc05vZGVJZChub2RlLmlkKSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNwYWNlVGFhKSB7XG4gICAgICAgICAgZWwgPSB0aGlzMi5fZWxlbWVudHNbbm9kZS5pZF07XG4gICAgICAgICAgdHJhbnNmb3JtTm9kZShlbCwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNwYWNlSFRNTCkge1xuICAgICAgICAgIGVsID0gdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdO1xuICAgICAgICAgIHRyYW5zZm9ybU5vZGUoZWwsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2U6IG5vIHRyYW5zZm9ybWFibGUgcmVwcmVzZW50YXRpb24gZm9yIFZpZXdzLlxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcmVzaXplZEhhbmRsZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBlbCwgd2g7XG4gICAgaWYgKF9oYXNOb2RlSWQobm9kZS5pZCkpIHtcbiAgICAgIC8vIFNhZmVndWFyZDogaWYgaXMgYSBTcGFjZVJlY3RhbmdsZVxuICAgICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkoJ3Jlc2l6ZScpKSB7XG4gICAgICAgIHdoID0gbm9kZS5nZXRTaXplKCk7XG4gICAgICAgIGVsID0gdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdO1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHdoWzBdICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gd2hbMV0gKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY29udGVudEFkZGVkSGFuZGxlciA9IGZ1bmN0aW9uIChzcGFjZU5vZGUsIG5ld1BhcmVudCwgb2xkUGFyZW50KSB7XG4gICAgLy8gUGFyYW1ldGVyczpcbiAgICAvLyAgIHNwYWNlTm9kZTogYSBTcGFjZU5vZGUgaS5lLiB0aGUgY29udGVudCB1bml0IHRoYXQgd2FzIGFkZGVkLlxuICAgIC8vICAgbmV3UGFyZW50OiBvcHRpb25hbC4gVGhlIG5ldyBwYXJlbnQgb2YgdGhlIFNwYWNlTm9kZVxuICAgIC8vICAgICBOb3QgdXNlZCBmb3IgYW55dGhpbmcgZm9yIG5vdyBidXQgcHJvYmFibHkgaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyAgIG9sZFBhcmVudDogb3B0aW9uYWwuIFRoZSBvbGQgcGFyZW50IG9mIHRoZSBTcGFjZU5vZGUuXG4gICAgLy8gICAgIE5vdCB1c2VkIGZvciBhbnl0aGluZyBmb3Igbm93IGJ1dCBwcm9iYWJseSBpbiB0aGUgZnV0dXJlLlxuICAgIGlmICh0eXBlb2Ygb2xkUGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBvbGRQYXJlbnQgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVvZiBuZXdQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG5ld1BhcmVudCA9IG51bGw7IH1cblxuICAgIHZhciBub2RlLCBlbCwgd2g7XG5cbiAgICAvLyBTcGFjZVZpZXcsIFNwYWNlVGFhIC4uLlxuICAgIG5vZGUgPSBzcGFjZU5vZGU7XG5cbiAgICAvLyBFbnN1cmUgdGhlIHNwYWNlTm9kZSBpcyBpbiBzYW1lIHNwYWNlLiBPdGhlcndpc2UsXG4gICAgLy8gaWYgdmlldydzIHNwYWNlIGhhcyBiZWVuIGp1c3QgY2hhbmdlZCwgYSB3YWl0aW5nXG4gICAgLy8gY29udGVudEFkZGVkIGV2ZW50IGNvdWxkIGFkZCBzcGFjZU5vZGUgZnJvbSB0aGUgb2xkIHNwYWNlLlxuICAgIGlmIChzcGFjZU5vZGUuZ2V0Um9vdFBhcmVudCgpICE9PSB0aGlzMi5nZXRSb290UGFyZW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoX2hhc05vZGVJZChub2RlLmlkKSkge1xuICAgICAgLy8gQ29udGVudCBpcyBhbHJlYWR5IGRyYXduLlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNwYWNlVGFhKSB7XG4gICAgICAgIGVsID0gbmV3IEltYWdlKDI1NiwgMjU2KTtcbiAgICAgICAgZWwuc3JjID0gbm9kZS50YWEuaW1hZ2Uuc3JjO1xuICAgICAgICBlbC5pZCA9IGdldFZpZXdTcGVjaWZpY0lkKG5vZGUuaWQpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSAndGFhc3BhY2UtdGFhJztcbiAgICAgICAgLy8gU2hvdyB0byBjbGllbnRcbiAgICAgICAgdGhpczIuX2VsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgLy8gTWFrZSByZWZlcmVuY2FibGVcbiAgICAgICAgdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdID0gZWw7XG4gICAgICAgIHRoaXMyLl9ub2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIC8vIE1ha2UgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgdHJhbnNmb3JtTm9kZShlbCwgbm9kZSk7XG4gICAgICAgIC8vIExpc3RlbiB0byBmdXJ0aGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBub2RlLm9uKCd0cmFuc2Zvcm1lZCcsIHRyYW5zZm9ybWVkSGFuZGxlcik7XG4gICAgICAgIG5vZGUub24oJ3Jlc2l6ZWQnLCByZXNpemVkSGFuZGxlcik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcGFjZUhUTUwpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRhaW5lciBkaXYuXG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IG5vZGUuaHRtbDtcbiAgICAgICAgZWwuaWQgPSBnZXRWaWV3U3BlY2lmaWNJZChub2RlLmlkKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gJ3RhYXNwYWNlLWh0bWwnO1xuICAgICAgICAvLyBSZXNpemUsIGFuZCBsZXQgdGFhc3BhY2Ugc3R5bGVzIGRvIHRoZSByZXN0LlxuICAgICAgICB3aCA9IG5vZGUuZ2V0U2l6ZSgpO1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHdoWzBdICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gd2hbMV0gKyAncHgnO1xuICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgdGhpczIuX2VsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgLy8gTWFrZSByZWZlcmVuY2FibGVcbiAgICAgICAgdGhpczIuX2VsZW1lbnRzW25vZGUuaWRdID0gZWw7XG4gICAgICAgIHRoaXMyLl9ub2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIC8vIE1ha2UgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgdHJhbnNmb3JtTm9kZShlbCwgbm9kZSk7XG4gICAgICAgIC8vIExpc3RlbiB0byBmdXJ0aGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBub2RlLm9uKCd0cmFuc2Zvcm1lZCcsIHRyYW5zZm9ybWVkSGFuZGxlcik7XG4gICAgICAgIG5vZGUub24oJ3Jlc2l6ZWQnLCByZXNpemVkSGFuZGxlcik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MU3BhY2VWaWV3KSB7XG4gICAgICAgIC8vIE5vIHJlcHJlc2VudGF0aW9uIGZvciB2aWV3cy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gU3BhY2VOb2RlIHN1YnR5cGU7IGNhbm5vdCByZXByZXNlbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbnRlbnRSZW1vdmVkSGFuZGxlciA9IGZ1bmN0aW9uIChzcGFjZU5vZGUsIG9sZFBhcmVudCwgbmV3UGFyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbGRQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG9sZFBhcmVudCA9IG51bGw7IH1cbiAgICBpZiAodHlwZW9mIG5ld1BhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgbmV3UGFyZW50ID0gbnVsbDsgfVxuXG4gICAgdmFyIHNhbWVSb290LCBlbCwgbm9kZTtcblxuICAgIG5vZGUgPSBzcGFjZU5vZGU7IC8vIEFsaWFzXG5cbiAgICAvLyBEZWNpZGUgc2FtZVJvb3RcbiAgICBpZiAob2xkUGFyZW50ID09PSBudWxsIHx8IG5ld1BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgc2FtZVJvb3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FtZVJvb3QgPSBvbGRQYXJlbnQuZ2V0Um9vdFBhcmVudCgpID09PSBuZXdQYXJlbnQuZ2V0Um9vdFBhcmVudCgpO1xuICAgIH1cblxuICAgIGlmIChzYW1lUm9vdCkge1xuICAgICAgLy8gTm8gcmVhc29uIHRvIHJlbW92ZSBhbmQgdGhlbiBhZGQgYWdhaW4uXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBwYXJlbnQgaW4gZGlmZmVyZW50IHNwYWNlLCBzbyBub3QgZGlzcGxheWVkIGluIHRoaXMgdmlldyBhbnltb3JlLlxuICAgICAgaWYgKF9oYXNOb2RlSWQobm9kZS5pZCkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIEhUTUwgZWxlbWVudFxuICAgICAgICBlbCA9IHRoaXMyLl9lbGVtZW50c1tub2RlLmlkXTtcbiAgICAgICAgdGhpczIuX2VsLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gbWVtb3J5LlxuICAgICAgICAvLyBKUyBmZWF0dXJlIG9mIGRlbGV0ZTogZG9lcyBub3QgdGhyb3cgaWYga2V5IGRvZXMgbm90IGV4aXN0XG4gICAgICAgIGRlbGV0ZSB0aGlzMi5fZWxlbWVudHNbbm9kZS5pZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzMi5fbm9kZXNbbm9kZS5pZF07XG4gICAgICAgIC8vIFJlbW92ZSBoYW5kbGVycy5cbiAgICAgICAgbm9kZS5vZmYoJ3RyYW5zZm9ybWVkJywgdHJhbnNmb3JtZWRIYW5kbGVyKTtcbiAgICAgICAgbm9kZS5vZmYoJ3Jlc2l6ZWQnLCByZXNpemVkSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gVmlldyBhZGRlZCB0byBuZXcgcGFyZW50LlxuICB0aGlzLm9uKCdhZGRlZCcsIGZ1bmN0aW9uIChzZWxmLCBuZXdTcGFjZSwgb2xkU3BhY2UpIHtcbiAgICB2YXIgZGVzLCBpO1xuXG4gICAgaWYgKG9sZFNwYWNlID09PSBuZXdTcGFjZSkge1xuICAgICAgLy8gQWxyZWFkeSBzZXQgdXAuIERvIG5vdGhpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIG5vZGVzIGZyb20gdGhlIG5ldyBzcGFjZS5cbiAgICBkZXMgPSBuZXdTcGFjZS5nZXREZXNjZW5kYW50cygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnRlbnRBZGRlZEhhbmRsZXIoZGVzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0byBsaXN0ZW4gZm9yIGNoYW5nZXMuXG4gICAgbmV3U3BhY2Uub24oJ2NvbnRlbnRBZGRlZCcsIGNvbnRlbnRBZGRlZEhhbmRsZXIpO1xuICAgIG5ld1NwYWNlLm9uKCdjb250ZW50UmVtb3ZlZCcsIGNvbnRlbnRSZW1vdmVkSGFuZGxlcik7XG4gIH0pO1xuXG4gIC8vIFZpZXcgcmVtb3ZlZCBmcm9tIHBhcmVudC5cbiAgdGhpcy5vbigncmVtb3ZlZCcsIGZ1bmN0aW9uIChzZWxmLCBvbGRTcGFjZSwgbmV3U3BhY2UpIHtcbiAgICB2YXIgZGVzLCBpO1xuXG4gICAgaWYgKG5ld1NwYWNlID09PSBvbGRTcGFjZSkge1xuICAgICAgLy8gQWxyZWFkeSBzZXQgdXAuIERvIG5vdGhpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIGNoYW5nZXMuXG4gICAgb2xkU3BhY2Uub2ZmKCdjb250ZW50QWRkZWQnLCBjb250ZW50QWRkZWRIYW5kbGVyKTtcbiAgICBvbGRTcGFjZS5vZmYoJ2NvbnRlbnRSZW1vdmVkJywgY29udGVudFJlbW92ZWRIYW5kbGVyKTtcblxuICAgIC8vIFJlbW92ZSBhbGwgbm9kZXMgZnJvbSBvbGQgc3BhY2UuXG4gICAgZGVzID0gb2xkU3BhY2UuZ2V0RGVzY2VuZGFudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb250ZW50UmVtb3ZlZEhhbmRsZXIoZGVzW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2aWV3IGlzIHRyYW5zZm9ybWVkLCB3ZSBvZiBjb3Vyc2UgbmVlZCB0byByZXRyYW5zZm9ybSBldmVyeXRoaW5nLlxuICB0aGlzLm9uKCd0cmFuc2Zvcm1lZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWQsIGVsZW1lbnQsIG5vZGU7XG4gICAgZm9yIChpZCBpbiB0aGlzMi5fZWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzMi5fZWxlbWVudHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGVsZW1lbnQgID0gdGhpczIuX2VsZW1lbnRzW2lkXTtcbiAgICAgICAgbm9kZSA9IHRoaXMyLl9ub2Rlc1tpZF07XG4gICAgICAgIHRyYW5zZm9ybU5vZGUoZWxlbWVudCwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmdldEVsZW1lbnRCeVNwYWNlTm9kZSA9IGZ1bmN0aW9uIChzcGFjZU5vZGUpIHtcbiAgICAvLyBHZXQgSFRNTCBlbGVtZW50IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGFjZSB0YWEuXG4gICAgLy8gUmV0dXJuIG51bGwgaWYgbm90IGZvdW5kLlxuICAgIGlmIChfaGFzTm9kZUlkKHNwYWNlTm9kZS5pZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tzcGFjZU5vZGUuaWRdO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLmdldFNwYWNlTm9kZUJ5RWxlbWVudElkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gR2V0IHNwYWNlIHRhYSBieSBIVE1MIGVsZW1lbnQgaWRcbiAgICAvLyBSZXR1cm4gbnVsbCBpZiBubyBzcGFjZSB0YWEgZm9yIHN1Y2ggaWQuXG4gICAgdmFyIGkgPSBpZC5zcGxpdCgnLScpO1xuICAgIHZhciBzcGFjZVZpZXdJZCA9IGlbMF07XG4gICAgdmFyIHNwYWNlTm9kZUlkID0gaVsxXTtcbiAgICBpZiAodGhpcy5pZCA9PT0gc3BhY2VWaWV3SWQpIHtcbiAgICAgIGlmIChfaGFzTm9kZUlkKHNwYWNlTm9kZUlkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNbc3BhY2VOb2RlSWRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB0aGlzLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiB0aGUgY29udGFpbmVyIEhUTUwgZWxlbWVudC5cbiAgICByZXR1cm4gdGhpcy5fZWw7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIHNldFBhcmVudCBzbyB0aGF0IG9ubHkgYSBTcGFjZVxuICAvLyBpcyBhbGxvd2VkIHRvIGJlY29tZSB0aGUgcGFyZW50LlxuICB2YXIgc3VwZXJTZXRQYXJlbnQgPSB0aGlzLnNldFBhcmVudDtcbiAgdGhpcy5zZXRQYXJlbnQgPSBmdW5jdGlvbiAoc3BhY2UpIHtcbiAgICBpZiAoIShzcGFjZSBpbnN0YW5jZW9mIFNwYWNlKSkge1xuICAgICAgdGhyb3cgJ0EgVmlldyBjYW4gb25seSBiZSBhIGNoaWxkIG9mIGEgU3BhY2UnO1xuICAgIH1cbiAgICBzdXBlclNldFBhcmVudC5jYWxsKHRoaXMsIHNwYWNlKTtcbiAgfTtcblxuICAvLyBWaWV3IHJlYWR5IHRvIGJlIGFkZGVkIHRvIFNwYWNlLlxuICB0aGlzLnNldFBhcmVudChzcGFjZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxTcGFjZVZpZXc7XG4iLCIvKlxuRW1pdHNcbiAgY29udGVudEFkZGVkXG4gIGNvbnRlbnRSZW1vdmVkXG4gICAgbm90IHRocm93biBpZiB0aGUgY29udGVudCB0byByZW1vdmUgZGlkIG5vdCBleGlzdCBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gIGNvbnRlbnRUcmFuc2Zvcm1lZFxuKi9cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBTcGFjZU5vZGUgPSByZXF1aXJlKCcuL1NwYWNlTm9kZScpO1xudmFyIFNwYWNlUGxhbmUgPSByZXF1aXJlKCcuL1NwYWNlUGxhbmUnKTtcblxudmFyIFNwYWNlID0gZnVuY3Rpb24gKCkge1xuICBFbWl0dGVyKHRoaXMpO1xuXG4gIFNwYWNlTm9kZSh0aGlzKTtcbiAgLy8gVE9ETyByZW1vdmUgcG9zc2liaWxpdHkgdG8gYWRkIHRvIHBhcmVudC5cblxuICBTcGFjZVBsYW5lKHRoaXMpO1xuICAvLyBTcGFjZSBoYXMgY29uc3RhbnQgaWRlbnRpdHkgdHJhbnNmb3JtYXRpb24gX1Rcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2U7XG4iLCIvKlxuIyBTcGFjZUVsZW1lbnRcblxuQSBIVE1MRWxlbWVudCBbMV0gaW4gdGhlIHNwYWNlLlxuXG5bMV0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxFbGVtZW50XG4qL1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgU3BhY2VOb2RlID0gcmVxdWlyZSgnLi9TcGFjZU5vZGUnKTtcbnZhciBTcGFjZVBsYW5lID0gcmVxdWlyZSgnLi9TcGFjZVBsYW5lJyk7XG52YXIgU3BhY2VUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vU3BhY2VUcmFuc2Zvcm1lcicpO1xudmFyIFNwYWNlUmVjdGFuZ2xlID0gcmVxdWlyZSgnLi9TcGFjZVJlY3RhbmdsZScpO1xuXG52YXIgU3BhY2VIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAgIHBhcmVudDpcbiAgLy8gICAgIGEgU3BhY2VOb2RlXG4gIC8vICAgaHRtbDpcbiAgLy8gICAgIGEgc3RyaW5nLCBjb250YWluaW5nIGh0bWxcbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VOb2RlKHRoaXMpO1xuICBTcGFjZVBsYW5lKHRoaXMpO1xuICBTcGFjZVRyYW5zZm9ybWVyKHRoaXMpO1xuICBTcGFjZVJlY3RhbmdsZSh0aGlzKTtcblxuICB0aGlzLmh0bWwgPSBodG1sO1xuICB0aGlzLnJlc2l6ZShbMjU2LCAyNTZdKTsgIC8vIEluaXRpYWwgZWxlbWVudCBzaXplLlxuXG4gIHRoaXMuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5odG1sO1xuICB9O1xuXG4gIC8vIFJlYWR5XG4gIHRoaXMuc2V0UGFyZW50KHBhcmVudCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlSFRNTDtcbiIsIi8qXG5BUEkgdjMuMC4wXG5cbkVtaXRzXG4gIGNvbnRlbnRBZGRlZFxuICBjb250ZW50UmVtb3ZlZFxuICAgIG5vdCB0aHJvd24gaWYgdGhlIGNvbnRlbnQgdG8gcmVtb3ZlIGRpZCBub3QgZXhpc3QgaW4gdGhlIGZpcnN0IHBsYWNlLlxuKi9cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLy8gVW5pcXVlIElEIGdlbmVyYXRvci4gVW5pcXVlIG92ZXIgc2Vzc2lvbi5cbi8vIFVzYWdlOiBzZXFpZC5uZXh0KClcbi8vIFJldHVybjogaW50XG52YXIgc2VxaWQgPSByZXF1aXJlKCdzZXFpZCcpKDApO1xuXG52YXIgU3BhY2VOb2RlID0gZnVuY3Rpb24gKGVtaXR0ZXIpIHtcbiAgLy8gUGFyYW1ldGVyc1xuICAvLyAgIGVtaXR0ZXIsIGFuIEVtaXR0ZXIuXG5cbiAgLy8gRWFjaCBub2RlIGhhcyBhbiBpZC4gVGhhdCBpcyB1c2VkIGJ5IHRoZSBwYXJlbnQgbm9kZXMgYW5kIGluIHZpZXdzLlxuICBlbWl0dGVyLmlkID0gc2VxaWQubmV4dCgpLnRvU3RyaW5nKCk7XG5cbiAgLy8gTm9kZXMgd2l0aCBudWxsIHBhcmVudCBhcmUgcm9vdCBub2RlcyBpLmUuIHNwYWNlcy5cbiAgLy8gU3BhY2VOb2RlI3JlbW92ZSBzZXRzIF9wYXJlbnQgdG8gbnVsbC5cbiAgZW1pdHRlci5fcGFyZW50ID0gbnVsbDtcblxuICAvLyBEaWN0IG92ZXIgbGlzdCBiZWNhdXNlIGtleSBzZWFyY2ggdGltZSBjb21wbGV4aXR5XG4gIGVtaXR0ZXIuX2NoaWxkcmVuID0ge307XG5cbiAgLy8gV2UgbmVlZCB0byBzdG9yZSBidWlsdCBoYW5kbGVycyBib3VuZCB0byBjaGlsZHJlblxuICAvLyB0byBiZSBhYmxlIHRvIHJlbW92ZSB0aGUgaGFuZGxlcnMgd2hlbiBjaGlsZCBpcyByZW1vdmVkLlxuICBlbWl0dGVyLl9hZGRlZEhhbmRsZXJzID0ge307XG4gIGVtaXR0ZXIuX3JlbW92ZWRIYW5kbGVycyA9IHt9O1xuXG4gIGVtaXR0ZXIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGNoaWxkIFNwYWNlTm9kZXMgaW4gYSBsaXN0LlxuICAgIC8vIERvZXMgbm90IGluY2x1ZGUgdGhlIGNoaWxkcmVuIG9mIHRoZSBjaGlsZHJlbi5cbiAgICB2YXIgaWQsIGFyciwgb2JqO1xuICAgIGFyciA9IFtdO1xuICAgIG9iaiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGZvciAoaWQgaW4gb2JqKSB7XG4gICAgICBhcnIucHVzaChvYmpbaWRdKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBlbWl0dGVyLmdldERlc2NlbmRhbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEFsbCBkZXNjZW5kYW50cyBpbiBhIGxpc3QsIGluY2x1ZGluZyB0aGUgY2hpbGRyZW4uXG4gICAgdmFyIGksIGNoaWxkcmVuLCBjaGlsZCwgYXJyO1xuICAgIGFyciA9IFtdO1xuICAgIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGFyciA9IGFyci5jb25jYXQoY2hpbGQsIGNoaWxkLmdldERlc2NlbmRhbnRzKCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuXG4gIGVtaXR0ZXIuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG4gIH07XG5cbiAgZW1pdHRlci5nZXRSb290UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEdldCB0aGUgcHJlZGVjZXNzb3Igd2l0aG91dCBwYXJlbnRzIGluIHJlY3Vyc2l2ZSBtYW5uZXIuXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudC5nZXRSb290UGFyZW50KCk7XG4gIH07XG5cbiAgZW1pdHRlci5oYXNDaGlsZCA9IGZ1bmN0aW9uIChzcGFjZU5vZGUpIHtcbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIHRydWUgaWYgc3BhY2VOb2RlIGlzIGEgY2hpbGQgb2YgdGhpcy5cbiAgICByZXR1cm4gc3BhY2VOb2RlLl9wYXJlbnQgPT09IHRoaXM7XG4gIH07XG5cbiAgZW1pdHRlci5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVtb3ZlIHRoaXMgc3BhY2Ugbm9kZSBmcm9tIGl0cyBwYXJlbnQuXG4gICAgLy8gUmV0dXJuOiBzZWUgc2V0UGFyZW50XG4gICAgcmV0dXJuIHRoaXMuc2V0UGFyZW50KG51bGwpO1xuICB9O1xuXG4gIGVtaXR0ZXIuc2V0UGFyZW50ID0gZnVuY3Rpb24gKG5ld1BhcmVudCkge1xuICAgIC8vIEFkZCB0byBuZXcgcGFyZW50LlxuXG4gICAgdmFyIG9sZFBhcmVudCA9IHRoaXMuX3BhcmVudDtcblxuICAgIGlmIChvbGRQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmIChuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRnJvbSByb290IHRvIHJvb3QuXG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZyb20gcm9vdCB0byBjaGlsZC5cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2FkZENoaWxkKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoJ2FkZGVkJywgdGhpcywgdGhpcy5fcGFyZW50LCBudWxsKTtcbiAgICAgICAgbmV3UGFyZW50LmVtaXQoJ2NvbnRlbnRBZGRlZCcsIHRoaXMsIHRoaXMuX3BhcmVudCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRnJvbSBjaGlsZCB0byByb290LlxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsOyAvLyBCZWNvbWVzIG5ldyByb290IG5vZGUuXG4gICAgICAgIG9sZFBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbnVsbCk7XG4gICAgICAgIG9sZFBhcmVudC5lbWl0KCdjb250ZW50UmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGcm9tIGNoaWxkIHRvIGNoaWxkLlxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBuZXdQYXJlbnQ7XG4gICAgICAgIG9sZFBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIG5ld1BhcmVudC5fYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbmV3UGFyZW50KTtcbiAgICAgICAgdGhpcy5lbWl0KCdhZGRlZCcsIHRoaXMsIG5ld1BhcmVudCwgb2xkUGFyZW50KTtcbiAgICAgICAgLy8gV2l0aCBib3RoIG9sZFBhcmVudCBhbmQgbmV3UGFyZW50LCBTcGFjZVZpZXcgaXMgYWJsZSB0b1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciB0byBrZWVwIHNhbWUgSFRNTEVsZW1lbnQgb3IgcmVjcmVhdGUgaXQuXG4gICAgICAgIG9sZFBhcmVudC5lbWl0KCdjb250ZW50UmVtb3ZlZCcsIHRoaXMsIG9sZFBhcmVudCwgbmV3UGFyZW50KTtcbiAgICAgICAgbmV3UGFyZW50LmVtaXQoJ2NvbnRlbnRBZGRlZCcsIHRoaXMsIG5ld1BhcmVudCwgb2xkUGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICBlbWl0dGVyLl9hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIC8vIFRvIGJlIGNhbGxlZCBmcm9tIGNoaWxkLnNldFBhcmVudCgpLlxuICAgIC8vXG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIC8vICAgY2hpbGQsIEEgU3BhY2VOb2RlXG4gICAgLy9cbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIHVuZGVmaW5lZFxuICAgIC8vXG4gICAgLy8gRGV2LiBub3RlOlxuICAgIC8vICAgUHJldmlvdXNseSB0aGlzIHdhcyBjYWxsZWQgZnJvbSB0aGUgU3BhY2VOb2RlIGNvbnN0cnVjdG9yLlxuICAgIC8vICAgSG93ZXZlciwgYmVjYXVzZSBTcGFjZU5vZGUgdXBncmFkZSBpcyBkb25lIGJlZm9yZSBvdGhlclxuICAgIC8vICAgdXBncmFkZXMsIHRoZSBjaGlsZCB3b3VsZCBub3QgYmUgcmVhZHkgdG8gYmUgYWRkZWQgdG8gcGFyZW50LlxuXG4gICAgdmFyIHNjID0gY2hpbGQ7IC8vIGFsaWFzXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fY2hpbGRyZW5bc2MuaWRdID0gc2M7XG5cbiAgICAvLyBTdGFydCB0byBsaXN0ZW4gaWYgY2hpbGQgaGFzIGJlZWQgYWRkZWQsIHJlbW92ZWQgb3IgdHJhbnNmb3JtZWRcbiAgICB2YXIgYWRkZWRIYW5kbGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHNlbGYuZW1pdCgnY29udGVudEFkZGVkJywgYSwgYiwgYyk7XG4gICAgfTtcbiAgICB2YXIgcmVtb3ZlZEhhbmRsZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgc2VsZi5lbWl0KCdjb250ZW50UmVtb3ZlZCcsIGEsIGIsIGMpO1xuICAgIH07XG4gICAgLy8gYWRkZWQgYW5kIHJlbW92ZWQgZXZlbnRzIGFyZSBub3QgbGlzdGVuZWQgYmVjYXVzZVxuICAgIC8vIGZvciBhZnRlciBzdWNjZXNzZnVsbHkgbWFkZSBhZGQgb3IgcmVtb3ZlLFxuICAgIC8vIGNvbnRlbnRBZGRlZCBhbmQgY29udGVudFJlbW92ZWQgYXJlIGZpcmVkIGluIHNldFBhcmVudC5cbiAgICBzYy5vbignY29udGVudEFkZGVkJywgYWRkZWRIYW5kbGVyKTtcbiAgICBzYy5vbignY29udGVudFJlbW92ZWQnLCByZW1vdmVkSGFuZGxlcik7XG4gICAgdGhpcy5fYWRkZWRIYW5kbGVyc1tzYy5pZF0gPSBhZGRlZEhhbmRsZXI7XG4gICAgdGhpcy5fcmVtb3ZlZEhhbmRsZXJzW3NjLmlkXSA9IHJlbW92ZWRIYW5kbGVyO1xuICB9O1xuXG4gIGVtaXR0ZXIuX3JlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gVG8gYmUgY2FsbGVkIGZyb20gU3BhY2VOb2RlI3JlbW92ZVxuICAgIC8vIFByZWNvbmRpdGlvbjogY2hpbGQgaW4gc3BhY2VcbiAgICB2YXIgc2MsIGg7XG5cbiAgICBzYyA9IGNoaWxkOyAvLyBhbGlhc1xuICAgIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltzYy5pZF07XG5cbiAgICAvLyBSZW1vdmUgaGFuZGxlcnNcbiAgICBoID0gdGhpcy5fYWRkZWRIYW5kbGVyc1tzYy5pZF07XG4gICAgZGVsZXRlIHRoaXMuX2FkZGVkSGFuZGxlcnNbc2MuaWRdO1xuICAgIHNjLm9mZignY29udGVudEFkZGVkJywgaCk7XG5cbiAgICBoID0gdGhpcy5fcmVtb3ZlZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fcmVtb3ZlZEhhbmRsZXJzW3NjLmlkXTtcbiAgICBzYy5vZmYoJ2NvbnRlbnRSZW1vdmVkJywgaCk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlTm9kZTtcbiIsIi8qXG5TcGFjZVBsYW5lXG5BUEkgdjAuNi4wXG5cbkEgU3BhY2VQbGFuZSByZXByZXNlbnRzIGEgY29vcmRpbmF0ZSBzeXN0ZW0uIEl0IGRvZXMgbm90IGluY2x1ZGVcbm1ldGhvZHMgdG8gdHJhbnNmb3JtIHRoZSBzeXN0ZW0uIFNwYWNlUGxhbmUgYW5kIFNwYWNlVHJhbnNmb3JtZXIgYXJlIHNlcGFyYXRlZFxuYmVjYXVzZSB3ZSB3YW50IHRvIGhhdmUgcGxhbmVzIHRoYXQgY2Fubm90IGJlIHRyYW5zZm9ybWVkLCBhcyB0aGUgU3BhY2UuXG5cbiovXG5cbnZhciBudWRnZWQgPSByZXF1aXJlKCdudWRnZWQnKTtcbnZhciBTcGFjZVBvaW50ID0gcmVxdWlyZSgnLi9TcGFjZVBvaW50Jyk7XG5cbnZhciBhdCA9IGZ1bmN0aW9uICh4eSkge1xuICAvLyBSZXR1cm5cbiAgLy8gICBBIFNwYWNlUG9pbnQgYXQgKHgseSkgb24gdGhlIHBsYW5lLlxuICBpZiAoeHkubGVuZ3RoICE9PSAyKSB7ICAvLyBERUJVRyBUT0RPIHJlbW92ZSB0aGlzXG4gICAgdGhyb3cgJ0ludmFsaWQgcG9pbnQsIHVzZSBhcnJheSBbeCwgeV0nO1xuICB9XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eSwgdGhpcyk7ICAvLyBOb3RlOiB0aGlzID09PSBzcGFjZU5vZGVcbn07XG5cbnZhciBTcGFjZVBsYW5lID0gZnVuY3Rpb24gKHNwYWNlTm9kZSkge1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgc3BhY2VOb2RlXG4gIC8vICAgICBBIFNwYWNlTm9kZSB0byBtb25rZXkgcGF0Y2ggdG8gU3BhY2VQbGFuZVxuXG4gIC8vIENvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24uXG4gIC8vIFRoZSB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBwbGFuZSB0byB0aGUgcGFyZW50IChzcGFjZSkuXG4gIC8vIFNlZSAyMDE2LTAzLTA1LTA5XG4gIC8vIExldDpcbiAgLy8gICB4X3NwYWNlLCBhIHBvaW50IGluIHNwYWNlXG4gIC8vICAgeF9wbGFuZSwgYSBwb2ludCBvbiB0aGUgcGxhbmUuXG4gIC8vICAgVCwgdGhlIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHBsYW5lXG4gIC8vIFRoZW46XG4gIC8vICAgeF9zcGFjZSA9IFQgKiB4X3BsYW5lXG4gIC8vXG4gIC8vIEZvciBTcGFjZSwgaXQgaXMgb2J2aW91c2x5IHRoZSBpZGVudGl0eSB0cmFuc2Zvcm06XG4gIC8vICAgeF9zcGFjZSA9IFQgKiB4X3NwYWNlXG4gIHNwYWNlTm9kZS5fVCA9IG51ZGdlZC5UcmFuc2Zvcm0uSURFTlRJVFk7IC8vIGlkZW50aXR5IHRyYW5zZm9ybWF0aW9uXG5cbiAgc3BhY2VOb2RlLmF0ID0gYXQ7XG5cbiAgc3BhY2VOb2RlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBMb2NhbCB0cmFuc2Zvcm0gZnJvbSBwbGFuZSB0byBwYXJlbnRcbiAgICAvL1xuICAgIC8vIFJldHVyblxuICAgIC8vICAgdHJhbnNmb3JtYXRpb24gZnJvbSBwbGFuZSB0byBwYXJlbnQsIGkuZS5cbiAgICAvLyAgICAgeHlfcGFyZW50ID0gVCAqIHh5X3BsYW5lXG4gICAgLy8gTmVlZGVkIHdoZW4gd2Ugd2FudCB0byBzdG9yZSB0cmFuc2Zvcm1lcidzIHBvc2l0aW9uIGZvciBsYXRlciB1c2UuXG4gICAgcmV0dXJuIHRoaXMuX1Q7XG4gIH07XG5cbiAgc3BhY2VOb2RlLmdldEdsb2JhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm5cbiAgICAvLyAgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIHBsYW5lIHRvIHJvb3QgY29udGFpbmVyLlxuICAgIC8vXG4gICAgLy8gRGV2IG5vdGU6XG4gICAgLy8gICBMb2NhbCB0cmFuc2Zvcm1hdGlvbnMgZ28gbGlrZTpcbiAgICAvLyAgICAgeHlfcGFyZW50ID0gVF9wbGFuZSAqIHh5X3BsYW5lXG4gICAgLy8gICAgIHh5X3BhcmVudF9wYXJlbnQgPSBUX3BhcmVudCAqIHh5X3BhcmVudFxuICAgIC8vICAgICAuLi5cbiAgICAvLyAgICAgeHlfcm9vdCA9IFRfcGFyZW50X3BhcmVudC4uLl9wYXJlbnQgKiB4eV9wYXJlbnRfcGFyZW50Li4uX3BhcmVudFxuICAgIC8vICAgVGhlcmVmb3JlIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBpczpcbiAgICAvLyAgICAgeHlfcm9vdCA9IFRfcGFyZW50Xy4uLl9wYXJlbnQgKiAuLi4gKiBUX3BhcmVudCAqIFRfcGxhbmUgKiB4eV9wbGFuZVxuICAgIGlmICh0aGlzLl9wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gbWF5YmUgdG9vIGZhcjogdGhpcy5fcGFyZW50Ll9wYXJlbnQgbWlnaHQgYmUgc3VmZmljaWVudC5cbiAgICAgIHJldHVybiB0aGlzLl9UO1xuICAgIH0gLy8gZWxzZVxuICAgIHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0R2xvYmFsVHJhbnNmb3JtKCkubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgfTtcblxuICBzcGFjZU5vZGUucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQmVjb21lIHNwYWNlLiBDYWxsZWQgZS5nLiB3aGVuIHBsYW5lIGlzIHJlbW92ZWQgZnJvbSBwYXJlbnQuXG4gICAgdGhpcy5fVCA9IG51ZGdlZC5UcmFuc2Zvcm0uSURFTlRJVFk7XG4gIH07XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VQbGFuZTtcbiIsIi8vIEFQSSB2MC42LjBcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG5cbnZhciBTcGFjZVBvaW50ID0gZnVuY3Rpb24gKHh5LCByZWZlcmVuY2UpIHtcbiAgLy8gRXhhbXBsZVxuICAvLyAgIHZhciBwID0gdGFhc3BhY2UuU3BhY2VQb2ludChbeCwgeV0sIHRhYSk7XG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHh5XG4gIC8vICAgICAyRCBhcnJheVxuICAvLyAgIHJlZmVyZW5jZVxuICAvLyAgICAgYSBTcGFjZU5vZGUgb3IgU3BhY2VQb2ludFxuICAvLyAgICAgICBhbiBpdGVtIGluIHNwYWNlLCBlbmFibGluZyBjb29yZCBwcm9qZWN0aW9ucy5cbiAgdGhpcy54eSA9IHh5O1xuXG4gIC8vIFRoZSBTcGFjZVBsYW5lJ3MgdHJhbnNmb3JtYXRpb24gdGhlIHh5IGFyZSBvbi5cbiAgLy8gRGVzaWduIG5vdGU6IGF0IGZpcnN0LCB0aGUgcmVmZXJlbmNlcyB3ZXJlIFNwYWNlUGxhbmVzIGFuZCBub3RcbiAgLy8gdHJhbnNmb3JtYXRpb25zLiBCdXQgYmVjYXVzZSBhIFNwYWNlUGxhbmUgY2FuIG1vdmUgb3IgYmUgcmVtb3ZlZCxcbiAgLy8gd2UgY2hvc2Ugb25seSB0aGUgdHJhbnNmb3JtYXRpb24gdG8gYmUgcmVtZW1iZXJlZC5cbiAgLy8gRGVzaWduIG5vdGU6IGxhdGVyIHdlIGZvdW5kIGl0IHdvdWxkIGJlIGNvbnZlbmllbnQgZm9yIGRlYnVnZ2luZ1xuICAvLyB0byBrbm93IHdoZXJlIHRoZSBwb2ludCBjYW1lIGZyb20sIHdoaWNoIGxlZCB0byB0aGlzLl9vcmlnaW4uXG4gIC8vIEFmdGVyIHRoYXQgd2UgZm91bmQgdGhhdCBpbiB0b1NwYWNlIG1ldGhvZCwgd2Ugd291bGQgbmVlZCByZWZlcmVuY2VcbiAgLy8gdG8gc3BhY2UsIGFsdGhvdWdoIHdlIG9ubHkgaGF2ZSBpbXBsaWNpdCByZWZlcmVuY2UgdG8gaXRzIGNvb3Jkcy5cbiAgLy8gVGhlcmVmb3JlIHRoaXMuX29yaWdpbiB3YXMgZHJvcHBlZC5cblxuICBpZiAocmVmZXJlbmNlLmhhc093blByb3BlcnR5KCdnZXRHbG9iYWxUcmFuc2Zvcm0nKSkge1xuICAgIC8vIElzIGEgU3BhY2VQbGFuZVxuICAgIHRoaXMuX1QgPSByZWZlcmVuY2UuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXMgYSBTcGFjZVBvaW50XG4gICAgdGhpcy5fVCA9IHJlZmVyZW5jZS5fVDtcbiAgfVxufTtcblxudmFyIHByb3RvID0gU3BhY2VQb2ludC5wcm90b3R5cGU7XG5cbnByb3RvLmVxdWFscyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICByZXR1cm4gKHRoaXMueHlbMF0gPT09IHBvaW50Lnh5WzBdICYmXG4gICAgdGhpcy54eVsxXSA9PT0gcG9pbnQueHlbMV0gJiZcbiAgICB0aGlzLl9ULmVxdWFscyhwb2ludC5fVCkpO1xuICB9O1xuXG5wcm90by5vZmZzZXQgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBwb2ludCBuZWFyYnkuXG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIGR4XG4gIC8vICAgICBNb3ZlbWVudCB0b3dhcmRzIHBvc2l0aXZlIHhcbiAgLy8gICBkeVxuICAvLyAgICAgLi4uXG4gIHZhciB4eSA9IFt0aGlzLnh5WzBdICsgZHgsIHRoaXMueHlbMV0gKyBkeV07XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eSwgdGhpcyk7XG59O1xuXG5wcm90by5wb2xhck9mZnNldCA9IGZ1bmN0aW9uIChyYWRpdXMsIHJhZGlhbnMpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IG1vdmVkIGJ5IHRoZSBwb2xhciBjb29yZGluYXRlc1xuICB2YXIgeCA9IHRoaXMueHlbMF0gKyByYWRpdXMgKiBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgdmFyIHkgPSB0aGlzLnh5WzFdICsgcmFkaXVzICogTWF0aC5zaW4ocmFkaWFucyk7XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludChbeCwgeV0sIHRoaXMpO1xufTtcblxucHJvdG8udG8gPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBTcGFjZVBvaW50IGF0IHNhbWUgbG9jYXRpb24gYnV0IG9uIGFcbiAgLy8gZGlmZmVyZW50IFNwYWNlUGxhbmUuXG4gIC8vXG4gIC8vIFBhcmFtZXRlclxuICAvLyAgIHRhcmdldCwgYSBTcGFjZVBsYW5lIG9yIG51bGwuXG4gIC8vXG4gIC8vIEltcGxlbWVudGF0aW9uIG5vdGUgKFNlZSAyMDE2LTAzLTA1LTA5KTpcbiAgLy9cbiAgLy8gRmlyc3QsIGNvbXB1dGUgY29vcmQuIHRyYW5zZi4gQiBmcm9tIHRoZSBjdXJyZW50IHBsYW5lXG4gIC8vIHRvIHRoZSBzcGFjZTpcbiAgLy8gICB4X3NwYWNlID0gQiAqIHhfcGxhbmUgIDw9PiAgeF9wbGFuZSA9IGludihCKSAqIHhfc3BhY2VcbiAgLy8gICBCID0gcGxhbmUuX1RcbiAgLy8gU2Vjb25kLCBsZXQgQSBiZSBjb29yZC4gdHJhbnNmLiBmcm9tIHRoZSBzcGFjZSB0byB0aGUgdGFyZ2V0IHBsYW5lOlxuICAvLyAgIHhfdGFyZ2V0ID0gQSAqIHhfc3BhY2VcbiAgLy8gICBBID0gaW52KHRhcmdldC5fVClcbiAgLy8gVGhlcmVmb3JlIGNvbWJpbmVkIGNvb3JkLiB0cmFuc2YuIEMgZnJvbSB0aGUgY3Vyci4gcGxhbmUgdG8gdGhlIHRhcmdldDpcbiAgLy8gICB4X3RhcmdldCA9IEMgKiB4X3BsYW5lXG4gIC8vICAgPD0+IEEgKiB4X3NwYWNlID0gQyAqIGludihCKSAqIHhfc3BhY2VcbiAgLy8gICA8PT4gQSA9IEMgKiBpbnYoQilcbiAgLy8gICA8PT4gQyA9IEFCXG4gIC8vICAgPD0+IEMgPSBpbnYodGFyZ2V0Ll9UKSAqIHBsYW5lLl9UXG4gIC8vXG5cbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIHRhcmdldCBpcyB0aGUgcm9vdCBub2RlIChzcGFjZSlcbiAgICByZXR1cm4gdGhpcy50b1NwYWNlKCk7XG4gIH1cblxuICAvLyBUYXJnZXQncyBnbG9iYWwgdHJhbnNmb3JtYXRpb24uIFRoaXMuX1QgaXMgYWxyZWFkeSBnbG9iYWwuXG4gIHZhciB0YXJnZXRfZ1QgPSB0YXJnZXQuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG5cbiAgaWYgKHRhcmdldF9nVC5lcXVhbHModGhpcy5fVCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBlbHNlXG4gIHZhciBDID0gdGFyZ2V0X2dULmludmVyc2UoKS5tdWx0aXBseUJ5KHRoaXMuX1QpO1xuICB2YXIgeHlfdGFyZ2V0ID0gQy50cmFuc2Zvcm0odGhpcy54eSk7XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eV90YXJnZXQsIHRhcmdldCk7XG59O1xuXG5wcm90by50b1NwYWNlID0gZnVuY3Rpb24gKCkge1xuICAvLyBDcmVhdGUgYSBuZXcgU3BhY2VQb2ludCBhdCBzYW1lIGxvY2F0aW9uIGJ1dCByZXByZXNlbnRlZCBvbiBzcGFjZSBjb29yZHMuXG4gIC8vXG4gIC8vIEltcGxlbWVudGF0aW9uIG5vdGU6XG4gIC8vICAgV2UgYWxyZWFkeSBoYXZlIGNvb3JkLiB0cmFuc2YuIGZyb20gdGhlIGN1cnJlbnQgcGxhbmUgdG8gdGhlIHNwYWNlOlxuICAvLyAgICAgcGxhbmUuX1RcbiAgdmFyIHh5X3NwYWNlID0gdGhpcy5fVC50cmFuc2Zvcm0odGhpcy54eSk7XG4gIHZhciBzcGFjZV9tb2NrID0geydfVCc6IFRyYW5zZm9ybS5JREVOVElUWX07XG4gIHJldHVybiBuZXcgU3BhY2VQb2ludCh4eV9zcGFjZSwgc3BhY2VfbW9jayk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHIpIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IHBvaW50IGJ5IHRyYW5zZm9ybWF0aW9uLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJcbiAgLy8gICB0clxuICAvLyAgICAgYSBUcmFuc2Zvcm1cbiAgdmFyIHh5X2hhdCA9IHRyLnRyYW5zZm9ybSh0aGlzLnh5KTtcbiAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KHh5X2hhdCwgdGhpcyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3BhY2VQb2ludDtcbiIsIi8vIEFQSSB2My4wLjBcblxudmFyIFNwYWNlUG9pbnQgPSByZXF1aXJlKCcuL1NwYWNlUG9pbnQnKTtcblxudmFyIFNwYWNlUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHNwYWNlVHJhbnNmb3JtZXIpIHtcblxuICB2YXIgdCA9IHNwYWNlVHJhbnNmb3JtZXI7ICAvLyBBbGlhc1xuXG4gIC8vIFJlY3RhbmdsZXMgaGF2ZSBzaXplLlxuICAvLyBJbiBpdHMgb3duIGNvb3JkaW5hdGVzLCByZWN0YW5nbGUncyByaWdodCBib3R0b20gY29ybmVyXG4gIC8vIGlzIGxvY2F0ZWQgYXQgW3dpZHRoLCBoZWlnaHRdLlxuICAvLyBCeSBkZWZhdWx0IHRyYW5zZm9ybWF0aW9uLCB3aWR0aCAxIGFuZCBoZWlnaHQgMSBlcXVhbCB0byAxIHNwYWNlIHVuaXQuXG4gIHZhciB3aWR0aCA9IDE7XG4gIHZhciBoZWlnaHQgPSAxO1xuXG4gIHQuYXROb3JtID0gZnVuY3Rpb24gKHh5KSB7XG4gICAgLy8gUmV0dXJuIGEgU3BhY2VQb2ludCBieSBjb29yZGluYXRlcyBub3JtYWxpemVkIGFib3V0IHRoZSBzaXplLlxuICAgIC8vIGF0Tm9ybShbMSwwXSkgcmV0dXJucyB0aGUgcG9pbnQgYXQgdGhlIHJpZ2h0IHVwcGVyIGNvcm5lci5cbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoICogeHlbMF0sIGhlaWdodCAqIHh5WzFdXSwgdCk7XG4gIH07XG5cbiAgdC5hdE1pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFNwYWNlUG9pbnQoW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWROID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGggLyAyLCAwXSwgdCk7XG4gIH07XG5cbiAgdC5hdE1pZFcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFswLCBoZWlnaHQgLyAyXSwgdCk7XG4gIH07XG5cbiAgdC5hdE1pZEUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCwgaGVpZ2h0IC8gMl0sIHQpO1xuICB9O1xuXG4gIHQuYXRNaWRTID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGggLyAyLCBoZWlnaHRdLCB0KTtcbiAgfTtcblxuICB0LmF0TlcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFswLCAwXSwgdCk7XG4gIH07XG5cbiAgdC5hdE5FID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgU3BhY2VQb2ludChbd2lkdGgsIDBdLCB0KTtcbiAgfTtcblxuICB0LmF0U1cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFswLCBoZWlnaHRdLCB0KTtcbiAgfTtcblxuICB0LmF0U0UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTcGFjZVBvaW50KFt3aWR0aCwgaGVpZ2h0XSwgdCk7XG4gIH07XG5cbiAgdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbd2lkdGgsIGhlaWdodF07XG4gIH07XG5cbiAgdC5yZXNpemUgPSBmdW5jdGlvbiAoZGltZW5zaW9ucykge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgZGltZW5zaW9ucywgW3dpZHRoLCBoZWlnaHRdXG4gICAgd2lkdGggPSBkaW1lbnNpb25zWzBdO1xuICAgIGhlaWdodCA9IGRpbWVuc2lvbnNbMV07XG5cbiAgICB0aGlzLmVtaXQoJ3Jlc2l6ZWQnLCB0KTtcbiAgfTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZVJlY3RhbmdsZTtcbiIsIi8vIEFQSSB2MC42LjBcblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFNwYWNlTm9kZSA9IHJlcXVpcmUoJy4vU3BhY2VOb2RlJyk7XG52YXIgU3BhY2VQbGFuZSA9IHJlcXVpcmUoJy4vU3BhY2VQbGFuZScpO1xudmFyIFNwYWNlVHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuL1NwYWNlVHJhbnNmb3JtZXInKTtcbnZhciBTcGFjZVJlY3RhbmdsZSA9IHJlcXVpcmUoJy4vU3BhY2VSZWN0YW5nbGUnKTtcblxudmFyIFNwYWNlVGFhID0gZnVuY3Rpb24gKHBhcmVudCwgdGFhKSB7XG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICAgcGFyZW50XG4gIC8vICAgICBhIFNwYWNlTm9kZVxuICAvLyAgIHRhYVxuICAvLyAgICAgYSBUYWFcbiAgRW1pdHRlcih0aGlzKTtcbiAgU3BhY2VOb2RlKHRoaXMpO1xuICBTcGFjZVBsYW5lKHRoaXMpO1xuICBTcGFjZVRyYW5zZm9ybWVyKHRoaXMpO1xuICBTcGFjZVJlY3RhbmdsZSh0aGlzKTtcblxuICB0aGlzLnRhYSA9IHRhYTtcbiAgdGhpcy5yZXNpemUoWzI1NiwgMjU2XSk7ICAvLyBTaXplIG9mIHRhYS5cblxuICB0aGlzLnNldFBhcmVudChwYXJlbnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFjZVRhYTtcbiIsIi8vIEFQSSB2My4wLjBcbnZhciBudWRnZWQgPSByZXF1aXJlKCdudWRnZWQnKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xudmFyIFNwYWNlUG9pbnQgPSByZXF1aXJlKCcuL1NwYWNlUG9pbnQnKTtcblxudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwb2ludHMsIHBsYW5lKSB7XG4gIC8vIFRyYW5zZm9ybSBhbGwgdGhlIHBvaW50cyBvbnRvIHRoZSBwYXJlbnQgYW5kXG4gIC8vIHJlcHJlc2VudCB0aGVtIGluIGFycmF5IFtbeDAseTBdLCBbeDEseTFdLCAuLi5dLlxuICAvL1xuICAvLyBBcmd1bWVudHM6XG4gIC8vICAgcG9pbnRzLCBhIHNpbmdsZSBzcGFjZXBvaW50IG9yIGEgbGlzdCBvZiBzcGFjZXBvaW50c1xuICAvLyAgIHBsYW5lLCBhIFNwYWNlUGxhbmUgZS5nLiBhIFNwYWNlVGFhIG9udG8gbm9ybWFsaXplLlxuICAvLyBSZXR1cm46XG4gIC8vICAgYXJyYXkgb2YgeHkgcG9pbnRzIGluIHNwYWNlLlxuICB2YXIgaSwgcCwgbnAsIG5vcm1hbGl6ZWQ7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpIHtcbiAgICAvLyBTaW5nbGUgU3BhY2VQb2ludFxuICAgIHAgPSBwb2ludHM7XG4gICAgbnAgPSBwLnRvKHBsYW5lKS54eTtcbiAgICByZXR1cm4gW25wXTtcbiAgfSAvLyBlbHNlXG4gIG5vcm1hbGl6ZWQgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgbnAgPSBwLnRvKHBsYW5lKS54eTtcbiAgICBub3JtYWxpemVkLnB1c2gobnApO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG52YXIgdHJhbnNmb3JtQnlFc3RpbWF0ZSA9IGZ1bmN0aW9uIChwbGFuZSwgdHlwZSwgZG9tYWluLCByYW5nZSwgcGl2b3QpIHtcbiAgLy8gVHlwZXM6IFQsUyxSLFRTLFRSLFNSLFRTUiAoc2VlIG51ZGdlZCBmb3IgZnVydGhlciBkZXRhaWxzKVxuXG4gIHZhciBub3JtUGl2b3Q7XG4gIGlmICh0eXBlb2YgcGl2b3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCBwbGFuZS5fcGFyZW50KVswXTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgYWxsIFNwYWNlUG9pbnRzIG9udG8gdGhlIHNwYWNlIGFuZCB0byBhcnJheXNcbiAgdmFyIG5vcm1Eb21haW4gPSBub3JtYWxpemUoZG9tYWluLCBwbGFuZS5fcGFyZW50KTtcbiAgdmFyIG5vcm1SYW5nZSA9IG5vcm1hbGl6ZShyYW5nZSwgcGxhbmUuX3BhcmVudCk7XG5cbiAgLy8gVGhlbiBjb21wdXRlIG9wdGltYWwgdHJhbnNmb3JtYXRpb24gaW4gc3BhY2VcbiAgdmFyIEhfc3BhY2UgPSBudWRnZWQuZXN0aW1hdGUodHlwZSwgbm9ybURvbWFpbiwgbm9ybVJhbmdlLCBub3JtUGl2b3QpO1xuICAvLyBTZWUgMjAxNi0wMy0wNS0xMTpcbiAgLy8gICBUbyBhcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBhIHNwYWNlIG9iamVjdDpcbiAgLy8gICAgIFRfaGF0ID0gdG9QYXJlbnQoSCkgKiBUXG4gIC8vIFRoZXJlZm9yZTpcbiAgcGxhbmUuX1QgPSBIX3NwYWNlLm11bHRpcGx5QnkocGxhbmUuX1QpO1xuXG4gIC8vIE5vdGlmeSBlc3BlY2lhbGx5IHZpZXcgYWJvdXQgdHJhbnNmb3JtYXRpb24uXG4gIHBsYW5lLmVtaXQoJ3RyYW5zZm9ybWVkJywgcGxhbmUpO1xufTtcblxuXG52YXIgU3BhY2VUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChwbGFuZSkge1xuICAvL1xuICAvLyBQYXJhbWV0ZXJzXG4gIC8vICAgcGxhbmVcbiAgLy8gICAgIGEgU3BhY2VQbGFuZVxuXG4gIHBsYW5lLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChUKSB7XG4gICAgLy8gTmVlZGVkIHdoZW4gd2Ugd2hhbiB0byByZXN0b3JlIHN0b3JlZCBwb3NpdGlvbiwgbWF5YmUgYWZ0ZXJcbiAgICAvLyBtb2RpZmljYXRpb24uXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgYXJlIHJvb3QsIGNhbm5vdCBzZXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX1QgPSBUO1xuICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgfTtcblxuICBwbGFuZS5zZXRHbG9iYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoVCkge1xuICAgIC8vIFNldCBsb2NhbCB0cmFuc2Zvcm0gc28gdGhhdCB0aGUgZ2xvYmFsIHRyYW5zZm9ybSBiZWNvbWVzIHRoZSBnaXZlbiBULlxuICAgIC8vXG4gICAgLy8gRGV2IG5vdGU6XG4gICAgLy8gICBHaXZlbiBUIGlzIGNvb3JkLiB0cmFuc2YuIGZyb20gdGhlIHBsYW5lIHRvIHJvb3QgKHNwYWNlKS5cbiAgICAvLyAgIFNvIGlzIHRoaXMuX1QuXG4gICAgLy8gICBjdXJyZW50X2dsb2JfdHJhbnMgPSBwYXJlbnRfZ2xvYl90cmFucyAqIHRoaXNfVFxuICAgIC8vICAgbmV3X2dsb2JfdHJhbnMgPSBwYXJlbnRfZ2xvYl90cmFucyAqIFhcbiAgICAvLyAgIDw9PiBYID0gaW52KHBhcmVudF9nbG9iX3RyYW5zKSAqIG5ld19nbG9iX3RyYW5zXG4gICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UgYXJlIHJvb3QsIGNhbm5vdCBzZXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJlbnRfZ2xvYmFsID0gdGhpcy5fcGFyZW50LmdldEdsb2JhbFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX1QgPSBwYXJlbnRfZ2xvYmFsLmludmVyc2UoKS5tdWx0aXBseUJ5KFQpO1xuICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgfTtcblxuICBwbGFuZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZG9tYWluLCByYW5nZSkge1xuICAgIC8vIE1vdmUgcGxhbmUgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5IGJ5IGV4YW1wbGUuXG4gICAgLy9cbiAgICAvLyBUcmFuc2xhdGUgdGhlIHBsYW5lIHNvIHRoYXQgYWZ0ZXIgdGhlIHRyYW5zbGF0aW9uLCB0aGUgZG9tYWluIHBvaW50c1xuICAgIC8vIHdvdWxkIGJlIGFzIGNsb3NlIHRvIGdpdmVuIHJhbmdlIHBvaW50cyBhcyBwb3NzaWJsZS5cbiAgICAvL1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgZG9tYWluXG4gICAgLy8gICByYW5nZVxuXG4gICAgdHJhbnNmb3JtQnlFc3RpbWF0ZSh0aGlzLCAnVCcsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIHBsYW5lLnNjYWxlID0gZnVuY3Rpb24gKHBpdm90LCBtdWx0aXBsaWVyT3JEb21haW4sIHJhbmdlKSB7XG4gICAgLy8gUGFyYW1ldGVyXG4gICAgLy8gICBwaXZvdCwgYSBTcGFjZVBvaW50XG4gICAgLy8gICBtdWx0aXBsaWVyLCB0aGUgc2NhbGUgZmFjdG9yLCA+IDBcbiAgICAvLyAgT1JcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB2YXIgdXNlTXVsdGlwbGllciA9ICh0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKTtcblxuICAgIGlmICh1c2VNdWx0aXBsaWVyKSB7XG4gICAgICB2YXIgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCB0aGlzLl9wYXJlbnQpWzBdO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyT3JEb21haW47XG4gICAgICAvLyBNdWx0aXBsaWVyIGRvZXMgbm90IGRlcGVuZCBvbiBwbGFuZS5cbiAgICAgIC8vIFdlIGNyZWF0ZSBhIHBpdm90ZWQgc2NhbGluZyB0cmFuc2Zvcm0gb24gcGFyZW50LlxuICAgICAgdmFyIFNfcGFyZW50ID0gVHJhbnNmb3JtLklERU5USVRZLnNjYWxlQnkobXVsdGlwbGllciwgbm9ybVBpdm90KTtcbiAgICAgIC8vIFNlZSAyMDE2LTAzLTA1LTExXG4gICAgICAvLyAgIFdlIHRyYW5zZm9ybSBzcGFjZSBvYmplY3RzIGJ5OlxuICAgICAgLy8gICBUX2hhdCA9IEhfc3BhY2UgKiBUXG4gICAgICB0aGlzLl9UID0gU19wYXJlbnQubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvbWFpbiA9IG11bHRpcGxpZXJPckRvbWFpbjtcbiAgICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1MnLCBkb21haW4sIHJhbmdlLCBwaXZvdCk7XG4gICAgfVxuICB9O1xuXG4gIHBsYW5lLnJvdGF0ZSA9IGZ1bmN0aW9uIChwaXZvdCwgcmFkaWFuc09yRG9tYWluLCByYW5nZSkge1xuICAgIC8vIFBhcmFtZXRlclxuICAgIC8vICAgcGl2b3RcbiAgICAvLyAgIHJhZGlhbnNcbiAgICAvLyAgT1JcbiAgICAvLyAgIHBpdm90XG4gICAgLy8gICBkb21haW5cbiAgICAvLyAgIHJhbmdlXG5cbiAgICB2YXIgdXNlUmFkaWFucyA9ICh0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKTtcblxuICAgIGlmICh1c2VSYWRpYW5zKSB7XG4gICAgICB2YXIgbm9ybVBpdm90ID0gbm9ybWFsaXplKHBpdm90LCB0aGlzLl9wYXJlbnQpWzBdO1xuICAgICAgdmFyIHJhZGlhbnMgPSByYWRpYW5zT3JEb21haW47XG4gICAgICAvLyBSYWRpYW5zIGRvIG5vdCBkZXBlbmQgb24gcGxhbmUuXG4gICAgICAvLyBXZSBjcmVhdGUgYSBwaXZvdGVkIHJvdGF0aW9uIHRyYW5zZm9ybSBvbiBwYXJlbnQuXG4gICAgICB2YXIgUl9wYXJlbnQgPSBUcmFuc2Zvcm0uSURFTlRJVFkucm90YXRlQnkocmFkaWFucywgbm9ybVBpdm90KTtcbiAgICAgIC8vIFNlZSAyMDE2LTAzLTA1LTExXG4gICAgICAvLyAgIFdlIHRyYW5zZm9ybSBzcGFjZSBvYmplY3RzIGJ5OlxuICAgICAgLy8gICBUX2hhdCA9IEhfc3BhY2UgKiBUXG4gICAgICB0aGlzLl9UID0gUl9wYXJlbnQubXVsdGlwbHlCeSh0aGlzLl9UKTtcbiAgICAgIHRoaXMuZW1pdCgndHJhbnNmb3JtZWQnLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvbWFpbiA9IHJhZGlhbnNPckRvbWFpbjtcbiAgICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1InLCBkb21haW4sIHJhbmdlLCBwaXZvdCk7XG4gICAgfVxuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZVNjYWxlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1RTJywgZG9tYWluLCByYW5nZSk7XG4gIH07XG5cbiAgcGxhbmUudHJhbnNsYXRlUm90YXRlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1RSJywgZG9tYWluLCByYW5nZSk7XG4gIH07XG5cbiAgcGxhbmUuc2NhbGVSb3RhdGUgPSBmdW5jdGlvbiAocGl2b3QsIGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1NSJywgZG9tYWluLCByYW5nZSwgcGl2b3QpO1xuICB9O1xuXG4gIHBsYW5lLnRyYW5zbGF0ZVNjYWxlUm90YXRlID0gZnVuY3Rpb24gKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICAvLyBQYXJhbWV0ZXJcbiAgICAvLyAgIGRvbWFpblxuICAgIC8vICAgcmFuZ2VcblxuICAgIHRyYW5zZm9ybUJ5RXN0aW1hdGUodGhpcywgJ1RTUicsIGRvbWFpbiwgcmFuZ2UpO1xuICB9O1xuXG4gIC8vIHBsYW5lLnRyYW5zbGF0ZUFuZFNjYWxlVG9GaXQsIG5vdCBzdXJlIGlmIG5lY2Vzc2FyeSBmb3Igbm93XG5cbiAgcGxhbmUub24oJ3JlbW92ZWQnLCBmdW5jdGlvbiAoc2VsZiwgb2xkUGFyZW50LCBuZXdQYXJlbnQpIHtcbiAgICAvLyBNYWludGFpbiBnbG9iYWwgbG9jYXRpb25cblxuICAgIGlmICh0eXBlb2Ygb2xkUGFyZW50ID09PSAndW5kZWZpbmVkJykgeyBvbGRQYXJlbnQgPSBudWxsOyB9XG4gICAgaWYgKHR5cGVvZiBuZXdQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7IG5ld1BhcmVudCA9IG51bGw7IH1cblxuICAgIHZhciBzYW1lUm9vdDtcbiAgICBpZiAobmV3UGFyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBSb290IG5vZGVzIGNhbm5vdCBtb3ZlLlxuICAgICAgdGhpcy5yZXNldFRyYW5zZm9ybSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob2xkUGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFJlbW92ZWQgZnJvbSBudWxsIHBhcmVudD9cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignQ2Fubm90IHJlbW92ZSBmcm9tIG51bGwgcGFyZW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3ZlZCBvbnRvIGFub3RoZXIgcGFyZW50LlxuICAgICAgICAvLyBMZXQgdXMga2VlcCB0aGUgbG9jYXRpb24gaW4gc3BhY2UgdGhlIHNhbWUgaWYgcG9zc2libGUuXG4gICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIG9ubHkgaWYgdGhlIHBhcmVudHMgc2hhcmUgc2FtZSByb290IGkuZS5cbiAgICAgICAgLy8gYXJlIGluIHRoZSBzYW1lIHNwYWNlLlxuICAgICAgICBzYW1lUm9vdCA9IG9sZFBhcmVudC5nZXRSb290UGFyZW50KCkgPT09IG5ld1BhcmVudC5nZXRSb290UGFyZW50KCk7XG4gICAgICAgIGlmIChzYW1lUm9vdCkge1xuICAgICAgICAgIC8vIEtlZXAgdGhlIGxvY2F0aW9uLlxuICAgICAgICAgIC8vIExldFxuICAgICAgICAgIC8vICAgT1QgYmUgdGhlIG9sZCBsb2NhbCBjb29yZC4gdHJhbnNmb3JtYXRpb24uXG4gICAgICAgICAgLy8gICBOVCBiZSB0aGUgdW5rbm93biBuZXcgbG9jYWwgY29vcmQuIHRyYW5zZi5cbiAgICAgICAgICAvLyAgIE9QR1QgYmUgdGhlIGdsb2JhbCBjb29yZC4gdHJhbnNmLiBvZiBvbGQgcGFyZW50XG4gICAgICAgICAgLy8gICBOUEdUIGJlIHRoZSBnbG9iYWwgY29vcmQuIHRyYW5zZi4gb2YgbmV3IHBhcmVudFxuICAgICAgICAgIC8vIE5vdywgd2Ugd2FudCB0byBrZWVwIGdsb2JhbCB0cmFuc2YuIHVuY2hhbmdlZC5cbiAgICAgICAgICAvLyAgIE9QR1QgKiBPVCA9IE5QR1QgKiBOVFxuICAgICAgICAgIC8vICAgPD0+IE5UID0gaW52KE5QR1QpICogT1BHVCAqIE9UXG4gICAgICAgICAgdmFyIG9wZ3QgPSBvbGRQYXJlbnQuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gICAgICAgICAgdmFyIG5wZ3QgPSBuZXdQYXJlbnQuZ2V0R2xvYmFsVHJhbnNmb3JtKCk7XG4gICAgICAgICAgdmFyIG90ID0gdGhpcy5fVDtcbiAgICAgICAgICB2YXIgbnQgPSBucGd0LmludmVyc2UoKS5tdWx0aXBseUJ5KG9wZ3QpLm11bHRpcGx5Qnkob3QpO1xuICAgICAgICAgIHRoaXMuX1QgPSBudDtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zZm9ybWVkJywgdGhpcyk7IC8vIFRPRE8gSXMgbmVlZGVkIGJlY2F1c2UgaW5wbGFjZT9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbiBkaWZmZXJlbnQgc3BhY2U6IHJlc2V0XG4gICAgICAgICAgdGhpcy5yZXNldFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IHRoZXJlIGNvdWxkIGJlIGEgbmVlZCB0byBjaGFuZ2UgcGFyZW50IHdpdGggdGhlIHNhbWVcbiAgICAgICAgLy8gbG9jYWwgdHJhbnNmb3JtYXRpb24uIE5vdCBuZWVkZWQgZm9yIG5vdy5cbiAgICAgIH1cblxuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYWNlVHJhbnNmb3JtZXI7XG4iLCIvLyBBUEkgdjAuNi4wXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgbG9hZGltYWdlcyA9IHJlcXVpcmUoJ2xvYWRpbWFnZXMnKTtcblxudmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIFRhYSA9IGZ1bmN0aW9uIChpbWdTcmMsIG9uTG9hZGVkKSB7XG4gIC8vIFBhcmFtZXRlcnNcbiAgLy8gICBpbWdTcmNcbiAgLy8gICBvbkxvYWRlZChlcnIsIHRhYSlcbiAgLy8gICAgIG9wdGlvbmFsLCBmdW5jdGlvbiAodGFhKVxuICBFbWl0dGVyKHRoaXMpO1xuICB2YXIgdGhpczIgPSB0aGlzO1xuXG4gIC8vIG9uTG9hZGVkIGlzIG9wdGlvbmFsXG4gIGlmICh0eXBlb2Ygb25Mb2FkZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkxvYWRlZCA9IE5PT1A7XG4gIH1cblxuICAvLyBUaGlzIG9iamVjdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgcmVhbCBJbWFnZSBvYmplY3QgYnV0IGJlZm9yZSB0aGF0XG4gIC8vIHNyYyBpcyBuZWVkZWQgaW4gU3BhY2VWaWV3LlxuICB0aGlzLmltYWdlID0geyBzcmM6IGltZ1NyYyB9O1xuXG4gIC8vIElmIHRoZSBpbWFnZSBpcyBjYWNoZWQsIHRoZSAnbG9hZCcgZXZlbnQgb2YgSW1hZ2UgZWxlbWVudCBpc1xuICAvLyBmaXJlZCBpbnN0YW50bHkgd2hlbiBjYWxsaW5nIGxvYWRpbWFnZXMuIElmIHdlIGRpZCBub3QgY2FyZVxuICAvLyBhYm91dCB0aGlzLCB0aGUgb24oJ2xvYWRlZCcsIGZuKSBsaXN0ZW5lcnMgd291bGQgZXhwZXJpZW5jZVxuICAvLyBkaWZmZXJlbnQgZXhlY3V0aW9uIG9yZGVyIGRlcGVuZGluZyB3aGV0aGVyIHRoZSBpbWFnZXMgd2FzXG4gIC8vIGNhY2hlZCBvciBub3QuXG4gIHZhciBub3RDYWNoZWQgPSBmYWxzZTtcblxuICBsb2FkaW1hZ2VzKGltZ1NyYywgZnVuY3Rpb24gKGVyciwgaW1hZ2UpIHtcbiAgICB2YXIgZW1pdGVyciwgZW1pdHRhYTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlbWl0ZXJyID0gZXJyO1xuICAgICAgZW1pdHRhYSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMyLmltYWdlID0gaW1hZ2U7XG4gICAgICBlbWl0ZXJyID0gbnVsbDtcbiAgICAgIGVtaXR0YWEgPSB0aGlzMjtcbiAgICB9XG5cbiAgICBpZiAobm90Q2FjaGVkKSB7XG4gICAgICB0aGlzMi5lbWl0KCdsb2FkZWQnLCBlbWl0ZXJyLCBlbWl0dGFhKTtcbiAgICAgIG9uTG9hZGVkKGVtaXRlcnIsIGVtaXR0YWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQb3N0cG9uZSBlbWl0dGluZyBvZiB0aGUgbG9hZGVkIGV2ZW50XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpczIuZW1pdCgnbG9hZGVkJywgZW1pdGVyciwgZW1pdHRhYSk7XG4gICAgICAgIG9uTG9hZGVkKGVtaXRlcnIsIGVtaXR0YWEpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9KTtcblxuICBub3RDYWNoZWQgPSB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUYWE7XG4iLCIvLyBBUEkgdjAuNi4wXG52YXIgbnVkZ2VkID0gcmVxdWlyZSgnbnVkZ2VkJyk7XG5cbi8vIFRPRE9cbi8vIG1vbmtleXBhdGNoIFwidG8ocGxhbmUpXCJcblxubW9kdWxlLmV4cG9ydHMgPSBudWRnZWQuVHJhbnNmb3JtO1xuIiwiXG5leHBvcnRzLlRhYSA9IHJlcXVpcmUoJy4vVGFhJyk7XG5leHBvcnRzLlNwYWNlVGFhID0gcmVxdWlyZSgnLi9TcGFjZVRhYScpO1xuZXhwb3J0cy5TcGFjZUhUTUwgPSByZXF1aXJlKCcuL1NwYWNlSFRNTCcpO1xuZXhwb3J0cy5TcGFjZSA9IHJlcXVpcmUoJy4vU3BhY2UnKTtcbmV4cG9ydHMuSFRNTFNwYWNlVmlldyA9IHJlcXVpcmUoJy4vSFRNTFNwYWNlVmlldycpO1xuXG5leHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gJzMuMC4wJztcbiJdfQ==
